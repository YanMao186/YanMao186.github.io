<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程是一门艺术</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-17T13:31:56.752Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yan Mao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java编程思想第二十章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第二十章/</id>
    <published>2019-11-17T13:19:16.000Z</published>
    <updated>2019-11-17T13:31:56.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二十章-注解"><a href="#第二十章-注解" class="headerlink" title="第二十章 注解"></a>第二十章 注解</h2><ul><li>==注解(也被称为元数据)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。==</li><li>注解是众多引入到Java SE5中的重要地语言变化之一，它们可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。</li><li>注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写“样板”代码的负担。</li><li>注解的优点：==更加干净易读的代码以及编译期类型检查等==。</li><li>Java SE5中内置了三种注解，定义在java.lang中：<ul><li><strong>@Override</strong>：表示当前方法定义将覆盖超类中的方法。</li><li><strong>@Deprecated</strong>:如果使用了注解为他的元素。那么编译器会发出警告信息。</li><li><strong>@SuppressWarnings</strong>:关闭不当的编译器警告信息。在Java  SE5之前的版本中，也可以使用该注解，不过忽略会被忽略不起作用。</li></ul></li><li>每当你创建描述符性质的类或者接口时，一旦其中包括了重复性的工作。那就可以考虑使用注解来简化自动化该过程。</li><li>注解是真正的语言级的概念。一旦构造出来，就享有编译期的类型检查保护。注解(annotation)是在实际的源代码级别保存所有的信息。而不是某种注释性的文字(comment)，这使得代码更简洁，且便于维护。</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul><li><p>下面使用<strong>@Test</strong>对<strong>testExecute()</strong>方法进行注解，该注解本身并不做任何事情，但是编译器要确保在其构造路径上必须有<strong>@Test注</strong>解的定义。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面中注解的方法与其他的方法没有任何区别，注解<strong>@Test</strong>可以与任何修饰共同作用与方法，如<strong>public</strong>,<strong>static</strong>,<strong>void</strong>，注解的使用方式几乎与修饰符的使用一模一样。</p></li></ul><h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><ul><li><p>下面是注解<strong>@Test</strong>的定义，可以看到，注解的定义看起来很像接口，事实上，与其他任何<strong>Java</strong>接口一样，注解也将会编译成class文件。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    Class&lt;? extends Throwable&gt; expected() <span class="keyword">default</span> Test.None.class;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">None</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Test</strong>的定义很像一个空的接口，定义注解时，会需要一些元注解，如<strong>@Target</strong>和<strong>@Retention</strong>。<strong>@Target</strong>用来定义你的注解将应用于什么地方(如是一个方法或是一个域)。<strong>@Retention</strong>用来定义该注解在那一个级别可用，在源代码中(<strong>SOURCE</strong>)，类文件中(<strong>CLASS</strong>)，或运行时(<strong>RUNTIME</strong>)。</p></li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>Java目前内置了四种元注解，元注解专门负责注解其他的注解。</li></ul><table><thead><tr><th>名称</th><th>概述</th></tr></thead><tbody><tr><td><strong>@Target</strong></td><td>表示该注解可以用于什么地方，可能的<strong>ElementType</strong>参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>:域声明(包括enum实例)<br><strong>LOCAL_VARIABLE</strong>:局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>:参数声明<br><strong>TYPE</strong>:类，接口(包括注解类型)或<strong>enum</strong>声明</td></tr><tr><td><strong>@Retention</strong></td><td>表示需要在什么级别保存该注解信息。可选的<strong>RetentionPolicy</strong>参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃。<br><strong>CLASS</strong>:注解在class文件中可用，但会被VM丢弃。<br><strong>RUNTIME</strong>:VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td></tr><tr><td><strong>@Documented</strong></td><td>此注解包含在Javadoc中。</td></tr><tr><td><strong>@Inherited</strong></td><td>允许子类继承父类中的注解。</td></tr></tbody></table><h3 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h3><ul><li><p>使用注解的过程中，很重要的一部分就是创建与使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员构造这类工具，它还提供了一个外部工具apt帮助程序员解析带有注解的Java源代码。</p></li><li><p>下面编写一个注解处理器，用它来读取PasswordUtils类，并使用反射机制查找@UseCase标记。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>,description = <span class="string">"password must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>,description = <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(List&lt;String&gt; prevPasswords,String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(password);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases,Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case:"</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : useCases) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Warning:Missing use case"</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collections.addAll(useCases,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>);</span><br><span class="line">        trackUseCases(useCases,PasswordUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Found Use Case:47 password must contain at least one numeric</span></span><br><span class="line"><span class="comment">Found Use Case:48 no description</span></span><br><span class="line"><span class="comment">Found Use Case:49 New passwords can't equal previously used ones</span></span><br><span class="line"><span class="comment">Warning:Missing use case50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>上面用到了两个反射的方法：<strong>getDeclaredMethods()</strong>和<strong>getAnnotation()</strong>，<strong>getAnnotation()</strong>返回指定类型的注解对象，此处就是<strong>UseCase</strong>,如果被注解的方法上没有该类型的注解，则返回<strong>null</strong>值。然后我们通过调用<strong>id()</strong>和<strong>description()</strong>方法从返回的<strong>UseCase</strong>对象中提取元素的值。</p></li></ul><h4 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h4><ul><li>标签<strong>@UseCase</strong>由<strong>UseCase.java</strong>定义，其中包含<strong>int</strong>元素<strong>id</strong>，以及一个<strong>String</strong>元素<strong>description</strong>。注解元素可用的类型包含以下几种。<ul><li>所有基本类型(<strong>int</strong>,<strong>float</strong>,<strong>boolean</strong>等)</li><li><strong>String</strong></li><li><strong>Class</strong></li><li><strong>enum</strong></li><li><strong>Annotation</strong></li><li>以上类型的数组</li></ul></li><li>如果你使用了其他类型编译器就会报错，也不允许使用任何包装类型。注解也可以作为元素的类型，也就是说注解可以嵌套。</li></ul><h4 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h4><ul><li><p>元素不能有不确定的值，也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。</p></li><li><p>对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以<strong>null</strong>作为其值。</p></li><li><p>为了绕开这个约束，我们只能自己定义一些特殊的值，如空字符串或负数，以此表示某个元素不存在。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimulatingNull &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="生成外部文件"><a href="#生成外部文件" class="headerlink" title="生成外部文件"></a>生成外部文件</h4><ul><li><p>假设你希望提供一些基本类型的对象/关系映射功能，能够自动生成数据库表，用以存储JavaBean对象。使用注解实现此功能，你可以将所有信息都保存在JavaBean源文件中，为此，我们需要一些新的注解，用以定义与Bean关联的数据库表的名字，以及与Bean属性关联的名字和SQL类型。</p></li><li><p>下面是一个注解的定义，他告诉注解处理器，你需要为我生成一个数据库表：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==@DBTable有一个name()元素，该注解通过这个元素为处理器创建数据库表提供表的名字。==</p></li><li><p>接下来为修饰JavaBean域准备的注解：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constrains &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span> <span class="keyword">default</span> @Constrains</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span> <span class="keyword">default</span> @Constrains</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解处理器通过<strong>@Constrains</strong>注解提取出数据库表的元数据，<strong>primaryKey()</strong>,<strong>allowNull()</strong>,<strong>unique()</strong>提供了默认值。</p></li><li><p>下面两个<strong>@interface</strong>定义的是<strong>SQL</strong>类型。如果希望这个<strong>framework</strong>更有价值的话，就应该为每种<strong>SQL</strong>类型都定义相应的注解。</p></li><li><p>这些<strong>SQL</strong>类型具有<strong>name()</strong>元素和<strong>constraints()</strong>元素，后者利用了嵌套注解的功能。注意<strong>constraints()</strong>元素的默认值是<strong>@Constraints</strong>。由于<strong>@Constraints</strong>注解类型之后，没有在括号中指明<strong>@Constraints</strong>中的元素的值，因此，<strong>constraints()</strong>元素的默认值实际上就是一个所有元素都为默认值的<strong>@Constraits</strong>注解。如果要令嵌入的<strong>@Constraits</strong>注解中的<strong>unique()</strong>元素为<strong>true</strong>，并以此作为<strong>constraints()</strong>元素的默认值，则需要如下定义该元素。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> @<span class="title">Constrains</span><span class="params">(unique = <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下面是一个简单的Bean，我们在其中应用了以上这些注解：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br><span class="line">    String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>)</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span></span><br><span class="line">    Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>,constrains = </span><br><span class="line">    <span class="meta">@Constrains</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    String handle;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@SQLString</strong>注解有两个有趣的地方：</p><ul><li>它们都使用了嵌入的<strong>@Constrains</strong>注解的默认值。</li><li>它们都使用了快捷方式？就是说如果程序员的注解中定义了名为<strong>value</strong>的元素，并且在应用该注解的时候，如果该元素是唯一需要赋值的一个元素，那么此时无需使用名-值对的这种语法，而只需在括号内给出<strong>value</strong>元素所需的值即可。这可以应用于任何合法类型的元素。</li></ul></li></ul><h4 id="变通之道"><a href="#变通之道" class="headerlink" title="变通之道"></a>变通之道</h4><ul><li>在上例中，你可以使用一个单一的注解类<strong>@TableColumn</strong>，它带有一个<strong>enum</strong>元素，该枚举类定义了<strong>STRING</strong>，<strong>INTEGER</strong>以及<strong>FLOAT</strong>等枚举类型。这就消除了每个<strong>SQL</strong>类型都需要一个<strong>@interface</strong>定义的负担，不过也使得以额外的信息修饰<strong>SQL</strong>类型的需求变得不可能，而这些额外的信息，如长度或精度等，可能是非常有必要的需求。</li><li>我们也可以使用<strong>String</strong>元素来描述实际的<strong>SQL</strong>类型，比如<strong>VARCHAR(30)</strong>或<strong>INTEGER</strong>。但是，它同时也将<strong>Java</strong>类型到<strong>SQL</strong>类型的映射绑在了一起，我们并不希望更换数据库导致代码必须修改并重新编译。</li><li>第三种方案是同时使用两个注解类型来注解一个域，<strong>@Constraints</strong>和相应的<strong>SQL</strong>类型(如：<strong>@SQLIntege</strong>)。这种方式可能会使代码有点乱，不过编译器允许程序员对一个目标同时使用多个注解，但是，使用多个注解的时候，同一个注解不能重复使用。</li></ul><h4 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h4><ul><li>不能使用关键字extends来继承某个@interface.在Java未来的版本中，似乎没有任何关于让注解支持继承的提案。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第二十章-注解&quot;&gt;&lt;a href=&quot;#第二十章-注解&quot; class=&quot;headerlink&quot; title=&quot;第二十章 注解&quot;&gt;&lt;/a&gt;第二十章 注解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;==注解(也被称为元数据)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十九章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十九章/</id>
    <published>2019-11-17T13:17:26.000Z</published>
    <updated>2019-11-17T13:32:47.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十九章-枚举类型"><a href="#第十九章-枚举类型" class="headerlink" title="第十九章 枚举类型"></a>第十九章 枚举类型</h2><p>关键字<strong>enum</strong>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p><h3 id="基本enum特性"><a href="#基本enum特性" class="headerlink" title="基本enum特性"></a>基本enum特性</h3><ul><li><p>创建enum时，编译器会为你生成一个相关的类，这个类继承自<strong>java.lang.Enum</strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Shrubbery &#123;</span><br><span class="line">    GROUND,CRAWLING,HANGING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Shrubbery s : Shrubbery.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">"ordinal:"</span> + s.ordinal());</span><br><span class="line">            System.out.println(s.compareTo(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(s.equals(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(s == Shrubbery.CRAWLING);</span><br><span class="line">            System.out.println(s.getDeclaringClass());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">            System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span> (String s : <span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">                Shrubbery shrubbery = Enum.valueOf(Shrubbery.class, s);</span><br><span class="line">                System.out.println(shrubbery);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GROUNDordinal:0</span></span><br><span class="line"><span class="comment">-1 </span></span><br><span class="line"><span class="comment">false </span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">CRAWLINGordinal:1</span></span><br><span class="line"><span class="comment">0 </span></span><br><span class="line"><span class="comment">true </span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">HANGINGordinal:2</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">false </span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ordinal()</strong>方法返回一个<strong>int</strong>值，这是每个<strong>enum</strong>实例在声明时的次序，从<strong>0</strong>开始。可以使用<strong>==</strong>来比较<strong>enum</strong>实例，编译器会自动为你提供<strong>equals()</strong>和<strong>hashCode()</strong>方法。</p></li><li><p><strong>Enum</strong>类实现了<strong>Comparable</strong>接口，所以它具有<strong>compareTo()</strong>方法。同时，它还实现了<strong>Serializable</strong>接口。</p></li><li><p>如果在<strong>enum</strong>实例上调用<strong>getDeclaringClass()</strong>方法，我们就能知道其所属的<strong>enum</strong>类。</p></li><li><p><strong>name()</strong>方法返回<strong>enum</strong>实例声明时的名字，这与使用<strong>toString()</strong>方法效果相同。<strong>valueOf()</strong>是在<strong>Enum</strong>中定义的<strong>static</strong>方法，它根据给定名字返回相应的<strong>enum</strong>实例，如果不存在给定名字的实例，将会抛出异常。</p></li></ul><h4 id="将静态导入用于enum"><a href="#将静态导入用于enum" class="headerlink" title="将静态导入用于enum"></a>将静态导入用于enum</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Spiciness &#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Burrito&#123;"</span> +</span><br><span class="line">                <span class="string">"degree="</span> + degree +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(NOT));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(MEDIUM));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(HOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=NOT&#125;</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=MEDIUM&#125;</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=HOT&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>static import</strong>能够将<strong>enum</strong>实例的标识符带入当前的命名空间，所以无需再用<strong>enum</strong>类型来修饰<strong>enum</strong>实例。</p></li></ul><h3 id="向enum中添加新方法"><a href="#向enum中添加新方法" class="headerlink" title="向enum中添加新方法"></a>向enum中添加新方法</h3><ul><li><p>除了不能继承自一个<strong>enum</strong>之外，我们基本上可以将<strong>enum</strong>看作一个常规的类。也就是说我们可以向<strong>enum</strong>中添加方法。<strong>enum</strong>甚至可以有<strong>main()</strong>方法。</p></li><li><p>一般来说，我们希望每个枚举实例都能够返回对自身的描述，而不仅仅只是默认的toString()实现，这只能够返回枚举实例的名字。为此，你可以创建一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。如下</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OzWitch &#123;</span><br><span class="line">    WEST(<span class="string">"Miss Gulch,aka the Wicked Witch of the West"</span>),</span><br><span class="line">    NORTH(<span class="string">"Glinda, the good witch of the north"</span>),</span><br><span class="line">    EAST(<span class="string">"Wicked Witch of the East.wearer of the Ruby"</span>+<span class="string">"Slippers,crushed by Dorothy`s house"</span>),</span><br><span class="line">    SOUTH(<span class="string">"Good by inference,but missing"</span>);</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    OzWitch(String description) &#123;</span><br><span class="line">        <span class="comment">//必须添加有参构造否则会报错</span></span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OzWitch witch : OzWitch.values()) &#123;</span><br><span class="line">            System.out.println(witch+<span class="string">": "</span>+witch.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WEST: Miss Gulch,aka the Wicked Witch of the West</span></span><br><span class="line"><span class="comment">NORTH: Glinda, the good witch of the north</span></span><br><span class="line"><span class="comment">EAST: Wicked Witch of the East.wearer of the RubySlippers,crushed by Dorothy`s house</span></span><br><span class="line"><span class="comment">SOUTH: Good by inference,but missing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果你打算定义自己的方法，那么必须在<strong>enum</strong>实例序列的最后添加一个分号。同时<strong>Java</strong>要求你必须定义一个<strong>enum</strong>实例。如果在定义<strong>enum</strong>实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。</p></li><li><p><strong>enum</strong>中的构造器与方法和普通的类没有什么区别，因为除了有少许限制外，<strong>enum</strong>就是一个普通的类。</p></li><li><p>上面我们将<strong>enum</strong>中的构造器声明为<strong>private</strong>，但对于它的可访问性而言，其实并没有什么变化，因为(即使不声明为<strong>private</strong>)我们只能在<strong>enum</strong>定义的内部使用其构造器创建<strong>enum</strong>实例。一旦<strong>enum</strong>地定义失败，编译器就不允许我们再使用其构造器来创建任何实例。</p></li></ul><h4 id="覆盖enum的方法"><a href="#覆盖enum的方法" class="headerlink" title="覆盖enum的方法"></a>覆盖enum的方法</h4><ul><li><p>覆盖<strong>toString()</strong>方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息，下面，我们使用的就是实例的名字，不过我们希望改变其格式。覆盖<strong>enum</strong>的<strong>toString()</strong>方法与覆盖一般类的方法没有什么区别。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpaceShip &#123;</span><br><span class="line">    SCOUT,CARGO,TRANSPORT,CRUISER,BATTLESHIP,MOTHERSHIP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = name();</span><br><span class="line">        String lower = id.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> id.charAt(<span class="number">0</span>)+lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SpaceShip name : values()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scout</span></span><br><span class="line"><span class="comment">Cargo</span></span><br><span class="line"><span class="comment">Transport</span></span><br><span class="line"><span class="comment">Cruiser</span></span><br><span class="line"><span class="comment">Battleship</span></span><br><span class="line"><span class="comment">Mothership</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>toString()</strong>方法通过调用<strong>name()</strong>方法取得<strong>SpaceShip</strong>的名字，然后将其修改为只有首字母大写的格式。</p></li></ul><h3 id="values-的神秘之处"><a href="#values-的神秘之处" class="headerlink" title="values()的神秘之处"></a>values()的神秘之处</h3><ul><li><p>编译器为你创建的enum类都继承自Enum类，但是Enum类并没有values()方法，但是我们却使用过该方法，难道存在某种“隐藏的方法吗？？？”，我们可以通过反射机制编写一个简单的程序，一探究竟。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Explore &#123;</span><br><span class="line">    HERE,THERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">analyze</span><span class="params">(Class&lt;?&gt; enumClass)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Interfaces: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : enumClass.getGenericInterfaces())</span><br><span class="line">            System.out.println(type);</span><br><span class="line">        System.out.println(<span class="string">"Base: "</span> + enumClass.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"Method: "</span>);</span><br><span class="line">        Set&lt;String&gt; methods = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method m : enumClass.getMethods())</span><br><span class="line">            methods.add(m.getName());</span><br><span class="line">        System.out.println(methods);</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; exploreMethods = analyze(Explore.class);</span><br><span class="line">        Set&lt;String&gt; enumMethods = analyze(Enum.class);</span><br><span class="line">        System.out.println(<span class="string">"Explore.containsAll(Enum)? "</span>+enumMethods.containsAll(enumMethods));</span><br><span class="line">        System.out.println(<span class="string">"Explore.removeAll(Enum): "</span>);</span><br><span class="line">        exploreMethods.removeAll(enumMethods);</span><br><span class="line">        System.out.println(exploreMethods);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Interfaces: </span></span><br><span class="line"><span class="comment">Base: class java.lang.Enum</span></span><br><span class="line"><span class="comment">Method: </span></span><br><span class="line"><span class="comment">[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, values, wait]</span></span><br><span class="line"><span class="comment">Interfaces: </span></span><br><span class="line"><span class="comment">java.lang.Comparable&lt;E&gt;</span></span><br><span class="line"><span class="comment">interface java.io.Serializable</span></span><br><span class="line"><span class="comment">Base: class java.lang.Object</span></span><br><span class="line"><span class="comment">Method: </span></span><br><span class="line"><span class="comment">[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, wait]</span></span><br><span class="line"><span class="comment">Explore.containsAll(Enum)? true</span></span><br><span class="line"><span class="comment">Explore.removeAll(Enum): </span></span><br><span class="line"><span class="comment">[values]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>结论是，values()方法是由编译器添加的static方法。</p></li></ul><h3 id="实现，而非继承"><a href="#实现，而非继承" class="headerlink" title="实现，而非继承"></a>实现，而非继承</h3><ul><li><h5 id="所有的enum都继承自java-lang-Enum类，由于Java不支持多重继承，所以你的-enum不能再继承其他类-。"><a href="#所有的enum都继承自java-lang-Enum类，由于Java不支持多重继承，所以你的-enum不能再继承其他类-。" class="headerlink" title="所有的enum都继承自java.lang.Enum类，由于Java不支持多重继承，所以你的==enum不能再继承其他类==。"></a>所有的<strong>enum</strong>都继承自<strong>java.lang.Enum</strong>类，由于Java不支持多重继承，所以你的==enum不能再继承其他类==。</h5></li><li><p>但是，在我们创建一个新的<strong>enum</strong>时，可以同时实现一个或多个接口。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CartoonCharacter implements Generator&lt;CartoonCharacter&gt; &#123;</span><br><span class="line">    SLAPPY,SPANKY,PUNCHY,SILLY,BOUNCY,NUTTY,BOB;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CartoonCharacter <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values()[rand.nextInt(values().length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumImplementation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printNext</span><span class="params">(Generator&lt;T&gt; rg)</span> </span>&#123;</span><br><span class="line">        System.out.println(rg.next()+<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CartoonCharacter cc = CartoonCharacter.BOB;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            printNext(cc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOB,</span></span><br><span class="line"><span class="comment">PUNCHY,</span></span><br><span class="line"><span class="comment">BOB,</span></span><br><span class="line"><span class="comment">SPANKY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">PUNCHY,</span></span><br><span class="line"><span class="comment">SLAPPY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">SLAPPY,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>结果有点奇怪，不过你必须要有一个<strong>enum</strong>实例才能调用其上的方法，现在，在任何接受<strong>Generator</strong>参数的方法中，如<strong>printNext()</strong>,都可以使用<strong>CartoonCharacter</strong>。</p></li></ul><h3 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h3><ul><li><p>无法从<strong>enum</strong>继承子类有时很令人沮丧，这种需求有时源自我们希望扩展原<strong>enum</strong>中的元素，有时是因为我们希望使用将一个<strong>enum</strong>中的元素进行分类。</p></li><li><p>在一个接口内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类的目的。</p></li><li><p>下面假设你想要用<strong>enum</strong>来表示不同类别的食物，同时还希望每个<strong>enum</strong>元素仍然保持<strong>Food</strong>类型，可以这样实现。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">        SALAD,SOUP,SPRONG_ROLLS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">        LASAGNE,BURRITO,PAD_THAI,</span><br><span class="line">        LENTILS,HUMMOUS,VINDALOO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">        TIRAMISU,GELATO,BLACK_FOREST_CAKE,</span><br><span class="line">        FRUIT,CREME_CARAMEL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">        BLACK_COFFEE,DECAF_COFFEE,ESPRESSO,</span><br><span class="line">        LATTE,CAPPUCCINO,TEA,HERB_TEA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于<strong>enum</strong>而言，实现接口是使其子类化的唯一方法，所以嵌入在<strong>Food</strong>中的每个<strong>enum</strong>都实现了<strong>Food</strong>接口。下面，我们可以说“==所有的东西都是某种类型的<strong>Food</strong>==”。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = Food.Appetizer.SALAD;</span><br><span class="line">        food = Food.MainCourse.LASAGNE;</span><br><span class="line">        food = Food.Dessert.GELATO;</span><br><span class="line">        food = Food.Coffee.CAPPUCCINO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>enum</strong>类型实现了<strong>Food</strong>接口，那么就可以将其实例向上转型为<strong>Food</strong>，所以上面中的所有东西都是<strong>Food</strong>。</p></li><li><p>当我们需要与一大堆类型打交道时，接口就不如<strong>enum</strong>好了，如你想创建一个“枚举的枚举”，那么可以创建一个新的<strong>enum</strong>，然后用其实例包装<strong>Food</strong>中的每一个<strong>enum</strong>类。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">random</span><span class="params">(Class&lt;T&gt; ec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values[random.nextInt(values.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Course &#123;</span><br><span class="line">    APPETIZER(Food.Appetizer.class),</span><br><span class="line">    MAINCOURSE(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Course</span><span class="params">(Class&lt;? extends Food&gt; kind)</span> </span>&#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面中，每一个Course的实例都将其对应的Class对象作为构造器的参数。通过getEnumConstants()方法，乐意从该Class对象中取得某个Food子类的所有enum实例。这些实例在randomSelection()中被用到，因此，通过从每个Course实例中随机地选择一个Food，我们便能够生成一份菜单。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Course course : Course.values()) &#123;</span><br><span class="line">                Food food = course.randomSelection();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SPRONG_ROLLS</span></span><br><span class="line"><span class="comment">VINDALOO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">DECAF_COFFEE</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SOUP</span></span><br><span class="line"><span class="comment">VINDALOO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">TEA</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SALAD</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">TEA</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SALAD</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">CREME_CARAMEL</span></span><br><span class="line"><span class="comment">LATTE</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SOUP</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">TIRAMISU</span></span><br><span class="line"><span class="comment">ESPRESSO</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>上面中，我们通过遍历每一个<strong>Course</strong>实例来获得“枚举的枚举”。</p></li><li><p>除此之外，还有一种更简洁的管理枚举的方法，就是将一个<strong>enum</strong>嵌套在另一个<strong>enum</strong>内，如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SecurityCategory &#123;</span><br><span class="line">    STOCK(Security.Stock.class),</span><br><span class="line">    BOND(Security.Bond.class);</span><br><span class="line">    Security[] values;</span><br><span class="line">    SecurityCategory(Class&lt;? extends Security&gt; kind) &#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Stock implements Security &#123;</span><br><span class="line">        SHORT,LONG,MARGIN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Bond implements Security &#123;</span><br><span class="line">        MUNICIPAL,JUNK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Security <span class="title">randomSelecttion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            SecurityCategory category = Enums.random(SecurityCategory.class);</span><br><span class="line">            System.out.println(category+<span class="string">":"</span>+category.randomSelecttion());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">STOCK:MARGIN</span></span><br><span class="line"><span class="comment">STOCK:MARGIN</span></span><br><span class="line"><span class="comment">BOND:JUNK</span></span><br><span class="line"><span class="comment">STOCK:SHORT</span></span><br><span class="line"><span class="comment">STOCK:LONG</span></span><br><span class="line"><span class="comment">STOCK:LONG</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">BOND:JUNK</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Security</strong>接口的作用是将其所包含的<strong>enum</strong>组合成一个公共类型，这一点是有必要的。然后，<strong>SecurityCategorg</strong>才能将<strong>Security</strong>中的<strong>enum</strong>作为其构造器的参数，以起到组织的效果。</p></li></ul><h3 id="使用EnumSet替代标志"><a href="#使用EnumSet替代标志" class="headerlink" title="使用EnumSet替代标志"></a>使用EnumSet替代标志</h3><ul><li><p><strong>Set</strong>是一种集合，只能向其中添加不重复的对象，<strong>enum</strong>也要求其成员都是唯一的，所以<strong>enum</strong>看起来也具有集合的行为。不过，由于不能从<strong>enum</strong>中删除或添加元素，所以他只能算是不太有用的集合。</p></li><li><p>Java SE5引入EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标识”。这种标识可以用来表示某种“开/关”信息，不过，使用这种标识，我们最终操作的只是一些bit，而不是这些bit想要表达的概念。</p></li><li><p>EnumSet的设计充分考虑到速度因素，因为他必须与非常高效的bit标识相竞争(其操作与HashSet相比，非常地快)。就其内部而言，它（可能）就是一个long值作为比特向量，所以EnumSet非常快读高效。使用EnumSet的优点是，他在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。</p></li><li><p>EnumSet中的元素必须来自一个enum。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoits &#123;</span><br><span class="line">    STAIR1,STAIR2,LOBBY,OFFICE1,OFFICE2,</span><br><span class="line">    OFFICE3,OFFICE4,BATHROOM,UTILITY,KITCHEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoits&gt; poits = EnumSet.noneOf(AlarmPoits.class);</span><br><span class="line">        poits.add(AlarmPoits.BATHROOM);</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits.addAll(EnumSet.of(AlarmPoits.STAIR1,AlarmPoits.STAIR2,AlarmPoits.KITCHEN));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits = EnumSet.allOf(AlarmPoits.class);</span><br><span class="line">        poits.removeAll(EnumSet.of(AlarmPoits.STAIR1,AlarmPoits.STAIR2,AlarmPoits.KITCHEN));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits.removeAll(EnumSet.range(AlarmPoits.OFFICE1,AlarmPoits.OFFICE2));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits = EnumSet.complementOf(poits);</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[BATHROOM]</span></span><br><span class="line"><span class="comment">[STAIR1, STAIR2, BATHROOM, KITCHEN]</span></span><br><span class="line"><span class="comment">[LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY]</span></span><br><span class="line"><span class="comment">[LOBBY, OFFICE3, OFFICE4, BATHROOM, UTILITY]</span></span><br><span class="line"><span class="comment">[STAIR1, STAIR2, OFFICE1, OFFICE2, KITCHEN]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>EnumSet</strong>的基础是<strong>long</strong>，一个<strong>long</strong>值有<strong>64</strong>位而一个<strong>enum</strong>实例只需一位<strong>bit</strong>表示其是否存在。也就是说，在不超过一个<strong>long</strong>的表达能力的情况下，你的<strong>EnumSet</strong>可以应用于最多不超过<strong>64</strong>个元素的<strong>enum</strong>。如果<strong>enum</strong>超过了<strong>64</strong>个元素会发生什么呢？</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEnumSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Big &#123;</span><br><span class="line">        A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,</span><br><span class="line">        A11,A12,A13,A14,A15,A16,A17,A18,A19,A20,</span><br><span class="line">        A21,A22,A23,A24,A25,A26,A27,A28,A29,A30,</span><br><span class="line">        A31,A32,A33,A34,A35,A36,A37,A38,A39,A40,</span><br><span class="line">        A41,A42,A43,A44,A45,A46,A47,A48,A49,A50,</span><br><span class="line">        A51,A52,A53,A54,A55,A56,A57,A58,A59,A60 ,</span><br><span class="line">        A61,A62,A63,A64,A65,A66,A67,A68,A69,A70,</span><br><span class="line">        A71,A72,A73,A74,A75,A76,A77,A78,A79,A80</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;Big&gt; bigEnumSet = EnumSet.allOf(Big.class);</span><br><span class="line">        System.out.println(bigEnumSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, </span></span><br><span class="line"><span class="comment">A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, </span></span><br><span class="line"><span class="comment">A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, </span></span><br><span class="line"><span class="comment">A31, A32, A33, A34, A35, A36, A37, A38, A39, A40, </span></span><br><span class="line"><span class="comment">A41, A42, A43, A44, A45, A46, A47, A48, A49, A50, </span></span><br><span class="line"><span class="comment">A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, </span></span><br><span class="line"><span class="comment">A61, A62, A63, A64, A65, A66, A67, A68, A69, A70, </span></span><br><span class="line"><span class="comment">A71, A72, A73, A74, A75, A76, A77, A78, A79, A80]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>EnumSet</strong>可以应用于多过<strong>64</strong>个元素的<strong>enum</strong>，所以，<strong>Enum</strong>会在必要的时候增加一个<strong>long</strong>。</p></li></ul><h3 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h3><ul><li><p>EnumMap是一种特殊的Map，他要求其中的键(key)必须来自一个enum，由于enum本身的限制，所以EnumMap在内部可由数组实现。因此EnumMap的速度很快，我们可以放心的使用enum实例在EnumMap中进行查找操作。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoits,Command&gt; em = <span class="keyword">new</span> EnumMap&lt;AlarmPoits, Command&gt;(AlarmPoits.class);</span><br><span class="line">        em.put(AlarmPoits.KITCHEN,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Kitchen fire"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        em.put(AlarmPoits.BATHROOM,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Bathroom alert"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;AlarmPoits, Command&gt; e : em.entrySet()) &#123;</span><br><span class="line">            System.out.println(e.getKey()+<span class="string">": "</span>);</span><br><span class="line">            e.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        em.get(AlarmPoits.UTILITY).action();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BATHROOM: </span></span><br><span class="line"><span class="comment">Bathroom alert</span></span><br><span class="line"><span class="comment">KITCHEN: </span></span><br><span class="line"><span class="comment">Kitchen fire</span></span><br><span class="line"><span class="comment">java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>与<strong>EnumSet</strong>一样，<strong>enum</strong>实例定义时的次序决定了其在<strong>EnumMap</strong>中的顺序。</p></li><li><p><strong>EnumMap</strong>有一个优点，那<strong>EnumMap</strong>允许程序员改变值对象，而常量相关的方法在编译期就被固定了。</p></li><li><p>在你有多种类型的<strong>enum</strong>，而且它们之间存在互操作的情况下，我们可以用<strong>EnumMap</strong>实现多路分发。</p></li></ul><h3 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h3><ul><li><p>当你要处理多种交互类型时，程序可能会变得相当复杂。如：如果一个系统要分析和执行数学表达式。我们可能会声明Number.plus(Number),Number.plus(Number)等等，其中Number是各种数学对象的超类。当你声明a.plus(b)时，你并不知道a或b的确切类型，那你如何能让它们正确的交互呢？？？？？</p></li><li><p>Java只支持单路分发。也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么Java的动态绑定机制只能处理其中一个的类型。这样就无法解决我们上面提到的问题，所以，你必须自己来绑定其他的类型，从而实现自己的动态绑定行为。</p></li><li><p>解决上面问题的方法就是多路分发，多态只能发生在方法调用时，所以，如果你想使用多路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知类型。</p></li><li><p>要利用多路分发，我们必须为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就需要为每个类型体系执行一个方法调用。</p></li><li><p>一般而言，需要有设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型。为了达到这种效果，我们需要与多个方法一同工作：因为每个分发都需要一个方法调用。</p></li><li><p>下面例子中(实现了”石头”，”剪刀”，”布”游戏)对应的方法是compete()和eval()，两者都是同一个类型的成员，它们可以产生三种Outcome实例中的一个作为结果：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Outcome &#123;</span><br><span class="line">    WIN,LOSE,DRAW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Outcome <span class="title">compete</span><span class="params">(Item it)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Scissors s)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.DRAW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Paper"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scissors</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.DRAW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Scissors"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rock"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">new</span> Scissors();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(Item a,Item b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a+<span class="string">"vs. "</span>+b+<span class="string">":"</span>+a.compete(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            match(newItem(),newItem());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Rockvs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Scissors:DRAW</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Paper:DRAW</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Rockvs. Scissors:WIN</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>Item是这几种类型的接口，将会被用作多路分发，RoShamBo1.match()有两个Item参数，通过调用Item.compete()方法开始两路分发。</p></li><li><p>要判断a的类型，分发机制会在a的实际类型的compete()内部起到分发的作用。compete()方法通过调用eval()来为另一个类型实现第二次分发。将自身(this)作为参数调用eval()，能够调用重载过的eval()方法,这能够保留第一次分发的类型信息。</p></li><li><p>要配置好多路分发需要很多工序，不过，他的好处在于方法调用时的优雅的语法</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十九章-枚举类型&quot;&gt;&lt;a href=&quot;#第十九章-枚举类型&quot; class=&quot;headerlink&quot; title=&quot;第十九章 枚举类型&quot;&gt;&lt;/a&gt;第十九章 枚举类型&lt;/h2&gt;&lt;p&gt;关键字&lt;strong&gt;enum&lt;/strong&gt;可以将一组具名的值的有限集合创建为一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十六章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十六章/</id>
    <published>2019-11-17T13:16:07.000Z</published>
    <updated>2019-11-17T13:32:58.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十六章-数组"><a href="#第十六章-数组" class="headerlink" title="第十六章 数组"></a>第十六章 数组</h2><h3 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h3><ul><li>数组于其他种类的容器之间的区别有三方面：<strong>效率</strong>，<strong>类型</strong>和<strong>保存基本类型的能力</strong>。<ol><li>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可变。</li><li>在泛型之前，其他的容器类在处理对象时，都将他们视作没有任何具体类型。就是说。他们将这些对象都当作Java中所有类的根类Object处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译期检查，来防止插入错误类型和抽取不当类型。</li><li>数组可以持有基本类型，而泛型之前的容器则不能。但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。</li></ol></li><li>随着自动包装机制的出现，容器已经可以与数组几乎一样方便地用于基本类型中了。数组硕果仅存的优点就是效率。然而，如果要解决更一般化的问题，那数组就可能受到过多的限制，因此在这些情况下你还是会使用容器。</li></ul><h3 id="数组是第一级对象"><a href="#数组是第一级对象" class="headerlink" title="数组是第一级对象"></a>数组是第一级对象</h3><ul><li><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个(数组)对象用以保存指向其他对象的引用。</p></li><li><p>对象数组和基本类型数组在使用上几乎是相同的；唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BerylliumSphere</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sphere"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerComparison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BerylliumSphere[] sphere = <span class="keyword">new</span> BerylliumSphere[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            sphere[i] = <span class="keyword">new</span> BerylliumSphere();</span><br><span class="line">        System.out.println(Arrays.toString(sphere));</span><br><span class="line">        System.out.println(sphere[<span class="number">4</span>]);</span><br><span class="line">        List&lt;BerylliumSphere&gt; sphereList = <span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">5</span>; i1++)</span><br><span class="line">            sphereList.add(<span class="keyword">new</span> BerylliumSphere());</span><br><span class="line">        System.out.println(sphereList);</span><br><span class="line">        System.out.println(sphereList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] integers = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">        System.out.println(integers[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        intList.add(<span class="number">97</span>);</span><br><span class="line">        System.out.println(intList);</span><br><span class="line">        System.out.println(intList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Sphere0, Sphere1, Sphere2, Sphere3, Sphere4, null, null, null, null, null]</span></span><br><span class="line"><span class="comment">Sphere4</span></span><br><span class="line"><span class="comment">[Sphere5, Sphere6, Sphere7, Sphere8, Sphere9]</span></span><br><span class="line"><span class="comment">Sphere9</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 97]</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BerylliumSphere[] a;</span><br><span class="line">    BerylliumSphere[] b = <span class="keyword">new</span> BerylliumSphere[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">"b"</span>+ Arrays.toString(b));</span><br><span class="line">        BerylliumSphere[] c = <span class="keyword">new</span> BerylliumSphere[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="keyword">null</span>)</span><br><span class="line">                c[i] = <span class="keyword">new</span> BerylliumSphere();</span><br><span class="line">        BerylliumSphere[] d = &#123; <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(),<span class="keyword">new</span> BerylliumSphere()</span><br><span class="line">        &#125;;</span><br><span class="line">        a = <span class="keyword">new</span> BerylliumSphere[] &#123;</span><br><span class="line">                <span class="keyword">new</span> BerylliumSphere(),<span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"a.length = "</span>+a.length);</span><br><span class="line">        System.out.println(<span class="string">"b.length = "</span>+b.length);</span><br><span class="line">        System.out.println(<span class="string">"c.length = "</span>+c.length);</span><br><span class="line">        System.out.println(<span class="string">"d.length = "</span>+d.length);</span><br><span class="line">        a = d;</span><br><span class="line">        System.out.println(<span class="string">"a.length = "</span>+a.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] e;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">"f: "</span>+ Arrays.toString(f));</span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.length; i++)</span><br><span class="line">            g[i] = i * i;</span><br><span class="line">        <span class="keyword">int</span>[] h = &#123;<span class="number">11</span>,<span class="number">47</span>,<span class="number">93</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"f.length ="</span> +f.length);</span><br><span class="line">        System.out.println(<span class="string">"g.length ="</span> +g.length);</span><br><span class="line">        System.out.println(<span class="string">"h.length ="</span> +h.length);</span><br><span class="line">        e = h;</span><br><span class="line">        System.out.println(<span class="string">"e.length ="</span> +e.length);</span><br><span class="line">        e = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"e.length ="</span> +e.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b[null, null, null, null, null]</span></span><br><span class="line"><span class="comment">a.length = 2</span></span><br><span class="line"><span class="comment">b.length = 5</span></span><br><span class="line"><span class="comment">c.length = 4</span></span><br><span class="line"><span class="comment">d.length = 3</span></span><br><span class="line"><span class="comment">a.length = 3</span></span><br><span class="line"><span class="comment">f: [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">f.length =5</span></span><br><span class="line"><span class="comment">g.length =4</span></span><br><span class="line"><span class="comment">h.length =3</span></span><br><span class="line"><span class="comment">e.length =3</span></span><br><span class="line"><span class="comment">e.length =2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>数组a是一个尚未被初始化的局部变量，在你对他正确的初始化之前，编译期不允许用此引用做任何事情。</p></li><li><p>数组b初始化为指向一个<strong>BerylliumSphere</strong>引用的数组，但其实并没有<strong>BerylliumSphere</strong>对象置入数组中。</p></li><li><p>length是数组的大小，而不是实际保存的元素个数，新生成一个数组对象时，其中所有的引用被自动的初始化为null；所以检查其中的引用是否为null，即可知道数组的某个位置是否存有对象。</p></li><li><p>基本类型的数组如果是数值型，就会被自动初始化为0；如果是字符型(char)，就会被自动初始化为(char)O；如果是布尔型，就被自动初始化为false。</p></li></ul><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul><li><p>对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultidimensionalPrimitiveArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>下面使用<strong>Java SE5</strong>的<strong>Arrays.deepToString()</strong>方法，它可以将多维数组转换为多个<strong>String</strong>，还可以使用<strong>new</strong>来分配数组，下面的三维数组就是在<strong>new</strong>表达式中分配的：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSWithNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到基本类型数组的值在不进行显式初始化的情况下，会被自动初始化。对象数组会被初始化为<strong>null</strong>。</p></li></ul><h3 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h3><ul><li><p>通常，数组与泛型不能很好的结合，你不能实例化具有参数化类型的数组：==Peel<banana> [] peels = new Peel<banana>[10];==，擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。但是，你可以参数化数组本身的类型。</banana></banana></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParmeterizedArrayType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubles = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line">        Integer[] ints2 = <span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2 = <span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        ints2 = MethodParameter.f(ints);</span><br><span class="line">        doubles2 = MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用参数化方法而不使用参数化类的方便之处在于：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的。</p></li><li><p>如上，不能创建泛型数组这一说法并不十分正确，编译期确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用，如：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls;</span><br></pre></td></tr></table></figure></li><li><p>这条语句可以顺利地通过编译期而不报任何错误。而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls;</span><br><span class="line">        List[] la = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        ls = (List&lt;String&gt;[])la;</span><br><span class="line">        ls[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Object[] objects = ls;</span><br><span class="line">        objects[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;BerylliumSphere&gt;[] spheres = (List&lt;BerylliumSphere&gt;[])<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spheres.length; i++) &#123;</span><br><span class="line">            spheres[i] = <span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一旦拥有对List<string>[]的引用，你就会看到你将得到某些编译器检查。问题是数组是协变类型的，因此List<string>[]也是一个Object[]，并且你可以利用这一点，将一个ArrayList<integer>赋值到你的数组中，而不会有任何编译期或运行时错误。</integer></string></string></p></li></ul><h3 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h3><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><ul><li><p>Java标准类库提供有static方法<strong>System.arraycopy()</strong>，用它复制数组比用for循环要快很多。<strong>System.arraycopy()</strong>针对所有类型做了重载</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyingArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(i,<span class="number">47</span>);</span><br><span class="line">        Arrays.fill(j,<span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+Arrays.toString(i));</span><br><span class="line">        System.out.println(<span class="string">"j="</span>+Arrays.toString(j));</span><br><span class="line">        System.arraycopy(i,<span class="number">0</span>,j,<span class="number">0</span>,i.length);</span><br><span class="line">        System.out.println(<span class="string">"j="</span>+Arrays.toString(j));</span><br><span class="line">        <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(k,<span class="number">103</span>);</span><br><span class="line">        System.arraycopy(i,<span class="number">0</span>,k,<span class="number">0</span>,k.length);</span><br><span class="line">        System.out.println(<span class="string">"k="</span>+Arrays.toString(k));</span><br><span class="line">        Arrays.fill(k,<span class="number">103</span>);</span><br><span class="line">        System.arraycopy(k,<span class="number">0</span>,i,<span class="number">0</span>,k.length);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+Arrays.toString(i));</span><br><span class="line">        Integer[] u = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        Integer[] v = <span class="keyword">new</span> Integer[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(u,<span class="keyword">new</span> Integer(<span class="number">47</span>));</span><br><span class="line">        Arrays.fill(v,<span class="keyword">new</span> Integer(<span class="number">99</span>));</span><br><span class="line">        System.out.println(<span class="string">"u="</span>+Arrays.toString(u));</span><br><span class="line">        System.out.println(<span class="string">"v="</span>+Arrays.toString(v));</span><br><span class="line">        System.arraycopy(v,<span class="number">0</span>,u,u.length/<span class="number">2</span>,v.length);</span><br><span class="line">        System.out.println(<span class="string">"u="</span>+Arrays.toString(u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=[47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">j=[99, 99, 99, 99, 99, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">j=[47, 47, 47, 47, 47, 47, 47, 99, 99, 99]</span></span><br><span class="line"><span class="comment">k=[47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">i=[103, 103, 103, 103, 103, 47, 47]</span></span><br><span class="line"><span class="comment">u=[47, 47, 47, 47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">v=[99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">u=[47, 47, 47, 47, 47, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>这个例子说明基本类型数组与对象数组都可以复制。然而，如果复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝。这被称为浅复制。</p></li><li><p><strong>System.arraycopy()</strong>不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。</p></li></ul><h4 id="数组的比较"><a href="#数组的比较" class="headerlink" title="数组的比较"></a>数组的比较</h4><ul><li><p><strong>Arrays</strong>类提供了重载后的<strong>equals()</strong>方法，用来比较整个数组。同样，此方法针对所有基本类型与<strong>Object</strong>都做了重载。数组相等的条件是元素个数必须相等，并且对应位置的元素也相等，这可以通过对每一个元素使用<strong>equals()</strong>作比较来判断。(对于基本类型，需要使用基本类型的包装器类的<strong>equals()</strong>方法)</p></li><li><p>如此处对于int类型使用Integer.equals()做比较</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparingArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(a1,<span class="number">47</span>);</span><br><span class="line">        Arrays.fill(a2,<span class="number">47</span>);</span><br><span class="line">        System.out.println(Arrays.equals(a1,a2));</span><br><span class="line">        a2[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">        System.out.println(Arrays.equals(a1,a2));</span><br><span class="line">        String[] s1 = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        Arrays.fill(s1,<span class="string">"Hi"</span>);</span><br><span class="line">        String[] s2 = &#123;</span><br><span class="line">            <span class="keyword">new</span> String(<span class="string">"Hi"</span>),<span class="keyword">new</span> String(<span class="string">"Hi"</span>),</span><br><span class="line">            <span class="keyword">new</span> String(<span class="string">"Hi"</span>),<span class="keyword">new</span> String(<span class="string">"Hi"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.equals(s1,s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十六章-数组&quot;&gt;&lt;a href=&quot;#第十六章-数组&quot; class=&quot;headerlink&quot; title=&quot;第十六章 数组&quot;&gt;&lt;/a&gt;第十六章 数组&lt;/h2&gt;&lt;h3 id=&quot;数组为什么特殊&quot;&gt;&lt;a href=&quot;#数组为什么特殊&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十五章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十五章/</id>
    <published>2019-11-17T13:13:42.000Z</published>
    <updated>2019-11-17T13:33:43.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h2><ul><li><p>一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。</p></li><li><p>有时候，拘泥于单继承体系，也会使程序受限太多。如果方法的参数是一个接口，而不是一个类，这种限制就放松了许多。因为任何实现了该接口的类都能满足该方法，这也包括暂时还不存在的类。接口允许我们快捷的实现类继承，也使我们有机会创建一个新类来做到这一点。</p></li><li><p>在有的时候，即便使用了接口，对程序的约束性还是太强大了。因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望达到的目地是编写更通用的代码，要使代码能够应用于”某种不具体的类型”而不是一个具体的接口或类。</p></li><li><p>泛型的概念：泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。</p></li></ul><h3 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h3><ul><li><p>有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。容器，就是存放要使用的对象的地方。数组也是如此，不过与简单的数组相比，容器类更加灵活，具备更多不同的功能。</p></li><li><p>有些情况下，我们希望容器能够同时存储多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。</p></li><li><p>与其使用Object，我们更喜欢使用暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换类型参数。如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        thia.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Automobile&gt; h = <span class="keyword">new</span> Holder&lt;Automobile&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = h.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型的核心概念：“告诉编译器想使用什么类型，然后编译器帮你处理一切细节”。</p></li></ul><h4 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h4><ul><li><p>在开发中可能经常会遇到，仅一次方法调用就能返回多个对象。可是return语句只允许返回单个对象。因此，解决方法就是创建一个对象，用它来持有想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。可是有了泛型，就能够一次性的解决问题，同时，我们在编译期就能确保类型安全。</p></li><li><p>这被称为==元组==(tuple):它是将一组对象直接打包存储于其中一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。(这个概念也称为数据传送对象，或信使)。</p></li><li><p>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。不过，我们希望能够为每一个对象指明其类型，并且从容器中读取出来时，能够得到正确的类型，要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个二维元组，它能够持有两个对象。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        first = a;</span><br><span class="line">       second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TwoTuple&#123;"</span> +</span><br><span class="line">                <span class="string">"first="</span> + first +</span><br><span class="line">                <span class="string">", second="</span> + second +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们可以使用继承机制实现长度更长的元组。从下面可以看到，增加类型参数是件很简单的事情。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span>+first+<span class="string">","</span>+second+<span class="string">","</span>+third+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了使用元组，你只需要定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。</p></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul><li><p>泛型也可以应用于接口，例如生成器(generator)，这是一种专门负责创建对象的类。</p></li><li><p>一般而言，一个生成器只定义一个方法，该方法用以产生新的对象。此处，就是<strong>next()</strong>方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//方法next()的返回类型是参数化T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java泛型的局限性：基本类型无法作为类型参数。</p></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li><p>可以在类中包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。</p></li><li><p>泛型方法使得该方法能够独立于类而产生变化。</p></li><li><p>无论何时只要你能做到，你就应该尽量使用泛型方法。就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。</p></li><li><p>对于一个<strong>static</strong>的方法而言，无法访问类的类型参数，所以，如果<strong>static</strong>方法需要使用泛型能力，<strong>就必须使其成为泛型方法。</strong></p></li><li><p>泛型方法格式 :</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerirMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName()<span class="string">");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法时，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为<strong>类型参数推断(type argument inference)</strong>。</p><h4 id="可变参数与泛型方法"><a href="#可变参数与泛型方法" class="headerlink" title="可变参数与泛型方法"></a>可变参数与泛型方法</h4><ul><li><p>泛型方法与可变参数能够很好的共存。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">            System.out.println(ls);</span><br><span class="line">            ls = makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">            System.out.pringln(ls);</span><br><span class="line">            ls = makeList(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>.spilt(<span class="string">""</span>));</span><br><span class="line">            System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h3><ul><li><p>当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的，如，尽管可以声明<strong>ArrayList.class</strong>，但是不能声明<strong>ArrayList<integer>.class</integer></strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ArrayList<string></string></strong>与<strong>ArrayList<integer></integer></strong>很容易被认为是不同的类型。不同的类型在行为方面肯定是不同的，如：将一个<strong>Integer</strong>放入<strong>ArrayList<string></string></strong>,所得到的行为(将失败)与把一个<strong>Integer</strong>放入<strong>ArrayList<integer></integer></strong>(将成功)所得到的行为完全不同。但是上面的程序会认为他们是相同的类型。</p></li><li><p>下面是对这个谜题的一个补充。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>,<span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;Frob&gt;();</span><br><span class="line">        Map&lt;Frob,Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;Frob,Fnorkle&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;Fnorkle&gt;();</span><br><span class="line">        Particle&lt;Long,Double&gt; p = <span class="keyword">new</span> Particle&lt;Long,Double&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Class.getTypeParameters()</strong>将”返回一个<strong>TypeVariable</strong>对象数组，表示有泛型声明所声明的类型参数······”.</p></li><li><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p></li><li><p><strong>Java</strong>泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此<strong>List<string></string></strong>和<strong>List<integer></integer></strong>在运行时事实上是相同的类型。这两种形式都被擦除成他们的“<strong>原生</strong>”类型，即<strong>List</strong>。</p></li><li><p>擦除减少了泛型的泛化性。泛型在Java中仍旧是有用的，只是不如他们本来设想的那么有用，而原因就是擦除。</p></li><li><p>在基于擦除的实现中，泛型类型被当作第二类型处理，即不能在某些重要的上下文环境中使用的类型。</p></li><li><p>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。</p></li><li><p>擦出的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“<strong>迁移兼容性</strong>”。</p></li></ul><h4 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h4><ul><li>泛型不能用于显式地引用运行时类型的操作之中，例如<strong>转型</strong>，<strong>instanceof</strong>操作和<strong>new表达式</strong>。</li><li>擦除和迁移兼容性意味着，使用泛型并不是强制的。</li><li>JDK5之后提供了一个注解<strong>@SuppressWarnings(“”)</strong>用于压制警告。</li></ul><h3 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h3><ul><li><p>擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125;<span class="comment">//Error</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();<span class="comment">//Error</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];<span class="comment">//Error</span></span><br><span class="line">        T[] array = (T)<span class="keyword">new</span> Object[SIZE];<span class="comment">//Unchecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>偶尔可以绕过这些问题来编程，但是有时必须通过引入类型标签来对擦除进行补偿。这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用他。</p></li></ul><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><ul><li><p>不能创建泛型数组。一般的解决方案是在任何想要创建泛型数组的地方都使用<strong>ArrayList</strong>(底层使用的数组结构)。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里你将获得数组的行为，以及由泛型提供的编译期的类型安全。</p></li><li><p>成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。</p></li></ul><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul><li>边界使得你可以在用于泛型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。</li><li>因为擦除移除了类型信息，所以，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法。但是，如果能够将这个参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行这种限制，<strong>Java</strong>泛型重用了<strong>extends</strong>关键字。</li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Apple</strong>的<strong>List</strong>不是<strong>Fruit</strong>的<strong>List</strong>。<strong>Apple</strong>的<strong>List</strong>将持有<strong>Apple</strong>和<strong>Apple</strong>的子类型，而<strong>Fruit</strong>的<strong>List</strong>将持有任何类型的<strong>Fruit</strong>，诚然，这包括<strong>Apple</strong>在内，但是它不是一个<strong>Apple</strong>的<strong>List</strong>，它仍旧是<strong>Fruit</strong>的<strong>List</strong>。<strong>Apple</strong>的<strong>List</strong>在类型上不等价于<strong>Fruit</strong>的<strong>List</strong>，即使<strong>Apple</strong>是一种<strong>Fruit</strong>类型。</p></li><li><p>有时你想在两个类型之间建立某种类型的向上转型关系，这是通配符所允许的。如：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt; ();</span><br><span class="line">        flist.add(<span class="keyword">null</span>);</span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>flist</strong>类型现在是<strong>List&lt;? extends Fruit&gt;</strong>,你可以将其读作“具有任何从Fruit继承的类型的列表”。</p></li><li><p><strong>List&lt;? extends Fruit&gt;</strong>可以合法的指向一个<strong>List<orange></orange></strong>。一旦执行这种类型的向上转型，你就将丢失掉向其中传递任何对象的能力，甚至是传递<strong>Object</strong>也不行。</p></li></ul><h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><ul><li><p>另外一种方式，及使用超类型通配符。可以声明通配符是由某个特定类的任何基类来界定的，方法是指定&lt;? super MyClass&gt;,甚至是使用类型参数：&lt;? super T&gt;(尽管你不能对泛型参数给出一个超类型边界；及不能声明<t super myclass>)。这使得你可以安全地传递一个类型对象到泛型类型中。但是，有了泛型通配符，就可以向Collection写入了：</t></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><ul><li><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;Warning:unchecked conversion</span><br><span class="line">        <span class="comment">//Found: List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assing3(new ArrayList());//Warning</span></span><br><span class="line">        <span class="comment">//Unchecked conversion.Found: ArrayList</span></span><br><span class="line">        <span class="comment">//Required:List&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        <span class="comment">//Both forms are acceptable as List&lt;?&gt;;</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译器并非总是关注像List和List<?>之间的这种差异，因此他们看起来就像是相同的事物。因为，事实上，由于泛型参数将擦除到他的第一个边界，因此List<?>看起来等价于List<object>,而List实际上也是List<object>除非这些语句都不为真。</object></object></p></li><li><p>List实际上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么”。</p></li><li><p>使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。</p></li></ul><h4 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h4><ul><li><p>有一种情况需要使用<?>而不是原生类型。如果向一个使用<?>的方法传递原生类型，那么对于编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法，下面演示这种技术，他被称为==<strong>捕获转换</strong>==，因为未指定的通配符类型被捕获，并被转换为确切类型，这里，有关警告的注释只有在<strong>@SuppressWarnings</strong>注解被移除之后才能起作用。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder);<span class="comment">//Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//f1(raw);//Produces warnings</span></span><br><span class="line">        f2(raw);<span class="comment">//No warnings</span></span><br><span class="line">        Hplder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);<span class="comment">//No warnings</span></span><br><span class="line">        <span class="comment">//Upcast to Holder&lt;?&gt;,still figures it out;</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>f1()</strong>中的类型参数都是确切的，没有通配符或边界。在<strong>f2()</strong>中，<strong>Holder</strong>参数是一个无界通配符，因此它看起来是未知的。但是，在<strong>f2()</strong>中，<strong>f1()</strong>被调用，而<strong>f1()</strong>需要一个已知参数。这里所发生的是：参数类型在调用<strong>f2()</strong>的过程中被捕获，因此它可以在对<strong>f1()</strong>的调用中被使用。</p></li></ul><h3 id="泛型常见问题"><a href="#泛型常见问题" class="headerlink" title="泛型常见问题"></a>泛型常见问题</h3><h4 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h4><ul><li><p>解决方案是使用基本类型的包装器以及Java SE5的自动包装机制。如果创建一个ArrayList<integer>，并将基本类型int应用于这个容器，那么自动包装机制将自动的实现int到Integer的双向转换。</integer></p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">            li.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i : li) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h4><ul><li><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口，下面是产生这种冲突的原因。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Hourly不能编译，因为擦除会将Payable<employee>和Payable<hourly>简化为相同的类Payable，这样，上面的代码就以为着在重复两次地实现相同地接口。有趣的是，如果从Payable地两种用法中都移除掉泛型参数，这段代码就可以编译。</hourly></employee></p></li></ul><h4 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h4><ul><li><p>使用带有泛型类型参数的转型或<strong>instanceof</strong>不会有任何效果。下面的容器在内部将各个值存储为<strong>Object</strong>，并在获取这些值时，在将他们转型回<strong>T</strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            FixedSizeStack&lt;String&gt; strings = <span class="keyword">new</span> FixedSizeStack&lt;String&gt;(SIZE);</span><br><span class="line">            <span class="keyword">for</span>(String s : <span class="string">"A BC D E F G H I J"</span>.split(<span class="string">" "</span>))</span><br><span class="line">            strings.push(s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                String s = strings.pop();</span><br><span class="line">                System.out.println(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果没有<strong>@SuppressWarnings</strong>注解，编译器将对<strong>pop()</strong>产生“<strong>unchecked cast</strong>”警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且<strong>pop()</strong>方法实际上并没有执行任何转型。这是因为，T被擦除到它的第一个边界，默认情况下是<strong>Object</strong>,因此<strong>pop()</strong>实际上只是将<strong>Object</strong>转型为<strong>Object</strong>。</p></li></ul><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul><li><p>下面的程序是不能编译的，即使编译它是一种合理的尝试。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于擦除的原因，重载方法将产生相同的类型签名。</p></li><li><p>与此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h3><ul><li><p>在Java泛型中，有一个好像是经常性出现的惯用法，它相当令人费解：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>这就像是两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong>类接受泛型参数<strong>T</strong>，而<strong>T</strong>由一个边界类限定，这个边界类就是拥有<strong>T</strong>作为其参数的<strong>SelfBounded</strong>。</p></li><li><p>当你首次看见他时，很难去解析它，它强调的是当<strong>extends</strong>关键字用于边界与用来创建子类明显是不同的。</p></li></ul><h4 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h4><ul><li><p><strong>BasicHolder</strong>可以使用任何类型作为其泛型类型，就像下面看到的这样。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(element.getClass().getSimpleName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b2 = BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><h5 id="自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。"><a href="#自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。" class="headerlink" title="自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。"></a>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。</h5></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">B</span>&gt; </span>&#123;&#125;<span class="comment">//Also OK</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>这会强制要求将正在定义的类当作参数传递给基类。</p></li><li><p>自限定参数的意义</p><ul><li>可以保证类型参数必须与正在被定义的类相同。</li><li>还可以从使用了另一个<strong>SelfBounded</strong>参数的<strong>SelfBounded</strong>中导出。</li></ul></li><li><p>自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。</p></li><li><p>还可以将自限定用于泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h4><ul><li><p>自限定类型的价值在于<strong>他们可以产生协变参数类型——方法参数类型会随着子类而变化</strong>。尽管自限定类型还可以产生于子类类型相同的返回类型，但是这并不十分重要，因为协变返回类型是在Java SE5中引入的：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>DerivedGetter</strong>中的<strong>get()</strong>方法覆盖了<strong>OrdinaryGetter</strong>中的<strong>get()</strong>,并返回了一个从<strong>OrdinaryGetter.get()</strong>的返回类型中导出的类型。尽管这是完全合乎逻辑的事情(<strong>导出类方法应该能够返回比它覆盖的基类方法更具体地类型</strong>)但是这在早先的Java版本中是不合法的。</p></li></ul><h3 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h3><ul><li><p>因为可以向<strong>Java SE5</strong>之前的代码传递泛型容器，所以旧式代码仍有可能会破坏你的容器，<strong>Java SE5</strong>的<strong>java.util.Collections</strong>中有一组便利工具，可以解决在这种情况下的类型检查问题，分别为：静态方法<strong>checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()</strong>及<strong>checkedSortedSet()</strong>。这些方法每一个都会将你希望动态检查的容器当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p></li><li><p>受检查的容器在你试图插入类型不正确的对象时抛出<strong>ClassCastException</strong>,这与泛型之前的(原生)容器形成了对比，对于后者来说，当你将对象从容器中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的容器，就可以发现谁在试图插入不良对象。</p></li><li><p>我们用受检查的容器来看看“将猫插入到狗列表中”这个问题。这里，<strong>oldStyleMethod()</strong>表示遗留代码，因为它接受的是原生的<strong>List</strong>，而<strong>@SuppressWarnings(“unchecked”)</strong>注解对于压制所产生的警告是必须的。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);</span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Pet&gt; pets = Collections.checkedList (<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">            pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">            pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行此程序时，你会发现插入一个Cat对于dogs1来说没有任何问题，而dogs2立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>由于擦除的原因，将泛型应用于异常时非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自Throwable(这将进一步阻止你去定义不能捕获的泛型异常)。</p></li><li><p>但是，类型参数可能会在一个方法的throws子句中用到。这使得你可以编写随检查型异常的类型而发生变化的泛型代码。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRunner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">    List&lt;T&gt; resultCollector = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Processor&lt;T,E&gt; processor : <span class="keyword">this</span>)</span><br><span class="line">    processor.process(resultCollector);</span><br><span class="line">    <span class="keyword">return</span> resultCollector;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failurel</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processpr</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            resultCollctor.add(<span class="string">"Hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Failure2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failure2</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failure2 </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count-- = <span class="number">0</span>)</span><br><span class="line">            resultCollector.add(<span class="number">47</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resultCollector.add(<span class="number">11</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            ProcessRunner&lt;String,Failure1&gt; runner = <span class="keyword">new</span> ProcessRunner&lt;String,Failure1&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            runner.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(runner.processAll());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Failure1 e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessRunner&lt;Integer,Failure2&gt; runner2 = <span class="keyword">new</span> ProcessRunner&lt;Integer,Failure2&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) </span><br><span class="line">            runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(runner2.processAll());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Failure2 <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Processor</strong>执行<strong>process()</strong>，并且可能会抛出具有类型E的异常。<strong>process()</strong>的结果存储在<strong>List<t> resultCollector</t></strong>中(<strong>这被称为收集参数</strong>)。<strong>ProcessRunner</strong>有一个<strong>processAll()</strong>方法，它将执行所持有的每个<strong>Process</strong>对象，并返回<strong>resultCollector</strong>。</p></li><li><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。</p></li></ul><h3 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h3><ul><li>混型：其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。</li><li>混型的价值之一是它们可以将特性和行为一致的应用于多个类之上。</li><li>在Java中，擦除会忘记基类类型，因此泛型类不能直接继承自一个泛型参数。</li></ul><h4 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h4><ul><li><p>常见的推荐解决方案是使用接口来产生混型效果，如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStampedImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span>,<span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamped = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumbered = <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamped.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumbered.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(),mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"text string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"text string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get()+<span class="string">" "</span>+mixin1.getStamp()+<span class="string">" "</span>+mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get()+<span class="string">" "</span>+mixin2.getStamp()+<span class="string">" "</span>+mixin2.getSerialNumber());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">text string 1 1571578397640 1</span></span><br><span class="line"><span class="comment">text string 2 1571578397640 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Mixin</strong>类基本上是在使用代理，因此每个混入类型都要求在<strong>Mixin</strong>中有一个相应的域，而你必须在<strong>Mixin</strong>中编写所有必须的方法，将方法调用转发给恰当的对象。</p></li></ul><h4 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h4><ul><li><p>装饰器模式使用分层对象来动态地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。</p></li><li><p>装饰器是通过使用组合和形式化结构(可装饰物/装饰器层次结构)来实现的，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basic = basic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        basic.set(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> basic.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStamped</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerialNumbered</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2= <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由使用装饰器所产生的对象的类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效的工作于装饰中的一层(最后一层)，而混型方法显然会更自然一些。因此，装饰器只是对由混型提出问题的一种局限的解决方案。</p></li></ul><h3 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li><p>可以使用的一种方式是反射。下面的<strong>perform()</strong>方法就是用了潜在类型机制。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mime"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woof"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sitting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker+<span class="string">"cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker+<span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面这些类完全是彼此分离的，没有任何公共基类(除了<strong>Object</strong>)或接口。通过反射，<strong>CommunicateRefleCtively.perform()</strong>能够动态地确定所需要的方法是否可用并调用他们，它甚至能够处理<strong>Mime</strong>只具有一个必须的方法这一事实，并能够部分实现其目标。</p></li></ul><h3 id="总结：转型真的如此之糟吗"><a href="#总结：转型真的如此之糟吗" class="headerlink" title="总结：转型真的如此之糟吗"></a>总结：转型真的如此之糟吗</h3><ul><li>在<strong>Java SE5</strong>之前，当你将一个对象放置到容器中时，这个对象就会被向上转型为<strong>Object</strong>，因此你会丢失类型信息。当你想要将这个对象从容器中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。如果没有<strong>Java SE5</strong>的泛型版本的容器，你放到容器里和从容器中取回，都是<strong>Object</strong>。</li><li>泛型出现之前的<strong>Java</strong>并不会让你误用放入到容器中的对象。如果将一个<strong>Dog</strong>扔到<strong>Cat</strong>的容器中，并且试图将这个容器中的所有东西都当作<strong>Cat</strong>处理，那么当你从这个<strong>Cat</strong>容器中取回那个<strong>Dog</strong>引用，并且试图将其转型为<strong>Cat</strong>时，就会得到一个<strong>RuntimeException</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十五章-泛型&quot;&gt;&lt;a href=&quot;#第十五章-泛型&quot; class=&quot;headerlink&quot; title=&quot;第十五章 泛型&quot;&gt;&lt;/a&gt;第十五章 泛型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十四章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十四章/</id>
    <published>2019-11-17T13:12:11.000Z</published>
    <updated>2019-11-17T13:33:32.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h2><ul><li>运行时类型信息使得你可以在程序运行时发现和使用类型信息。</li><li>Java是如何让我们在运行时识别对象和类的信息的，主要有两种方式。<ul><li>一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型。</li><li>一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</li></ul></li></ul><h3 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h3><ul><li>下面看一个我们已经很熟悉的一个例子，它使用了多态的类层次结构。最通用的类型是(泛型)是基类<strong>Shape</strong>，而派生出的具体类有<strong>Circle</strong>，<strong>Square</strong>和<strong>Triangle</strong>。</li></ul><p><img src="/2019/11/17/java编程思想第十四章/1568909940991.png" alt="1568909940991"></p><ul><li>这是一个典型的类层次结构图，基类位于顶部，派生类向下拓展。面向对象编程中基本的目的是：<strong>让代码只操纵对基类的引用</strong>。这样，如果要添加一个新类来扩展程序，就不会影响到原来的代码。在这个例子的<strong>Shape</strong>接口中动态的绑定了<strong>draw()</strong>方法，目的就是让客户端程序员使用泛化的<strong>Shape</strong>引用来调用<strong>draw()</strong>。<strong>draw()</strong>在所有派生类里都会被覆盖，并且由于它是被<strong>动态绑定</strong>的，所以即使是通过泛化的<strong>Shape</strong>引用来调用，也能产生正确行为。这就是==多态==。</li><li>因此，通常会创建一个具体的对象(Circle,Square,或者Triangle),把它向上转型成Shape(忽略对象的具体类型)，并在后面的程序中使用匿名的Shape引用。你可以像下面这样对Shape层次结构编码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">".draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Circle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Square"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Triangle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Circle(),<span class="keyword">new</span> Square(),<span class="keyword">new</span> Triangle());</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapeList) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Circle.draw()</span></span><br><span class="line"><span class="comment">Square.draw()</span></span><br><span class="line"><span class="comment">Triangle.draw()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>基类包含<strong>draw()</strong>方法，它通过传递<strong>this</strong>参数给<strong>System.out.println()</strong>,间接的使用<strong>toString()</strong>打印类标识符(注意，<strong>toString()被声明为abstract，以此强制继承者覆写该方法，并可以防止对无格式的Shape的实例化</strong>)。如果某个对象出现在字符串表达式中(涉及“+”和字符串对象的表达式)，<strong>toString()</strong>方法就会被自动调用，以生成表示该对象的<strong>String</strong>。每个派生类都要覆盖(从<strong>Object</strong>继承来的)<strong>toString()</strong>方法，这样<strong>draw()</strong>在不同情况下就打印出不同的消息(多态)。</p></li><li><p>在这个例子中，当把<strong>Shape</strong>对象放入<strong>List<shape></shape></strong>的数组时会向上转型。但在向上转型为<strong>Shape</strong>的时候也丢失了<strong>Shape</strong>对象的具体类型。对于数组而言，它们只是<strong>Shape</strong>类的对象。</p></li><li><p>当从数组中取出元素时，这种容器—–实际上它将所有的事物都当作<strong>Object</strong>持有—–会自动将结果转型回<strong>Shape</strong>。这是<strong>RTTI</strong>最基本的使用形式，因为在Java中，<strong>所有的类型转换都是在运行时进行正确性检查的</strong>，这也是<strong>RTTI</strong>名字的含义：在运行时，识别一个对象的类型。</p></li><li><p>在这个例子中，<strong>RTTI</strong>类型转换并不彻底：<strong>Object</strong>被转型为<strong>Shape</strong>，而不是转型为<strong>Circle</strong>,<strong>Square</strong>或者<strong>Triangle</strong>。这是因为目前我们只知道这个<strong>List<shape></shape></strong>保存的都是<strong>Shape</strong>。在编译时，将由容器和Java的泛型系统来强制确保这一点；而在运行时，由类型转换操作来确保这一点。</p></li><li><p>接下来就是多态机制的事情了，<strong>Shape</strong>对象实际执行什么样的代码，是由引用所指向的具体对象<strong>Circle</strong>,<strong>Square</strong>或者<strong>Triangle</strong>而决定的。通常，也正是这样的要求；你希望大部分代码尽可能少地了解对象的具体类型，而是只与对象家族中的一个通用表示打交道(在这个例子中是Shape)。这样代码会更容易写，更容易读，且更便于维护；设计也更容易实现，理解和改变。所以“多态”是面向对象编程的基本目标。</p></li></ul><h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><ul><li>要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。事实上，Class对象就是用来创建类的所有的“常规”对象的，Java使用Class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。Class对象还拥有大量的使用RTTI的其他方式。</li><li>类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象(更恰当地说，是被保存在一个同名的.class文件中)。为了生成这个类的对象，运行这个程序的Java虚拟机(JVM)将使用被称为“类加载器”的子系统。</li><li>类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生的类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，他们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求(如以某种特殊的方式加载类，以支持Web服务器应用，或者在网络中下载类)，那么你有一种方式可以挂接额外的类加载器。</li><li>所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。</li><li>因此，Java程序在它运行之前并非被完全加载，其各个部分是在必需时才加载的。这一点与许多传统语言都不同。</li><li>类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。</li><li>一旦某个类的Class对象被加载进内存，它就被用来创建这个类的所有对象。如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.ThinkingInJava;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Candy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Gum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SweetShop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"inside main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Candy();</span><br><span class="line">        System.out.println(<span class="string">"After creating Candy"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"Gum"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Couldn`t find Gum"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"After Class.forName(\"Gum\")"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cookie();</span><br><span class="line">        System.out.println(<span class="string">"After creating Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inside main</span></span><br><span class="line"><span class="comment">Loading Candy</span></span><br><span class="line"><span class="comment">After creating Candy</span></span><br><span class="line"><span class="comment">Couldn`t find Gum</span></span><br><span class="line"><span class="comment">After Class.forName("Gum")</span></span><br><span class="line"><span class="comment">Loading Cookie</span></span><br><span class="line"><span class="comment">After creating Cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>这里的每个类Candy,Gum和Cookie,都有一个static子句，该子句在类第一次被加载时执行。这时会有相应的信息打印出来，告诉我们这个类什么时候被加载了。在main()中，创建对象的代码被置于打印语句之间，以帮助我们判断加载的时间点。</li><li>从输出中可以看到，Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。</li><li>上面的<code>Class.forName(&quot;Gum&quot;);</code>这个方法是Class类的一个static成员。Class对象就和其他对象一样，我们可以获取并操作它的引用(这也是类加载器的工作)。forName()是取得Class对象的引用的一种方法。它是用一个包含目标类的文本名的String作输入参数，返回的是一个Class对象的引用，上面的代码忽略了返回值。对forName()的调用是为了它产生的“副作用”：如果类Gum还没有被加载就加载它。在加载的过程中。Gum的static子句被执行。</li><li>无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的<strong>Class</strong>对象的引用。<strong>Class.forName()</strong>就是实现此功能的便捷途径，因为你不需要为了获得<strong>Class</strong>引用而持有该类型的对象。但是，如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用<strong>getClass()</strong>方法来获取<strong>Class</strong>引用了，这个方法属于根类<strong>Object</strong>的一部分，它将返回表示该对象的实际类型的<strong>Class</strong>引用。</li></ul><h4 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h4><ul><li><p>Java还提供了另一种方法来生成对Class对象的引用，及使用==类字面常量==。即使用==类字面常量(类名.class)==。这样做不仅更简单，而且更安全。因为他在编译的时候就会受到检查(因此不需要置于try语句块中)。并且它根除了对==forName()==方法的调用，所以也更高效。</p></li><li><p>类字面常量不仅可以应用于普通的类，也可以用于接口，数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象，如下：</p><table><thead><tr><th align="center">boolean.class</th><th align="center">等价于</th><th align="center">Boolean.TYPE</th></tr></thead><tbody><tr><td align="center"><strong>char.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Character.TYPE</strong></td></tr><tr><td align="center"><strong>byte.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Byte.TYPE</strong></td></tr><tr><td align="center"><strong>short.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Short.TYPE</strong></td></tr><tr><td align="center"><strong>int.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Integer.TYPE</strong></td></tr><tr><td align="center"><strong>long.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Long.TYPE</strong></td></tr><tr><td align="center"><strong>float.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Float.TYPE</strong></td></tr><tr><td align="center"><strong>double.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Double.TYPE</strong></td></tr><tr><td align="center"><strong>void.class</strong></td><td align="center"><strong>等价于</strong></td><td align="center"><strong>Void.TYPE</strong></td></tr></tbody></table></li><li><p>当使用“<strong>.class</strong>”来创建对<strong>Class</strong>对象的引用的时候，不会自动地初始化该<strong>Class</strong>对象。为了使用类而做的准备工作实际包含三个步骤：</p><ul><li><strong>加载</strong>，这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。</li><li><strong>链接</strong>，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。</li><li><strong>初始化</strong>，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法或者非常数静态域进行首次引用时才执行。</li></ul></li><li><p>初始化有效地实现了尽可能的“惰性”。仅使用<strong>.class</strong>语法来获得对类的引用不会引发初始化。但是，为了产生<strong>Class</strong>引用，<strong>Class.forName()</strong>立即就进行了初始化。</p></li><li><p>如果一个<strong>static</strong>域不是<strong>final</strong>的，那么在对他进行访问时，总是要求在它被读取之前，要先进行链接(为这个域分配存储空间)和初始化(初始化该存储空间)。</p></li></ul><h4 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h4><ul><li><strong>Class</strong>引用总是指向某个<strong>Class</strong>对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。他还包含该类的静态成员，因此，<strong>Class</strong>引用表示的就是它所指向的对象的确切类型，而该对象便是<strong>Class</strong>类的一个对象。</li><li>在Java se5中，将他的类型变得更具体了一些，而这是通过允许你对Class引用所指向的Class对象的类型进行限制而实现的，此处用到了泛型语法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        Class&lt;Integer&gt; genericIntClass = <span class="keyword">int</span>.class;</span><br><span class="line">        genericIntClass = Integer.class;</span><br><span class="line">        intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通的类不会产生警告信息，尽管泛型类引用只能赋值为指向声明的类型，但是普通的类引用可以被重新赋值为指向任何其他的Class对象。通过使用泛型语法。可以让编译器强制执行额外的类型检查。</li><li>为了在使用泛化的Class引用时放松限制，使用通配符，它是java泛型的一部分。通配符就是“?”，表示“任何事物”。我们可以在上例的普通Class引用中添加通配符，并产生相同的结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardClassReferenes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Java se5中，Class<?>优于平凡的Class，即便他们是等价的，并且平凡的Class如你所见，不会产生编译器警告信息。Class<?>的好处是它表示你并非是碰巧或者由于疏忽，而使用了一个非具体的类引用，你就是选择了非具体的版本。</li><li>为了创建一个Class引用，他被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字相结合，创建一个范围。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedClassReferences</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Number&gt; bounded = <span class="keyword">int</span>.class;</span><br><span class="line">        bounded = <span class="keyword">double</span>.class;</span><br><span class="line">        bounded= Number.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查，因此如果你操作有误，稍后立即就会发现这一点。</li></ul><h4 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h4><ul><li><p>Java SE5中添加了用于Class引用的新的转型语法，即<strong>cast()</strong>方法:</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasts</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Building b = <span class="keyword">new</span> House();</span><br><span class="line">        Class&lt;House&gt; houseType = House.class;</span><br><span class="line">        House h = houseType.cast(b);</span><br><span class="line">        h = (house)b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>cast()</strong>方法接受参数对象，并将其转型为<strong>Class</strong>引用的类型。</p></li></ul><h3 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h3><ul><li><p>目前为止，已知的RTTI形式包括。</p><ul><li><p>传统的类型转换，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个<strong>ClassCastException</strong>异常。</p></li><li><p>代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。</p></li><li><p>RTTI在Java中还有第三种形式，就是关键字<strong>instanceof</strong>。他返回一个布尔值，告诉我们对象是不是某个特定类型的实例。可以用提问的方式使用它，就像这样:</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog) </span><br><span class="line">((Dog)x).bark();</span><br></pre></td></tr></table></figure></li><li><p>在将<strong>x</strong>转型为一个<strong>Dog</strong>前，上面的<strong>if</strong>语句会检查对象<strong>x</strong>是否从属于<strong>Dog</strong>类。进行向下兼容前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用<strong>instanceof</strong>是非常重要的，否则会得到一个<strong>ClassCastException</strong>异常。</p></li></ul></li></ul><h3 id="注册工厂"><a href="#注册工厂" class="headerlink" title="注册工厂"></a>注册工厂</h3><ul><li>你可能会考虑在每个子类中添加静态初始化器，以使得该初始化器可以将它的类添加到某个List中，遗憾的是，静态初始化器只有在类首先被加载的情况下才能被调用，因此你就要面临”先有鸡还是先有蛋”的问题，生成器在其列表中不包含这个类，因此它永远不能创建这个类的对象，而这个类也就不能被强制加载并置于这个列表中。</li><li>这主要是因为，你被强制要求自己去手工创建这个列表(除非你想编写一个工具，它可以全面搜索和分析源代码，然后创建和编译这个列表)。因此，最佳的做法是，将这个列表置于一个位于中心的，位置明显的地方，而我们感兴趣的继承结构的基类可能就是这个最佳位置。</li><li>这里我们需要做的其他修改就是使用工厂方法设计模式，将对象的创建工作交给类自己去完成，工厂方法可以被多态的调用，从而为你创建恰当类型的对象。下面这个例子中，工厂方法就是<strong>Factory</strong>接口中的<strong>create()</strong>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型参数T使得create()可以在每种Factory实现中返回不同的类型。这也充分利用了协变返回类型。</li></ul><h3 id="反射：运行时的类信息"><a href="#反射：运行时的类信息" class="headerlink" title="反射：运行时的类信息"></a>反射：运行时的类信息</h3><ul><li>如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别他，并利用这些信息做一些有用的事。</li><li>人们想要在运行时获取类的信息的另外一个动机，便是希望提供在跨网络的远程平台上创建和运行对象的能力。这被称为<strong>远程方法调用(RMI)</strong>，它允许一个Java程序将对象分布到多台机器上。</li><li>Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field,Method以及Constructor类(每个类都实现了Method接口)。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。</li><li>当通过反射与一个未知类型的对象打交道时，JVM只是简单得检查这个对象，看他属于哪个特定的类。在用它做其他事情之前必须先加载那个类的Class对象。因此，那个类的<strong>.class</strong>文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所以<strong>RTTI</strong>和反射之间真正的区别只在于，对<strong>RTTI</strong>来说，编译器在编译时打开和检查<strong>.class</strong>文件。而对于反射来说<strong>.class</strong>文件在编译时是不可获取的，所以是在运行时打开和检查<strong>.class</strong>文件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十四章-类型信息&quot;&gt;&lt;a href=&quot;#第十四章-类型信息&quot; class=&quot;headerlink&quot; title=&quot;第十四章 类型信息&quot;&gt;&lt;/a&gt;第十四章 类型信息&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;运行时类型信息使得你可以在程序运行时发现和使用类型信息。&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="类型信息" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十三章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十三章/</id>
    <published>2019-11-17T13:09:40.000Z</published>
    <updated>2019-11-17T13:33:21.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章 字符串"></a>第十三章 字符串</h2><h3 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h3><ul><li>==String对象是不可变的==，String类中每个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象则丝毫未动。</li><li>每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</li></ul><h3 id="重载-“-”-与StringBuilder"><a href="#重载-“-”-与StringBuilder" class="headerlink" title="重载   “+”  与StringBuilder"></a>重载   “+”  与StringBuilder</h3><ul><li>String对象是不可变的,你可以给一个String对象加任意多的别名。因为String对象具有只读特性，所以指向它的任意引用都不可能改变它的值，因此，也就不会对其他的引用有什么影响。</li><li>不可变性会带来一定的效率问题。为String对象重载的“+”操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义(用于String的“+”与“+=”是java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符)。</li><li>操作符“+”可以用来连接String。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concatenation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String mango = <span class="string">"mango"</span>;</span><br><span class="line">        String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="string">"47"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">abcmangodef47</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>StringBuilder是Java se1.5引入的，在这之前使用的是StringBuffer,后者是线程安全的，因此开销也会大些，所以在Java Se5/6中，字符串操作应该还会更快一些。</li></ul><h3 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h3><ul><li>Java中的每个类从根本上都是继承自<strong>Object</strong>，标准容器类也不例外，因此容器类都有<strong>toString()</strong>方法，并且覆写了该方法，使得它生成的String结果能够表达容器自身，以及容器所包含的对象。例如<strong>ArrayList.toString()</strong>，它会遍历<strong>ArrayList</strong>中包含的所有对象，调用每个对象上的<strong>toString()</strong>方法。</li><li>如果你希望toString()方法打印出对象的内存地址，也许你会考虑使用==this==关键字。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfinitRecursion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"InfinitRecursion address: "</span>+ <span class="keyword">this</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;InfinitRecursion&gt; v = <span class="keyword">new</span> ArrayList&lt;InfinitRecursion&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>:i++) &#123;</span><br><span class="line">    v.add(<span class="keyword">new</span> InfinitRecursion());</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当你创建了<strong>InfinitRecursion</strong>对象，并将其打印出来的时候，你会得到一串非常长的异常，</p><p><img src="/2019/11/17/java编程思想第十三章/1568475112738.png" alt="1568475112738"></p><p>如果你将该<strong>InfiniteRecursion</strong>对象存入一个<strong>ArrayList</strong>中，然后打印该<strong>ArrayList</strong>，你也会得到同样的异常，其实，当如下代码运行时：==”InfinitRecursion address: “+ this==,在这里发生了自动类型装换，由==InfinitRecursion==类型转换为String类型，因为编译器看到一个String对象后面跟着一个“+”，而后面的对象不是String，于是编译器试着将this转换成一个String。它怎么转换呢，正是调用this上的toString()方法，于是就发生了递归调用。</p></li><li><p>如果你真的想要打印出对象的内存地址，应该调用<strong>Object.toString()</strong>方法，这才是负责此任务的方法。所以你不该使用this，而是应该调用<strong>super.toString()</strong>方法。</p></li></ul><p><img src="/2019/11/17/java编程思想第十三章/1568475178185.png" alt="1568475178185"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十三章-字符串&quot;&gt;&lt;a href=&quot;#第十三章-字符串&quot; class=&quot;headerlink&quot; title=&quot;第十三章 字符串&quot;&gt;&lt;/a&gt;第十三章 字符串&lt;/h2&gt;&lt;h3 id=&quot;不可变String&quot;&gt;&lt;a href=&quot;#不可变String&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十二章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十二章/</id>
    <published>2019-11-17T13:07:51.000Z</published>
    <updated>2019-11-17T13:32:34.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><h3 id="java的基本理念是”结构不佳的代码不能直接运行”"><a href="#java的基本理念是”结构不佳的代码不能直接运行”" class="headerlink" title="java的基本理念是”结构不佳的代码不能直接运行”"></a>java的基本理念是”结构不佳的代码不能直接运行”</h3><h3 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h3><ul><li>当发生异常后,会有几件事情随之发生,首先,将使用new在堆内存中创建异常对象,然后,当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时,异常处理机制接管程序,并开始寻找一个恰当的地方来继续执行程序,这个恰当的地方就是==异常处理程序==,他的任务是将程序从错误状态中恢复,以使程序能要么换一种方式运行,要么继续运行下去.</li></ul><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ul><li><p>如:对于一个对象的引用t,传递给你的时候可能未被初始化,所以在使用这个对象引用调用其方法之前,会先对引用进行检查,可以创建一个代表错误信息的对象,并且将它从当前环境中”抛出”,这样就把错误信息传播到了”更大”的环境中,这被称为抛出异常如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><ul><li>与java中的其他对象一样,我们总是使用new在堆上创建异常对象,这也伴随着存储空间的分配和构造器的调用,所有的标准异常类都有两个构造器,一个是默认构造器;另一个是接受字符串作为参数,以便能把相关信息放入异常对象的构造器:   <code>throw new BullPointerException(&quot;t == null&quot;)</code></li></ul><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul><li><p><strong>try块</strong></p><ul><li>在方法内部抛出了异常(或者在方法内部调用的其他方法抛出异常),这个方法将在抛出异常的过程中结束,要是不希望方法就此结束,可以在方法内部设置一个特殊的块来捕获异常.因为在这个块里”尝试各种可能产生异常的方法调用,所以称之为try块,它是跟在try关键字之后的普通的程序块.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常处理程序</strong></p><ul><li>抛出的异常必须在某处得到处理,这个”地点”就是异常处理程序,而且针对每个要捕获的异常,得准备相应的处理程序.异常处理程序必须紧跟在<strong>try</strong>块之后,以关键字<strong>catch</strong>表示.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type1 id1) &#123;</span><br><span class="line">    <span class="comment">//Handle exceptions of Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type2 id2) &#123;</span><br><span class="line">    <span class="comment">//Handle exceptions of Type2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type3 idd3) &#123;</span><br><span class="line">    <span class="comment">//Handle exception of Type3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常处理程序必须紧跟在<strong>try</strong>块之后,当异常被抛出时,异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序,然后进入<strong>catch</strong>子句执行,此时认为异常得到了处理.一旦<strong>catch</strong>子句结束,则处理程序的查找过程结束,只有匹配的<strong>catch</strong>子句才能得到执行.</li></ul></li><li><p><strong>终止与恢复</strong></p><ul><li>异常处理理论上有两种基本模型.<ul><li>java支持<strong>终止模型</strong>,在这种模型中,将假设错误非常关键,以至于程序无法返回到异常发生的地方继续执行,一旦异常被抛出,就表明错误已无法挽回,也就不能回来继续执行.</li><li>另一种称为<strong>恢复模型</strong>,就是异常处理程序的工作是修正错误,然后重新尝试调用出问题的方法,并认为第二次能成功,,对于恢复模型,通常希望异常被处理之后能继续执行程序.如果用java实现类似的恢复的行为,那么在遇到错误时就不能抛出异常,而是调用方法来修正该错误.或者,把try块放在while循环中,这样就不断地进入try块,直到得到满意的结果.</li></ul></li></ul></li></ul><h3 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h3><ul><li>java<strong>提供的异常体系不可能预见所有的希望加以报告的错误</strong>,所以可以<strong>自定义异常类</strong>来表示程序中可能遇见的特定问题.<strong>要自定义异常类,必须从已有的异常类中继承,最好的方法就是选择意思相近的异常类继承(不过这样的有异常并不容易找).建立新的异常类的最简单的方法就是让编译器为你产生默认构造器</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.ThinkingInJava;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritingExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throw SimpleException from f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SimpleException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InheritingExceptions sed = <span class="keyword">new</span> InheritingExceptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sed.f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SimpleException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"Caught it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h3><ul><li><h5 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h5><ul><li>有时希望把刚刚捕获的异常重新抛出,尤其是在Exception捕获所有异常的时候,既然已经得到了对当前异常对象的引用,可以直接把它重新抛出:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"An exception was thrown"</span>);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重新抛出异常会把异常抛给上一级环境中的异常处理程序,同一个try块的后续catch子句将被忽略,此外,异常对象的所有信息都得以保持,所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息</li><li>永远不必为清理前一个异常对象而担心,或者说为异常对象的清理而担心,他们都是用new在堆上创建的对象,所以垃圾回收器会自动把他们清理掉.</li></ul></li><li><p><strong>异常链</strong></p><ul><li>常常会想要在捕获一个异常后抛出另一个异常,并且希望把原始异常的信息保存下来,这被称为==异常链==</li><li>在jdk1.4之前，程序员必须自己编写代码来保存原始异常的信息。现在所有的<strong>Throwable</strong>的子类在构造器中都可以接受一个cause对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</li><li>在==Throwable==的子类中，只有三种基本的异常类提供了带==cause==参数的构造器。分别为==Error==(用于java虚拟机报告系统错误)，==Exception以及RuntimeException。==如果要把其他类型的异常链接起来，应该使用==initCause()==方法而不是构造器。</li></ul></li></ul><h3 id="Java标准异常"><a href="#Java标准异常" class="headerlink" title="Java标准异常"></a>Java标准异常</h3><ul><li>==Throwable==这个Java类被用来表示任何作为异常被抛出的类。==Throwable==对象可以被分为两种类型<ul><li>==Error==：用来表示编译时和系统错误。</li><li>==Exception==:是可以被抛出的基本类型，在java类库，用户方法以及运行时故障中都可能抛出==Exception==型异常，所以我们需要关心的基类通常是==Exception==。</li><li>异常的基本的概念是用名称代表发生的问题，并且异常的名称应该是可以望文之意。异常并非全部定义在==java.lang==包里定义的，有些异常是用来支持其他像==util，net和io==这样的程序包，这些异常可以通过他们的完整名称或者从他们的父类中看出端倪，如：所有的输入/输出异常都是从==java.io.IOException==继承而来的。</li></ul></li></ul><h3 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h3><ul><li><p>对于一些代码，可能希望无论在try块中的异常是否抛出，他们都得到执行。这通常适用于内存回收之外的情况，为了达到这个效果需要在异常处理程序的后面加上finally子句。finally包围的代码表示总是执行(无论异常是否抛出)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//The guarded region: Dangerous activities</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (A a1) &#123;</span><br><span class="line">   <span class="comment">//Handler for situation A</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (A a2) &#123;</span><br><span class="line"><span class="comment">//Handler for situation B</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (A a3) &#123;</span><br><span class="line"><span class="comment">//Handler for situation C</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//Activities that happen every time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h4><ul><li>对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要，他能使程序员保证：==无论try块中发生了什么，内存总能得到释放==。但是java中有垃圾回收机制，所以内存释放不再是问题。而且，Java也没有析构函数可供调用。</li><li>Java在什么情况下需要用到finally？<ul><li>当要把除内存之外的资源恢复到他们的初始状态时，就要用到finally子句，这种需要清理的资源包括：已经打开的文件资源或网络连接，在屏幕上画得图形，甚至是外部世界的某个开关。</li><li>当涉及break和continue语句的时候，finally子句也会得到执行，请注意，如果把finally子句和带标签的break及continue配合使用，在java里就没有必要使用goto语句了。</li></ul></li></ul><h4 id="在return中使用finally"><a href="#在return中使用finally" class="headerlink" title="在return中使用finally"></a>在return中使用finally</h4><ul><li><p>因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">print(<span class="string">"Initialization that requires cleanup"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">print(<span class="string">"Point 1"</span>);</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">print(<span class="string">"Point 2"</span>);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">print(<span class="string">"Point 3"</span>);</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">print(<span class="string">"End"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  print(<span class="string">"Performing cleanup"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) </span><br><span class="line">f(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h4><ul><li>Java的异常实现也有瑕疵，异常作为程序出错的标志，决不应该被忽略，但他还是有可能被轻易的忽视。用某些特殊的方式使用finally子句，就会出现这种情况：</li></ul></li></ul><h3 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h3><ul><li>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常，这个限制很又用，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作(当然这是面向对象的基本概念)，异常也不例外。</li></ul><h3 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h3><ul><li>抛出异常的时候，异常处理系统会按照代码的书写顺序找出”最近”的处理程序。找到匹配的处理程序之后，他就认为异常将得到处理，然后就不再继续查找。</li><li>查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。</li></ul><h3 id="其他可选方式"><a href="#其他可选方式" class="headerlink" title="其他可选方式"></a>其他可选方式</h3><ul><li><p>异常处理的一个重要原则就是“只有在你知道如何处理的情况下才捕获异常”。实际上，异常处理的一个重要目标就是把错误处理的代码同错误发生的地点向分离。这使你能在一段代码中专注于要完成的事情，至于如何处理错误，则放在另一段代码中完成。这样一来，主干代码就不会与错误处理代码混在一起，也更容易理解和维护。通过允许一个处理程序去处理多个出错点，异常处理还使得错误处理代码的数量趋向于减少。</p></li><li><p>“被检查的异常”使这个问题变得有些复杂，因为他们强制你在可能还没准备好处理错误的时候被迫加上==catch==子句，这就导致了==吞食则有害==的问题</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//...to do something useful</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ObligatoryException e) &#123;&#125;<span class="comment">// Gulp</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异常使用指南"><a href="#异常使用指南" class="headerlink" title="异常使用指南"></a>异常使用指南</h3><ol><li>在恰当的级别处理问题。(在知道该如何处理的情况下才捕获异常)</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化。</li><li>让类库和程序更安全。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十二章&quot;&gt;&lt;a href=&quot;#第十二章&quot; class=&quot;headerlink&quot; title=&quot;第十二章&quot;&gt;&lt;/a&gt;第十二章&lt;/h2&gt;&lt;h3 id=&quot;java的基本理念是”结构不佳的代码不能直接运行”&quot;&gt;&lt;a href=&quot;#java的基本理念是”结构不佳的代码不能
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十八章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十八章/</id>
    <published>2019-11-17T12:59:19.000Z</published>
    <updated>2019-11-17T13:32:19.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h2><h3>对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</h3><ul><li><strong>Java 1.0</strong>版本以来，<strong>Java</strong>的<strong>I/O</strong>类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于<strong>Unicode</strong>的类。在<strong>JDK 1.4</strong>中，添加了<strong>nio</strong>类(对于“新<strong>I/O</strong>”来说，这是一个从现在起我们将要使用若干年的名称，即使它们在<strong>JDK 1.4</strong>中就已经被引入了，因此它们已经“旧”了)添加进来是为了改进性能及功能。</li></ul><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul><li><strong>File</strong>(文件)类这个名字具有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。==它既能代表一个特定文件的名称，有能代表一个目录下的一组文件的名称==。如果它指的是一个文件集，我们就可以对此集合调用<strong>list()</strong>方法，这个方法会返回一个字符数组。</li></ul><h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><ul><li><p>假设查看一个目录列表，可以用两种方法来使用<strong>File</strong>对象。如果调用不带参数的<strong>list()</strong>方法，便可以获得此<strong>File</strong>对象包含的全部列表。但是，如果我们想要获得一个受限列表，如：想得到所有拓展名为<strong>.java</strong>的文件，那么就需要使用“<strong>目录过滤器</strong>”，这个类会告诉我们怎么显示符合条件的<strong>File</strong>对象。</p></li><li><p>通过使用<strong>java.utils.sort()</strong>和<strong>String.CASE_INSENSITIVE.ORDERComparator</strong>，可以很容易的对结果进行排序(按字母顺序)</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">            Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>DirFilter</strong>这个类存在的唯一原因就是<strong>accept()</strong>方法。创建这个类的目的在于把<strong>accept()</strong>方法提供给<strong>list()</strong>使用，使<strong>list()</strong>可以回调<strong>accept()</strong>，进而以决定哪些文件包含在列表中。因此，这种结构也常常被称为==回调==。更具体的说，这是一个==策略模式==。==策略的目的就是提供了代码行为的灵活性==。</p></li><li><p><strong>accept()</strong>方法必须接受一个代表某个特定文件所在目录的<strong>File</strong>对象，以及包含那个文件的一个<strong>String</strong>。注意：==<strong>list()</strong>方法会为此目录对象下的每个文件名调用<strong>accept()</strong>,来判断该文件是否包含在内；判断结果由<strong>accept()</strong>返回的布尔值决定。==</p></li></ul><h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><ul><li><strong>File</strong>类不仅仅只代表存在的文件或目录。也可以用<strong>File</strong>对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，检查某个<strong>File</strong>对象代表的是一个文件还是一个目录，并可以删除文件。</li></ul><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul><li><strong>I/O</strong>库中常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。“流”屏蔽了实际的<strong>I/O</strong>设备中处理数据的细节。</li><li><strong>Java</strong>类库中的<strong>I/O</strong>类分成==输入和输出==两部分。通过==继承==，任何自<strong>InputStream</strong>或<strong>Reader</strong>派生而来的类都含有名为<strong>read()</strong>的基本方法，==用于读取单个字节或者字节数组==。同样，任何自<strong>OutputStream</strong>或<strong>Writer</strong>派生而来的类都含有名为<strong>write()</strong>的基本方法，==用于写单个字节或者字节数组==。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个流对象来提供所期望的功能(这是装饰器设计模式)。</li><li>实际上。<strong>Java</strong>中的“<strong>流</strong>”类库让人迷惑的主要原因就在于：==创建单一的结果流，却需要创建多个对象==。</li><li>在<strong>Java 1.0</strong>中，类库的设计者首先限定与<strong>输入</strong>有关的所有类都应该从<strong>InputStream</strong>继承,而<strong>输出</strong>有关的所有类都应该从<strong>OutputStream</strong>继承。</li></ul><h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul><li><strong>InputStream</strong>的作用是用来表示那些从不同数据源产生输入的类。包括：<ol><li>字节数组。</li><li><strong>String</strong>对象。</li><li>文件。</li><li>“管道”，工作方式与实际管道类似，即，从一端输入，从另一端输出。</li><li>一个由其他种类的流组成的序列，以便我们可以将它们收集和并到一个流内。</li><li>其他数据源，如<strong>Internet</strong>连接等。</li></ol></li><li>每一种数据源都有相应的<strong>InputStream</strong>子类。另外，<strong>FileInputStream</strong>也属于一种<strong>InputStream</strong>，为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</li></ul><table><thead><tr><th>类</th><th>功能</th><th>构造器参数/如何使用</th></tr></thead><tbody><tr><td><strong>ByteArrayInputStream</strong></td><td>允许将内存的缓冲区当作<strong>InputStrem</strong>使用</td><td>缓冲区，字节将从中取出<br>          作为一种数据源：将其与<strong>FileterInputStream</strong>对象相连以提供有用接口</td></tr><tr><td><strong>StringBufferInputStream</strong></td><td>将<strong>String</strong>转换为<strong>InputStream</strong></td><td>字符串。底层实现实际使用<strong>StringBuffer</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>FileInputStream</strong></td><td>用于从文件中读取信息</td><td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象1相连以提供有用接口</td></tr><tr><td><strong>PipedInputStream</strong></td><td>产生用于写入相关<strong>PipedOutputStream</strong>的数据。实现“管道化”概念</td><td><strong>PipedOutputStream</strong><br>          作为多线程中的数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>SequenceInputStream</strong></td><td>将两个或多个<strong>InputStream</strong>对象转换成单一<strong>InputStream</strong></td><td>两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<strong>Enumeration</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>FilterInputStream</strong></td><td>抽象类，作为“装饰器”的接口。其中“装饰器”为其他类的<strong>InputStream</strong>类提供有用功能。</td><td></td></tr></tbody></table><h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><ul><li>该类型的类决定了输出所要去往的目标：字节数组，文件或管道。</li><li><strong>FilterOutputStream</strong>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</li></ul><table><thead><tr><th>类</th><th>功能</th><th>如何使用</th></tr></thead><tbody><tr><td><strong>ByteArrayOutputStream</strong></td><td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td><td>缓冲区大小(可选的)<br>          用于指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>FileOutputStream</strong></td><td>用于将信息写至文件。</td><td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>PipedOutputStream</strong></td><td>任何写入其中的信息都会自动作为相关<strong>PipedInputStream</strong>的输出。实现“管道化”概念</td><td><strong>PipedInputStream</strong>          <br>指定用于多线程的数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td></tr><tr><td><strong>FilterOutputStream</strong></td><td>抽象类，作为“装饰器”的接口。其中，“装饰器”为其他<strong>OutputStream</strong>提供有用功能。</td><td></td></tr></tbody></table><h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><ul><li><strong>Java I/O</strong>类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是<strong>Java I/O</strong>类库里存在<strong>filter</strong>(过滤器)类的原因所在抽象类<strong>filter</strong>是所有装饰器的基类。</li><li>==装饰器必须具有和它所装饰的对象相同的接口==，但它也可以扩展接口，这种情况只发生在个别<strong>filter</strong>类中。</li><li>装饰器的==缺点==：在编写程序时，==增加了代码的复杂性==。<strong>Java I/O</strong>类库操作不便的原因在于：我们必须创建许多类—“核心” <strong>I/O</strong>类型加上所有的装饰器，才能得到我们所希望的单个<strong>I/O</strong>对象。</li><li><strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>是用来提供装饰器类接口以控制特定输入流(<strong>InputStream</strong>)和输出流(<strong>OutputStream</strong>)的两个类。<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>分别自<strong>I/O</strong>类库中的基类<strong>InputStream</strong>和<strong>OutputStream</strong>派生而来，这两个类是装饰器的必要条件。</li></ul><h4 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a>通过FilterInputStream从InputStream读取数据</h4><ul><li><strong>FilterInputStream</strong>类能够完成两件完全不同的事情。<ol><li><strong>DataInputStream</strong>允许我们读取不同的基本类型数据以及<strong>String</strong>对象(所有的方法都以“<strong>read</strong>”开头，如：<strong>readByte()</strong>,<strong>readFloat()</strong>等等)。搭配相应的<strong>DataOutputStream</strong>,就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</li><li>其他<strong>FilterInputStream</strong>类则在内部修改<strong>InputStream</strong>的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。</li></ol></li><li>我们几乎每次都要对输入进行缓冲—–不管我们正在连接的是什么<strong>I/O</strong>设备，所以，<strong>I/O</strong>类库把无缓冲输入(而不是缓冲输入)作为特殊情况(或只是方法调用)就显得更加合理了。</li></ul><table><thead><tr><th>类</th><th>功能</th><th>构造器参数/如何使用</th></tr></thead><tbody><tr><td><strong>DataInputStream</strong></td><td>与<strong>DataOutputStream</strong>搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)。</td><td><strong>InputStream</strong><br>包含用于读取基本类型数据的全部接口。</td></tr><tr><td><strong>BufferedInputStream</strong></td><td>使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。</td><td><strong>InputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td></tr><tr><td><strong>LineNumberInputStream</strong></td><td>跟踪输入流中的行号；可调用<strong>getLineNumber()</strong>和<strong>setLineNumber(int)</strong>。</td><td><strong>InputStream</strong><br>仅增加了行号，因此可能要与接口对象搭配使用。</td></tr><tr><td><strong>PushbackInputStream</strong></td><td>具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退。</td><td><strong>InputStream</strong><br>通常作为编译器的扫面器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td></tr></tbody></table><h4 id="通过FilterOutPutStream向OutputStream写入"><a href="#通过FilterOutPutStream向OutputStream写入" class="headerlink" title="通过FilterOutPutStream向OutputStream写入"></a>通过FilterOutPutStream向OutputStream写入</h4><ul><li>与<strong>DataInputStream</strong>对应的是<strong>DataOutputStream</strong>，它可以将各种<strong>基本数据类型</strong>以及<strong>String</strong>对象格式化输出到“流”中；这样，任何设备上的任何<strong>DataInputStream</strong>都能够读取它们。所有的方法都以”<strong>wirte</strong>“开头，如<strong>writeByte()</strong>,<strong>writeFloat()</strong>等等。</li><li><strong>PrintStream</strong>最初目的便是为了以可视化格式打印所有的<strong>基本数据类型</strong>以及<strong>String</strong>对象。这和<strong>DataOutputStream</strong>不同，后者的目的是将数据元素置入“流”中，使<strong>DataInputStream</strong>能够可移植地重构它们。</li><li><strong>PrintStream</strong>可能会有些问题，因为它捕捉了所有的<strong>IOException</strong>(因此，我们必需使用<strong>checkError()</strong>自行测试错误状态，如果出现错误它返回<strong>true</strong>)。另外，<strong>PrintStream</strong>也未完全国际化，不能以平台无关地方式处理换行动作(这些问题在<strong>printWriter</strong>中得到了解决)。</li><li><strong>BufferedOutputStream</strong>是一个修改过的<strong>OutputStream</strong>，<strong>它对数据流使用缓冲技术</strong>；因此当每次向流写入时，不必每次都进行实际的物理写操作。</li></ul><table><thead><tr><th>类</th><th>功能</th><th>构造器参数/如何使用</th></tr></thead><tbody><tr><td><strong>DataOutputStream</strong></td><td>与<strong>DataInputStream</strong>搭配使用，因此可以按照可移植方式向流中写入基本类型数据(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)</td><td><strong>OutputStream</strong><br>包含用于写入基本类型数据的全部接口。</td></tr><tr><td><strong>PrintStream</strong></td><td>用于产生格式化输出。其中<strong>DataOutputStream</strong>处理数据的存储，<strong>PrintStream</strong>处理显示。</td><td><strong>OutputStream</strong>,可以用<strong>boolean</strong>值指示是否在每次换行时清空缓冲区(可选的)应该是对<strong>OutputStream</strong>对象的“<strong>final</strong>”封装。</td></tr><tr><td><strong>BufferedOutputStream</strong></td><td>使用它以避免每次发送数据时都要进行实际的写操作。代表“使用缓冲区”。可以调用<strong>flush()</strong>清空缓冲区。</td><td><strong>OutputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td></tr></tbody></table><h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul><li><strong>Java 1.1</strong>对基本的<strong>I/O</strong>流类库进行了重大的修改。<strong>InputStream</strong>和<strong>OutputStream</strong>在以面向==字节==形式的<strong>I/O</strong>中提供极有价值的功能，<strong>Reader</strong>和<strong>Writer</strong>则提供兼容<strong>Unicode</strong>与面向==字符==的<strong>I/O</strong>功能。</li><li>有时我们必须把来自“<strong>字节</strong>”层次结构中的类和“<strong>字符</strong>”层次结构中的类结合起来使用。为了实现这个目的，要用到”<strong>适配器</strong>“(adapter)类：<strong>InputStreamReader</strong>可以把<strong>InputStream</strong>转换为<strong>Reader</strong>，而<strong>OutputStreamWriter</strong>可以把<strong>OutputStream</strong>转换为<strong>Writer</strong>。</li><li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的<strong>I/O</strong>流继承层次结构仅支持<strong>8位字节流</strong>，并且不能很好地处理<strong>16位的Unicode字符</strong>。由于<strong>Unicode</strong>用于<strong>字符国际化</strong>(<strong>Java</strong>本身的<strong>char</strong>也是16位的<strong>Unicode</strong>)，所以添加<strong>Reader</strong>和<strong>Writer</strong>继承层次结构就是为了在所有的<strong>I/O</strong>操作中都支持<strong>Unicode</strong>。</li></ul><h4 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h4><ul><li>在某些场合中，==面向字节==的<strong>InputStream</strong>和<strong>OutputStream</strong>才是正确的解决方案；特别是，<strong>java.util.zip</strong>类库就是==面向字节的而不是面向字符==的。因此，最明智的做法就是尽量尝试使用<strong>Reader</strong>和<strong>Writer</strong>，一旦程序代码无法成功编译，我们就会发现自己==不得不使用面向字节==的类库。</li><li>下面展示了在两个继承层次结构中，信息的来源和去处(即数据物理上来自哪里及去向哪里)之间的关系：</li></ul><table><thead><tr><th>来源与去处：Java 1.0类</th><th>相应的Java 1.1类</th></tr></thead><tbody><tr><td><strong>InputStream</strong></td><td><strong>Reader</strong><br>适配器：<strong>InputStreamReader</strong></td></tr><tr><td><strong>OutputStream</strong></td><td><strong>Writer</strong><br>适配器：<strong>OutputStreamWriter</strong></td></tr><tr><td><strong>FileInputStream</strong></td><td><strong>FileReader</strong></td></tr><tr><td><strong>FileOutputStream</strong></td><td><strong>FileWriter</strong></td></tr><tr><td><strong>StringBufferInputStream</strong>(已弃用)</td><td><strong>StringReader</strong></td></tr><tr><td>无</td><td><strong>StringWriter</strong></td></tr><tr><td><strong>ByteArrayInputStream</strong></td><td><strong>CharArrayReader</strong></td></tr><tr><td><strong>ByteArrayOutputStream</strong></td><td><strong>CharArrayWriter</strong></td></tr><tr><td><strong>PipedInputStream</strong></td><td><strong>PipedReader</strong></td></tr><tr><td><strong>PipedOutputStream</strong></td><td><strong>PipedWriter</strong></td></tr></tbody></table><h4 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h4><ul><li>对于<strong>InputStream</strong>和<strong>OutputStream</strong>来说，我们会使用<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>的装饰器子类来修改“<strong>流</strong>”以满足特殊需要。<strong>Reader</strong>和<strong>Writer</strong>的类继承层次结构继续沿用相同的思想，但是并不完全相同。</li></ul><table><thead><tr><th>过滤器 Java 1.0类</th><th>相应的 Java 1.1类</th></tr></thead><tbody><tr><td><strong>FilterInputStream</strong></td><td><strong>FilterReader</strong></td></tr><tr><td><strong>FilterOutputStream</strong></td><td><strong>FilterWriter</strong>(抽象类，没有子类)</td></tr><tr><td><strong>BufferedInputStream</strong></td><td><strong>BufferedReader</strong>(也有<strong>readLine()</strong>)</td></tr><tr><td><strong>BufferedOutputStream</strong></td><td><strong>BufferedWriter</strong></td></tr><tr><td><strong>DataInputStream</strong></td><td>使用<strong>DataInputStream</strong>(除了当需要使用<strong>readLine()</strong>时以外，这时应该使用<strong>BufferedReader</strong>)</td></tr><tr><td><strong>PrintStream</strong></td><td><strong>PrintWriter</strong></td></tr><tr><td><strong>LineNumberInputStream</strong>(已弃用)</td><td><strong>LineNumberReader</strong></td></tr><tr><td><strong>StreamTokenizer</strong></td><td><strong>StreamTokenizer</strong>(使用接受<strong>Reader</strong>的构造器)</td></tr><tr><td><strong>PushbackInputStream</strong></td><td><strong>PushbackReader</strong></td></tr></tbody></table><ul><li>无论我们何时使用<strong>readLine()</strong>,都不应该使用<strong>DataInputStream</strong>(这会遭到编译器的强烈反对)，而应该使用<strong>BufferedReader</strong>。除这一点，<strong>DataInputStream</strong>仍然是<strong>I/O</strong>类库的首选。</li><li><strong>PrintWriter</strong>提供了一个既能接受<strong>Writer</strong>对象又能接受任何<strong>OutputStream</strong>对象的构造器。<strong>PrintWriter</strong>的格式化接口实际上与<strong>PrintStream</strong>相同。</li><li>有一种<strong>PrintWriter</strong>构造器还有一个选项，就是“<strong>自动执行清空</strong>”选项。如果构造器设置此选项，则每个<strong>Println()</strong>执行之后，便会自动清空。</li></ul><h4 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h4><table><thead><tr><th>以下这些Java 1.0类在Java 1.1中没有相应类</th></tr></thead><tbody><tr><td><strong>DataOutputStream</strong></td></tr><tr><td><strong>File</strong></td></tr><tr><td><strong>RandomAccessFile</strong></td></tr><tr><td><strong>SequenceInputStream</strong></td></tr></tbody></table><ul><li><strong>DataOutputStream</strong>，在使用时没有任何变化；因此如果想以“可传输的”格式存储和检索数据，可以使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构。</li></ul><h3 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h3><ul><li><strong>RandomAccessFile</strong>适用于由大小已知的记录组成的文件，所以我们可以使用<strong>seek()</strong>将记录从一处转移到另一处，然后读取或者修改记录。</li><li>除了实现了<strong>DataInput</strong>和<strong>DataOutput</strong>接口之外，它和这两个继承层次结构没有任何关联。甚至不适用<strong>InputStream</strong>和<strong>OutputStream</strong>类中已有的任何功能。它是一个完全独立的类，这么做是因为<strong>RandomAccessFile</strong>拥有和别的<strong>I/O</strong>类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。</li><li>只有RandomAccessFile支持搜寻方法，并且只适用于文件。</li></ul><h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I/O流的典型使用方式"></a>I/O流的典型使用方式</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul><li><p>如果想要打开一个文件用于字符输入，可以使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputReader</strong>。为了提高速度，我们希望对那个文件进行缓冲，那么将所产生的引用传给一个<strong>BufferedReader</strong>构造器。由于<strong>BufferedReader</strong>也提供了<strong>readLine()</strong>方法，所以这是我们的最终对象和进行读取的接口。当<strong>readLine()</strong>将返回<strong>null</strong>时，你就达到了文件的末尾。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>字符串<strong>sb</strong>用来累计文件的全部内容(包括必须添加的换行符，因为<strong>readLine()</strong>已将它们删掉)。最后，调用<strong>close()</strong>关闭文件。</p></li></ul><h4 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h4><ul><li><p>下面，从<strong>BufferedInputFile.read()</strong>读入的<strong>String</strong>结果被用来创建一个<strong>StringReader</strong>。然后调用<strong>read()</strong>每次读取一个字符，并把它发送到控制台。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = sr.read())!= -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>read()</strong>是以<strong>int</strong>形式返回下一字节，因此必须类型转型为<strong>char</strong>才能正确打印。</p></li></ul><h4 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h4><ul><li><p>要读取格式化数据，可以使用<strong>DataInputStream</strong>,它是一个面向字节的<strong>I/O</strong>类(不是面向字符的)。因此我们必须使用<strong>InputStream</strong>类而不是<strong>Reader</strong>类。当然，可以用<strong>InputStream</strong>以字节的形式读取任何数据(如一个文件)，不过，这里使用的是字符串。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile</span><br><span class="line">                                    .read(<span class="string">"D://HelloWorld.java"</span>)</span><br><span class="line">                                    .getBytes()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>必须为<strong>ByteArrayInputStream</strong>提供字节数组，为了产生该数组<strong>String</strong>包含了一个可以实现此项工作的<strong>getBytes()</strong>方法。所产生的<strong>ByteArrayInputStream</strong>是一个适合传递给<strong>DataInputStream</strong>的<strong>InputStream</strong>。</p></li><li><p>如果我们从<strong>DataInputStream</strong>用<strong>readByte()</strong>一次一个字节读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束。相反，我们可以使用<strong>available()</strong>方法查看还有多少可供存储的字符。如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesrEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul><li><p>FileWriter对象可以向文件写入数据。创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出(尝试移除此包装来感受对性能的影响——缓冲往往能显著地增加I/O操作地性能)。下面，为了提供格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可作为普通文本文件读取。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://HelloWorld.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            out.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">2: public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">3: System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">4: &#125;</span></span><br><span class="line"><span class="comment">5: &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>一旦读完输入数据流，<strong>readLine()</strong>会返回<strong>null</strong>。我们可以看到要为<strong>out</strong>显示调用<strong>close()</strong>。如果我们不为所有的输出文件调用<strong>close()</strong>,就会发现缓冲区内容不会被刷新清空，那么它们就不完整。</p></li></ul><h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><ul><li><p><strong>PrintWriter</strong>可以对数据进行格式化，以便人们阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用<strong>DataOutputStream</strong>写入数据，并用<strong>DataInputStream</strong>恢复数据。当然，这些流可以是任意形式。注意：<strong>DataOutputStream</strong>和<strong>DataInputStream</strong>是==面向字节==的，因此要使用<strong>InputStream</strong>和<strong>OutputStream</strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">That was pi</span></span><br><span class="line"><span class="comment">1.41413</span></span><br><span class="line"><span class="comment">Square root of 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>DataOutputStream</strong>写入数据，<strong>Java</strong>保证我们可以使用<strong>DataInputStream</strong>准确地读取数据—无论读和写数据的平台多么不同。</p></li><li><p>当使用<strong>DataOutputStream</strong>时，写字符串并且让<strong>DataInputStream</strong>能够恢复它的==唯一可靠==的做法就是使用<strong>UTF-8</strong>编码，在示例中是用<strong>writeUTF()</strong>和<strong>readUTF()</strong>实现的。</p></li><li><p><strong>writeDouble()</strong>将<strong>double</strong>类型的数字存储到流中，并用相应的<strong>readDouble()</strong>恢复它(对于其他的数据类型，也有类似方法用于读写)。</p></li></ul><h4 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h4><ul><li><p>使用<strong>RandomAccessFile</strong>，类似于组合使用了<strong>DataInputStream</strong>和<strong>DataOutputStream</strong>(因为它实现了相同的接口：<strong>DataInput</strong>和<strong>DataOutput</strong>)。另外，利用<strong>seek()</strong>可以在文件中到处移动，并修改文件中的某个值。</p></li><li><p>使用<strong>RandomAccessFile</strong>时，你必须知道文件排版，这样才能正确使用它。<strong>RandomAccessFile</strong>拥有读取基本类型和<strong>UTF-8</strong>字符串的各种方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">" "</span>+rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">            rf.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">            rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">            rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 7.069999999999999</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 47.001</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>display()</strong>方法打开了一个文件，并以<strong>double</strong>值的形式显示了其中的七个元素。在<strong>main()</strong>中，首先创建了文件，然后打开并修改它。因为<strong>double</strong>总是8字节长，所以为了用<strong>seek()</strong>查找第5个双精度值，你只需用5*8来产生查找位置。</p></li></ul><h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul><li>程序的<strong>所有输入</strong>都可以来自于<strong>标准输入</strong>，它的<strong>所有输出</strong>也都可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送到<strong>标准错误</strong>。<strong>标准I/O</strong>的意义在于：我们可以很容易地把程序串联起来，一个程序的<strong>标准输出</strong>可以成为另一个程序的<strong>标准输入</strong>。</li></ul><h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul><li><p>按照标准<strong>I/O</strong>模型，<strong>Java</strong>提供了<strong>System.in</strong>,<strong>System.out</strong>,<strong>System.err</strong>。其中<strong>System.out</strong>已经事先被包装成了<strong>printStream</strong>对象。<strong>System.err</strong>同样也是<strong>PrintStream</strong>，但是<strong>System.in</strong>却是一个没有被包装过的未经加工的<strong>InputStream</strong>。这意味着尽管我们可以立即使用<strong>System.out</strong>和<strong>System.err</strong>，但是在读取<strong>System.in</strong>之前必须对其进行包装。</p></li><li><p>通常我们会用<strong>readLine()</strong>一次一行地读取输入，我们可以将<strong>System.in</strong>包装成<strong>BufferedReader</strong>来使用这要求我们必须用<strong>InputStreamReader</strong>把<strong>System.in</strong>转换成<strong>Reader</strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><ul><li><p><strong>System.out</strong>是一个<strong>PrintStream</strong>，而<strong>PrintStream</strong>是一个<strong>OutputStream</strong>。<strong>PrintWriter</strong>有一个可以接受<strong>OutputStream</strong>作为参数的构造器。所以，只要需要，就可以使用那个构造器把<strong>System.out</strong>转换成<strong>PrintWriter</strong>。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>将第二个参数设为<strong>true</strong>，以便开启自动清空功能；否则，有可能看不到输出。</p></li></ul><h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><ul><li><p><strong>System</strong>类提供了一些简单的静态方法调用，以允许我们对标准输入，输出和错误<strong>I/O</strong>流进行<strong>重定向</strong>：</p><ul><li><strong>setIn(InputStream)</strong></li><li><strong>setOut(PrintStream)</strong></li><li><strong>setErr(PrintStream)</strong></li></ul></li><li><p>如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用。如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"D://test.txt"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>I/O</strong>重定向操纵的是<strong>字节流</strong>，而不是字符流；因此我们使用的是<strong>InputStream</strong>和<strong>OutputStream</strong>，而不是<strong>Reader</strong>和<strong>Writer</strong>。</p></li></ul><h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><ul><li><p><strong>JDK 1.4</strong>的<strong>java.nio.*</strong>包中引入了新的<strong>Java I/O</strong>类库，其目的在于<strong>提高速度</strong>。速度的提高在<strong>文件I/O</strong>和<strong>网络I/O</strong>中都有可能发生。</p></li><li><p>速度的提高来自所使用的结构更接近于操作系统执行<strong>I/O</strong>的方式：<strong>通道和缓冲器</strong>。</p></li><li><p>唯一直接与通道交互的缓冲器是<strong>ByteBuffer</strong>—也就是说，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<strong>ByteBuffer</strong>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但却正好，因为这是大多数操作系统中更有效的映射方式。</p></li><li><p>旧<strong>I/O</strong>类库中有三个类被修改了，用以产生<strong>FileChannel</strong>。分别是<strong>FileInputStream</strong>,<strong>FileOutputStream</strong>以及用于<strong>既读又写</strong>的<strong>RandomAccessFile</strong>。注意这些是<strong>字节操作流</strong>，与低层的<strong>nio</strong>性质一致。<strong>Reader</strong>和<strong>Writer</strong>这种<strong>字符模式类</strong>不能用于产生通道；但是<strong>java.nio.channels.Channels</strong>类提供了实用方法，用以在通道中产生<strong>Reader</strong>和<strong>Writer</strong>。</p></li><li><p>下面演示上面的三种类型的流，用于产生<strong>可写</strong>的，<strong>可读可写</strong>的及<strong>可读</strong>的通道。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span> (buff.hasRemaining())</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buff.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Some text Some more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>getChannel()</strong>将会产生一个<strong>FileChannel</strong>。通道是一种相当基础的东西：可以向它传送用于读写的<strong>ByteBuffer</strong>，并且可以锁定文件的某些区域用于独占式访问。</p></li><li><p>将字节存放于<strong>ByteBufferr</strong>的方法之一是：使用一种“<strong>put</strong>”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<strong>warp()</strong>方法将已存在的字节数组“包装”到<strong>ByteBuffer</strong>中。一旦如此，就不再复制底层的数组，而是把它作为所产生的<strong>ByteBuffer</strong>的存储器，我们称之为数组支持的<strong>ByteBuffer</strong>。</p></li><li><p>对于只读访问，我们必须显式地使用静态的<strong>allocate()</strong>方法来分配<strong>ByteBuffer</strong>。<strong>nio</strong>的目标就是快速移动大量数据，因此<strong>ByteBuffer</strong>的大小就显得尤为重要。</p></li><li><p>甚至达到更高的速度也有可能，方法就是使用<strong>allocateDirect()</strong>而不是<strong>allocate()</strong>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p></li><li><p>一旦调用<strong>read()</strong>来告知<strong>FileChannel</strong>向<strong>ByteBuffer</strong>存储字节，就必须调用缓冲器上的<strong>fip()</strong>，让它做好让别人读取字节的准备。</p></li><li><p>如果打算使用缓冲器执行进一步的<strong>read()</strong>操作，我们也必须得调用<strong>clear()</strong>来为每个<strong>read()</strong>做好准备。如下面这个简单文件复制程序。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到，打开一个<strong>FileChannel</strong>用于读，而打开另一个以用于写。<strong>ByteBuffer</strong>被分配了空间，当<strong>FileChannel.read()</strong>返回<strong>-1</strong>时，表示我们已经到达了输入的末尾。每次<strong>read()</strong>操作之后，就会将数据输入到缓冲器中，<strong>filp()</strong>则是准备缓冲器以便它的信息可以由<strong>write()</strong>提取。<strong>write()</strong>操作之后，信息仍在缓冲器中，接着<strong>clear()</strong>操作则对所有的内部指针重新排序，以便缓冲器在另一个<strong>read()</strong>操作期间能够做好接受数据的准备。</p></li><li><p>上面的程序并不是处理此类操作的理想方式，特殊方法<strong>transferTo()</strong>和<strong>transferFrom()</strong>允许我们将一个通道和另一个通道直接相连。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><ul><li><p>尽管ByteBuffer只能保留字节类型的数据，但是它具有可以从其他所容纳的字节中产生出各种不同基本类型值的方法。如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; bb.limit())</span><br><span class="line">            <span class="keyword">if</span> (bb.get() != <span class="number">0</span>)</span><br><span class="line">                System.out.print(<span class="string">"nonzero"</span>);</span><br><span class="line">        System.out.print(<span class="string">"i ="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"Howdy!"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = bb.getChar())!= <span class="number">0</span>)</span><br><span class="line">            System.out.print(c+<span class="string">" "</span>+<span class="string">"\b"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">        System.out.println(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getInt());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getLong());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getFloat());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getDouble());</span><br><span class="line">        bb.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i =1025Howdy!</span></span><br><span class="line"><span class="comment">12390</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">9.9471144E7</span></span><br><span class="line"><span class="comment">9.9471142E7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>在分配一个<strong>ByteBuffer</strong>之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零，它的确是这样做的。这里一共检测了<strong>1024</strong>个值(由缓冲器的<strong>limit()</strong>决定)，并且所有的值都是<strong>0</strong>。</p></li><li><p>向<strong>ByteBuffer</strong>插入基本类型数据的最简单方式是：利用<strong>asCharBuffer(),asShortBuffer()</strong>等获得该缓冲器上的视图，然后使用视图的<strong>put()</strong>方法，使用<strong>ShortBuffer</strong>的<strong>put()</strong>方法时，需要进行类型转换。</p></li></ul><h4 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h4><ul><li><p>视图缓冲器(view buffer)可以让我们通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong>。<strong>ByteBuffer</strong>依然是实际存储数据的地方，“支持”着前面的视图。因此，对视图的修改都会映射成为对<strong>ByteBuffer</strong>中数据的修改。这使得我们可以很方便地向<strong>ByteBuffer</strong>插入数据。视图还允许我们从<strong>ByteBuffer</strong>一次一个地或者成批的读取基本类型值。下面，通过<strong>IntBuffer</strong>操纵<strong>ByteBuffer</strong>中的<strong>int</strong>型数值。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">888</span>,<span class="number">345</span>,<span class="number">3456</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span> (ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">1811</span></span><br><span class="line"><span class="comment">888</span></span><br><span class="line"><span class="comment">345</span></span><br><span class="line"><span class="comment">3456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>先用重载后的<strong>put()</strong>方法存储一个整数数组。接着<strong>get()</strong>和<strong>put()</strong>方法调用直接访问底层<strong>ByteBuffer</strong>中的某个整数位置。</p></li><li><p>一旦底层的<strong>ByteBuffer</strong>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型。</p></li></ul><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li><p>Java I/O类库中的类支持读写压缩格式的数据流，这些类不是从Reader和Writer类派生而来的，而是属于InputStream和OutputStream继承层次结构的一部分。这是因为压缩类库是按字节方式而不是字符方式处理的。</p><table><thead><tr><th>压缩类</th><th>功能</th></tr></thead><tbody><tr><td><strong>CheckedInputStream</strong></td><td><strong>GetCheckSum()</strong>为任何<strong>InputStream</strong>产生校验和(不仅是解压缩)</td></tr><tr><td><strong>CheckedOutputStream</strong></td><td><strong>GetCheckSum()</strong>为任何<strong>OutputStream</strong>产生校验和(不仅是压缩)</td></tr><tr><td><strong>DeflaterOutputStream</strong></td><td>压缩类的基类</td></tr><tr><td><strong>ZipOutputStream</strong></td><td>一个<strong>DeflaterOutputStream</strong>，用于将数据压缩成Zip文件格式</td></tr><tr><td><strong>GZIPOutputStream</strong></td><td>一个个<strong>DeflaterOutputStream</strong>，用于将数据压缩成GZIP文件格式</td></tr><tr><td><strong>InflaterInputStream</strong></td><td>解压缩类的基类</td></tr><tr><td><strong>ZipInputStream</strong></td><td>一个<strong>InflaterInputStream</strong>,用于解压缩Zip文件格式的数据</td></tr><tr><td><strong>GZIPInputStream</strong></td><td>一个<strong>InflaterInputStream</strong>,用于解压缩GZIP文件格式的数据</td></tr></tbody></table></li></ul><h4 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h4><ul><li><p>如果对单个数据流进行压缩，<strong>GZIP</strong>可能是一个比较适合的选择。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: \nGZIPcompress file\n"</span>+</span><br><span class="line">                    <span class="string">"\tUses GZIP comression to compress"</span> + <span class="string">"the file to test.gz"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"E://test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file"</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read())!= -<span class="number">1</span>)</span><br><span class="line">            out.write(c);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">"D://test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine())!= <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接将输出流封装成<strong>GZIPOutputStream</strong>或<strong>ZipOutputStream</strong>，并将输入流封装成<strong>GZIPInputStream</strong>或<strong>ZipInputStream</strong>即可。</p></li></ul><h4 id="Java档案文件"><a href="#Java档案文件" class="headerlink" title="Java档案文件"></a>Java档案文件</h4><ul><li><p><strong>Zip</strong>格式也被应用于<strong>JAR</strong>(Java Archive,Java档案文件)文件格式中。这种格式就像<strong>Zip</strong>一样，可以将一组文件压缩到单个压缩文件中。</p></li><li><p>如果不采用<strong>JAR</strong>文件，<strong>Web</strong>浏览器在下载构成一个应用的所有文件时必须重复多次请求<strong>Web</strong>服务器；而且所有这些文件都是未经压缩的。如果将所有这些文件合并到一个<strong>JAR</strong>文件中，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，可以使传输时间更短。另外，处于安全考虑，<strong>JAR</strong>文件中的每个条目都可以加上数字化签名。</p></li><li><p><code>jar [options] destination [manifest] inputfile(s)</code></p></li></ul><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>c</td><td>创建一个新的或空的压缩文档</td></tr><tr><td>t</td><td>列出目录表</td></tr><tr><td>x</td><td>解压所有文件</td></tr><tr><td>x file</td><td>解压该文件</td></tr><tr><td>f</td><td>意指：“我打算指定一个文件名。” 如果没有用这个选项，jar假设所有的输入都来自标准输入；或者在创建一个文件时，输出对象也假设为标准输出。</td></tr><tr><td>m</td><td>表示第一个参数将是用户自建的清单文件的名字</td></tr><tr><td>v</td><td>产生详细输出，描述jar所作的工作</td></tr><tr><td>O</td><td>只存储文件，不压缩文件(用来创建一个可放在类路径中的JAR文件)</td></tr><tr><td>M</td><td>不自动创建文件清单</td></tr></tbody></table><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul><li>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。</li><li><strong>Java</strong>的对象序列化将那些实现了<strong>Serializable</strong>接口的对象转换成了一个<strong>字节序列</strong>，并能在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。</li><li>序列化可以实现轻量级持久性。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久化的效果。</li><li>对象序列化主要是为了支持两种特性：<ol><li><strong>Java</strong>的<strong>远程方法调用(Remote Method Invocation,RMI)</strong>，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li><li>对<strong>Java Beans</strong>来说，对象的序列化也是必须的。使用<strong>Bean</strong>时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保留下来，并在程序启动时进行后期恢复；这种具体的工作就是由对象序列化完成的。</li></ol></li><li>要序列化一个对象，首先要创建某些<strong>OutputStream</strong>对象，然后将其封装在一个<strong>ObjectOutputStream</strong>对象内。这时，只需要调用<strong>writeObject()</strong>即可将对象序列化，并将其发送给<strong>OutputStream</strong>(对象化序列是基于字节的，因要使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构)。要反向进行该过程(即将一个序列化还原为一个对象)，需要将一个<strong>InputStream</strong>封装在<strong>ObjectInputStream</strong>内，然后调用<strong>readObject()</strong>。我们最后获得的是一个引用，它指向一个向上转型的<strong>Object</strong>，所以必须向下转型才能直接设置它们。</li></ul><h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><ul><li><p>我们将一个对象序列化，并通过网络将其作为文件传递给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个文件吗？</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    setter&amp;getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"D://X.file"</span>));</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://X.file"</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>打开文件和读取<strong>mystery</strong>对象的内容都需要<strong>User</strong>的<strong>Class</strong>对象；而<strong>Java</strong>虚拟机找不到<strong>User.class</strong>(除非它正好在类路径<strong>Classpath</strong>内)。这样就会得到一个<strong>ClassNotFoundException</strong>的异常。必须保证<strong>Java</strong>虚拟机能找到相关的<strong>.class</strong>文件。</p></li></ul><h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><ul><li>某些情况下你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</li><li>在这些特殊情况下，可通过实现<strong>Externalizable</strong>接口—–代替实现<strong>Serialzable</strong>接口—来对序列化进行控制。<strong>Externalizable</strong>接口继承了<strong>Serializable</strong>接口，同时还增加了两个方法：<strong>writeExternal()</strong>和<strong>readExternal()</strong>。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</li></ul><h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><ul><li><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息，通常就会面临这种情况。即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式访问它。</p></li><li><p>如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个的关闭序列化。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"username = "</span>+username+<span class="string">"&amp;&amp;"</span>+<span class="string">"password = "</span>+password+<span class="string">"&amp;&amp;"</span>+<span class="string">"date"</span>+date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">"Tom"</span>,<span class="string">"11111111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span>+ a);</span><br><span class="line">        ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">                o.writeObject(a);</span><br><span class="line">                o.close();</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Recovering object at "</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        a = (Logon)in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span> + a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = 11111111&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">Recovering object at Sun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = null&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>date</strong>字段被存储到磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p></li><li><p>由于<strong>Externalizable</strong>对象在默认情况下不保存它们的任何字段，所以<strong>transient</strong>关键字只能和<strong>Serializable</strong>对象一起使用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十八章-Java-I-O系统&quot;&gt;&lt;a href=&quot;#第十八章-Java-I-O系统&quot; class=&quot;headerlink&quot; title=&quot;第十八章 Java I/O系统&quot;&gt;&lt;/a&gt;第十八章 Java I/O系统&lt;/h2&gt;&lt;h3&gt;对程序语言的设计者来说，创建一个好
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="I/O" scheme="http://yoursite.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第十七章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第十七章/</id>
    <published>2019-11-17T12:55:57.000Z</published>
    <updated>2019-11-17T13:33:10.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h2><h3 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h3><p><img src="/2019/11/17/java编程思想第十七章/1572948167233-1573995500325.png" alt="1572948167233"></p><ul><li>Java SE5新添加了：<ul><li><strong>Queue</strong>接口(<strong>LinkedList</strong>已经为实现该接口做了修改及其实现<strong>PrioityQueue</strong>和各种风格的<strong>BlockingQueue</strong>)。</li><li><strong>ConcurrentMap</strong>接口及其实现<strong>ConcurrentHashMap</strong>(用于多线程机制)。</li><li><strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>,它们也是用与多线程机制。</li><li><strong>EnumSet</strong>和<strong>EnumMap</strong>，为使用<strong>enum</strong>而设计的<strong>Set</strong>和<strong>Map</strong>的特殊实现。</li><li>在<strong>Collections</strong>类中的的多个便利方法，虚线框表示<strong>abstract</strong>类，它们只是部分实现了特定接口的工具。如：你可以在创建自己的<strong>Set</strong>,那么并不用从<strong>Set</strong>接口开始并实现其中的全部方法，只需从<strong>AbstractSet</strong>继承，然后执行一些创建新类必须的工作。</li></ul></li></ul><h3 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h3><ul><li><p>容器的填充仍然像java.util.Arrays一样面临不足。就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill()。与Arrays版本一样，此fill()方法也是只是复制同一个对象引用来填充整个容器的，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StringAddress&#123;"</span> +</span><br><span class="line">                <span class="string">"s='"</span> + s + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>,<span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"World"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;]</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>上面展示了两种对单个对象引用来填充Collection的方式。</p><ul><li>第一种是使用<strong>Collections.nCopies()</strong>创建传递给构造器的<strong>List</strong>，此处填充的是<strong>ArrayList</strong>。</li><li>第二种是使用<strong>Collection.fill()</strong>,<strong>fill()</strong>方法的用处有限，因为它只能替换已经在<strong>List</strong>中存在的元素，而不能添加新元素。</li></ul></li></ul><h3 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>boolean add(T)</td><td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false</td></tr><tr><td>boolean addAll(Collection&lt;? extends T&gt;)</td><td>添加参数中的所有元素，只要添加了任意元素就返回true(可选的)移除容器中的所有元素(可选的)</td></tr><tr><td>boolean contains(T)</td><td>如果容器已经持有具有泛型类型T此参数，则返回true</td></tr><tr><td>Boolean containsAll(Collection&lt;?&gt;)</td><td>如果容器持有此参数中的所有元素，则返回true</td></tr><tr><td>boolean isEmpty()</td><td>容器中没有元素时返回true</td></tr><tr><td>Iterator<t> iterator()</t></td><td>返回一个Iterator<t>，可以用来遍历容器中的元素</t></td></tr><tr><td>Boolean remove(Object)</td><td>如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回true(可选的)</td></tr><tr><td>boolean removeAll(Collection&lt;?&gt;)</td><td>移除参数中的所有元素。只要有移除动作发生就返回true(可选的)</td></tr><tr><td>Boolean retainAll(Collection&lt;?&gt;)</td><td>只保存参数中的元素(应用集合论的“交集”概念)。只要Collection发生了改变就返回true(可选的)</td></tr><tr><td>int size()</td><td>返回容器中元素的数目</td></tr><tr><td>Object[] toArray()</td><td>返回一个数组，该数组包含容器中的所有元素</td></tr><tr><td><t> T[] toArray(T[] a)</t></td><td>返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object</td></tr><tr><td>void clear()</td><td>移除容器中的所有元素(可选)</td></tr></tbody></table><ul><li>其中不包括随机访问所选择元素的<strong>get()</strong>方法。因为<strong>Collection</strong>包括<strong>Set</strong>，而<strong>Set</strong>是自己维护内部顺序的。因此，如果想检查<strong>Collection</strong>中的元素，那就必须使用迭代器。</li></ul><h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><ul><li>执行各种不同的添加和移除的方法在<strong>Collection</strong>接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。</li><li>接口时面向对象设计中的契约，它声明“<strong>无论你选择如何实现该接口，我保证你可以向该接口发送这些消息</strong>”，但是可选操作违反了这个非常基本的原则，它声明调用某些方法将不会执行有意义的行为，相反，他会抛出异常。</li><li>如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。</li><li>为什么将方法定义为可选的？因为这样做可以防止在设计中出现==接口爆炸==的情况。容器类库中的其他设计看起来总是为了描述每个主题的各种变体，而最终患上了接口过剩症。甚至这么做仍不能捕捉接口的各种特例，因为总有人发明新的接口，“未获支持的操作”这种方式可以实现Java容器类库的一个重要目标：==容器应该易学易用==。未获支持的操作是一种特例，可以延迟到需要时再实现。但是为了让这种方式能工作。<ol><li><strong>UnsupportedOperationException</strong>必须是一种罕见事件，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。这种设计留下了一个“后门”，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么它仍旧适合现有的类库。</li><li>如果一个操作是未获支持的，那么在实现接口的时候可能就会导致<strong>UnsupportedOperationException</strong>异常。毕竟，它表示编程上有错误，使用了不正确的接口实现。</li></ol></li><li>未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。</li></ul><h4 id="未获支持的操作"><a href="#未获支持的操作" class="headerlink" title="未获支持的操作"></a>未获支持的操作</h4><ul><li><p>常见的未获支持的操作，都来源于背后由==固定尺寸的数据结构支持的容器==，当你用<strong>Arrays.asList()</strong>将数组转换为<strong>List</strong>时，就会得到这样的容器。还可以通过使用<strong>Collections</strong>类中的“不可修改”的方法，选择创建任何会抛出<strong>UnsupportedOperationException</strong>的容器(包括Map)。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---"</span>+msg+<span class="string">"---"</span>);</span><br><span class="line">        Collection&lt;String&gt; c = list;</span><br><span class="line">        Collection&lt;String&gt; subList = list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.retainAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"retainAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.removeAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"removeAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"clean()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.add(<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.addAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.remove(<span class="string">"C"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"remove()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(<span class="number">0</span>,<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A B C D E F G H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"Modifiable Copy"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"Arrays.asList()"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList()"</span>, Collections.unmodifiableList(</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;(list)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Modifiable Copy---</span></span><br><span class="line"><span class="comment">---Arrays.asList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">---unmodifiableList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">List.set()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Arrays.asList()</strong>会生成一个<strong>List</strong>，它基于一个固定大小的数组，仅支持那些不会改变数组大小的操作，任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个<strong>UnsupportedOpreationException</strong>异常，以表示对未获支持操作的调用(一个编程错误)。</p></li><li><p>应该把<strong>Arrays.asList()</strong>的结果作为构造器的参数传递给任何<strong>Collection</strong>(或者使用<strong>addAll()</strong>方法，或<strong>Collections.addAll()</strong>静态方法)，这样可以生成允许使用所有的方法的普通容器，这样的调用会产生新的尺寸可调的底层数据结构。</p></li><li><p><strong>Collections</strong>类中的”不可修改”的方法将容器包装到了一个代理中，只要你执行任何试图修改容器的操作，这个代理都会产生<strong>UnsupportedOperationException</strong>异常，使用这些方法的目标就是产生”常量”容器对象。</p></li></ul><h3 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h3><ul><li><p>在<strong>Java</strong>中像<strong>Integer</strong>和<strong>String</strong>这样的<strong>Java</strong>预定义的类型，这些类型被设计为可以在容器内部使用。当你创建自己的类型时，要意识到<strong>Set</strong>需要一种方式来维护存储顺序，而存储顺序如何维护，则是在<strong>Set</strong>的不同实现之间会有所变化。因此，不同的<strong>Set</strong>实现不仅具有不同的行为，而且它们对于可以在特定的<strong>Set</strong>中放置的元素的类型也有不同的要求。</p><table><thead><tr><th>类型</th><th>特性</th></tr></thead><tbody><tr><td><strong>Set</strong>(interface)</td><td>存入<strong>Set</strong>的每个元素都必须是唯一的，因为<strong>Set</strong>不保存重复元素。加入<strong>Set</strong>的元素必须定义<strong>equals()</strong>方法以确保对象的唯一性。<strong>Set</strong>与<strong>Collection</strong>有完全一样的接口。<strong>Set</strong>接口不保证维护元素的次序。</td></tr><tr><td><strong>HashSet</strong>(项目中最常使用)</td><td>为快速查找而设计的<strong>Set</strong>。存入<strong>HashSet</strong>的元素必须定义<strong>hashCode()</strong></td></tr><tr><td><strong>TreeSet</strong></td><td>保持次序的<strong>Set</strong>，底层为树结构。使用它可以从<strong>Set</strong>中提取有序的序列。元素必须实现<strong>Comparable</strong>接口。</td></tr><tr><td><strong>LinkedHashSet</strong></td><td>具有<strong>HashSet</strong>的查询速度，且内部使用链表维护元素的顺序(插入的顺序)。于是在使用迭代器遍历<strong>Set</strong>时，结果会按元素的次序显示。元素也必须定义<strong>hashCode()</strong>方法。</td></tr></tbody></table></li><li><p>你必须为散列存储和树形存储都创建一个<strong>equals()</strong>方法，但是<strong>hashCode()</strong>只有在这个类将被置于<strong>HashSet</strong>或<strong>LinkedHashSet</strong>中时才是必需的。但是建议你应该在覆盖<strong>equals()</strong>方法时，总是同时覆盖<strong>hashCode()</strong>方法。</p></li><li><p>下面演示为了成功的使用特定的Set实现类而必须定义的方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        i = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i == ((SetType)o).i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeType arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arg.i &lt; i ? -<span class="number">1</span> : (arg.i == i ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fill</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(</span><br><span class="line">                        type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="comment">[7, 7, 0, 8, 5, 9, 4, 1, 1, 3, 2, 3, 1, 9, 2, 8, 4, 6, 5, 4, 6, 8, 0, 3, 7, 5, 0, 6, 2, 9]</span></span><br><span class="line"><span class="comment">[2, 6, 1, 7, 1, 4, 0, 0, 9, 9, 9, 4, 7, 8, 0, 3, 8, 8, 7, 6, 3, 5, 5, 1, 6, 2, 2, 4, 3, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException: java.lang.ClassCastException: com.ym.ThinkingInJava.SetType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: com.ym.ThinkingInJava.HashType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>为了证明那些方法对于某种特定的<strong>Set</strong>是必需的，并且同时还要避免代码重复，我们创建了三个类，基类<strong>SetType</strong>只存储一个<strong>int</strong>，并且通过<strong>toString()</strong>方法产生它的值。因为所有在<strong>Set</strong>中存储的类都必须具有<strong>equals()</strong>方法，因此在基类中也有该方法。其等价性是基于这个<strong>int</strong>类型的<strong>i</strong>的值来确定的。</p></li><li><p><strong>HashType</strong>继承自<strong>SetType</strong>，并且添加了<strong>hashCode()</strong>方法，该方法对于放置到<strong>Set</strong>的散列实现中的对象来说是必需的。</p></li><li><p><strong>TreeType</strong>实现了<strong>Comparable</strong>接口，如果一个对象被用于任何种类的排序容器中，如<strong>SortedSet</strong>(<strong>TreeSet</strong>的其唯一实现)，那么它必须实现这个接口。注：==在<strong>compareTo()</strong>中，没有使用“简洁明了”的形式<strong>return i-i2,</strong>因为这是一个常见的编程错误，它只有在<strong>i</strong>和<strong>i2</strong>都是无符号的<strong>int</strong>(如果<strong>Java</strong>确实有<strong>unsigned</strong>关键字的话，但实际上并没有)时才能正确工作。对于<strong>Java</strong>的有符号<strong>int</strong>，他就会出错，因为<strong>int</strong>不够大，不足以表现两个有符号<strong>int</strong>的差。如：<strong>i</strong>是一个很大的正数，而j是很大的负整数，<strong>i-j</strong>就会溢出并且返回负值，这就不正确了==。</p></li><li><p><strong>fill()</strong>和<strong>test()</strong>方法都是使用泛型定义的，这是为了避免代码重复。</p></li><li><p><strong>HashSet</strong>以某种神秘的顺序保存所有的元素，<strong>LinkedhashSet</strong>按照元素插入的顺序保存元素，而<strong>TreeSet</strong>按照排序顺序维护元素(按照<strong>compareTo()</strong>的实现方式，这里维护的是降序)</p></li><li><p>对于没有重新定义<strong>hashCode()</strong>方法的<strong>SetType</strong>或<strong>TreeType</strong>，如果将它们放置到任何散列实现中都会产生重复值，这样就违反了Set的基本契约。</p></li><li><p>如果在<strong>TreeSet</strong>中使用没有实现<strong>Comparable</strong>的类型，那么你将会得到更确定的结果，在<strong>TreeSet</strong>试图将该对象当作<strong>Comparable</strong>使用时，将抛出一个异常。</p></li></ul><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><ul><li>SortedSet中的元素可以保证处于排序状态，这使得它可以通过在SortedSet接口中的下列方法提供附加的功能：</li></ul><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><strong>Comparator comparator()</strong></td><td>返回当前<strong>Set</strong>使用的<strong>Comparator</strong>;或者返回<strong>null</strong>，表示以自然方式排序。</td></tr><tr><td><strong>Object first()</strong></td><td>返回容器中的第一个元素。</td></tr><tr><td><strong>Object last()</strong></td><td>返回容器中的最末一个元素</td></tr><tr><td><strong>SortedSet subSet(fromElement,toElement)</strong></td><td>生成此Set的子集，范围从<strong>fromElement</strong>(包含)到<strong>toElement</strong>(不包含)</td></tr><tr><td><strong>SortedSet headSet(toElement)</strong></td><td>生成此<strong>Set</strong>的元素，由小于<strong>toElement</strong>的元素组成</td></tr><tr><td><strong>SortedSet tailSet(fromElement)</strong></td><td>生成此<strong>Set</strong>的子集，由大于或等于<strong>fromElement</strong>的元素组成</td></tr></tbody></table><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(sortedSet,<span class="string">"one two three four five six seven eight"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">3</span>) low = it.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) high = it.next();</span><br><span class="line">            <span class="keyword">else</span> it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">        System.out.println(sortedSet.headSet(high));</span><br><span class="line">        System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">eight</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">[one, seven, six, three]</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three]</span></span><br><span class="line"><span class="comment">[one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>SortedSet</strong>是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用<strong>LinkedHashSet</strong>来保存。</p></li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><p>除并发应用，<strong>Queue在SE5中仅有的两个实现是LinkedList和PriorityQueue</strong>，两者的<strong>差异在于排序行为而不是性能</strong>。</p></li><li><p>下面是Queue实现的大部分操作的示例，包括基于并发的Queue.你可以将元素从队列的一端插入，并从另一端将它们抽取出来：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)</span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        String[] s = (<span class="string">"one two three four five six seven eight nine ten"</span>).split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>除了优先级队列(<strong>PriorityBlockingQueue,PriorityQueue</strong>)，<strong>Queue</strong>将精确地按照元素被置于<strong>Queue</strong>中的顺序产生它们。</p></li></ul><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><ul><li><p>该列表中的每个对象都包含一个字符串和一个主要的以及次要的优先级值。该列表的排序顺序也是通过实现Comparable而进行控制的。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoList</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDoList</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String td,<span class="keyword">char</span> pri, <span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.primary = pri;</span><br><span class="line">            <span class="keyword">this</span>.secondary = sec;</span><br><span class="line">            <span class="keyword">this</span>.item = td;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ToDoItem arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primary &gt; arg.primary)</span><br><span class="line">                <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (primary == arg.primary)</span><br><span class="line">                <span class="keyword">if</span> (secondary &gt; arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (secondary == arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toString(primary)+secondary+<span class="string">": "</span>+item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ToDoList toDoList = <span class="keyword">new</span> ToDoList();</span><br><span class="line">        toDoList.add(<span class="string">"Empty trash"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed bird"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Mow lawn"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Water lawn"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed cat"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!toDoList.isEmpty())</span><br><span class="line">            System.out.println(toDoList.remove());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A1: Water lawn</span></span><br><span class="line"><span class="comment">A2: Feed dog</span></span><br><span class="line"><span class="comment">B1: Feed cat</span></span><br><span class="line"><span class="comment">B7: Feed bird</span></span><br><span class="line"><span class="comment">C3: Mow lawn</span></span><br><span class="line"><span class="comment">C4: Empty trash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><ul><li><p>双向队列(双端队列)就像是一个队列，但是你可以在任何一端添加或移除元素。在<strong>LinkedList</strong>中包含支持双向队列的方法，但是在<strong>Java</strong>标准类库中没有任何显式的用于双向队列的接口。因此，<strong>LinkedList</strong>无法去实现这样的接口，你也无法转型到<strong>Queue</strong>那样去向上转型为<strong>Deque(双向队列/dek/)</strong>。但是，你可以使用组合来创建一个<strong>Deque</strong>类，并直接从<strong>LinkedList</strong>中暴露相关的方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    ..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillTest</span><span class="params">(Deque&lt;Integer&gt; deque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            deque.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">55</span>; i++) &#123;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; di = <span class="keyword">new</span> Deque&lt;&gt;();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        System.out.println(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeFirst() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeLast() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[26, 25, 24, 23, 22, 21, 20, 50, 51, 52, 53, 54]</span></span><br><span class="line"><span class="comment">26 25 24 23 22 21 20 50 51 52 53 54 </span></span><br><span class="line"><span class="comment">54 53 52 51 50 20 21 22 23 24 25 26 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>你可能不太在两端放入元素并抽取它们，因此，<strong>Deque</strong>不如<strong>Queue</strong>那样常用。</p></li></ul><h3 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h3><ul><li><p>标准的<strong>Java</strong>类库中包含了<strong>Map</strong>的几种基本实现，包括：<strong>HashMap</strong>,<strong>TreeMap</strong>,<strong>LinkedHashMap</strong>,<strong>WeakHashMap</strong>,<strong>ConcurrentHashMap</strong>,<strong>IdentityHashMap</strong>。</p></li><li><p>上面实现类都有同样的基本接口<strong>Map</strong>，但是行为特征各不相同，==这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和判定“键”等价的策略等方面==。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        pairs = <span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= pairs.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        pairs[index++] = <span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(pairs[i][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++) &#123;</span><br><span class="line">            result.append(pairs[i][<span class="number">0</span>].toString());</span><br><span class="line">            result.append(<span class="string">" : "</span>);</span><br><span class="line">            result.append(pairs[i][<span class="number">1</span>].toString());</span><br><span class="line">            <span class="keyword">if</span> (i &lt; index - <span class="number">1</span>)</span><br><span class="line">                result.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AssociativeArray&lt;String,String&gt; map = <span class="keyword">new</span> AssociativeArray&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">"sky"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        map.put(<span class="string">"grass"</span>,<span class="string">"green"</span>);</span><br><span class="line">        map.put(<span class="string">"ocean"</span>,<span class="string">"dancing"</span>);</span><br><span class="line">        map.put(<span class="string">"tree"</span>,<span class="string">"tall"</span>);</span><br><span class="line">        map.put(<span class="string">"earth"</span>,<span class="string">"brown"</span>);</span><br><span class="line">        map.put(<span class="string">"sun"</span>,<span class="string">"warm"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">"extra"</span>,<span class="string">"object"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Too many objects!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"ocean"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Too many objects!</span></span><br><span class="line"><span class="comment">sky : blue</span></span><br><span class="line"><span class="comment">grass : green</span></span><br><span class="line"><span class="comment">ocean : dancing</span></span><br><span class="line"><span class="comment">tree : tall</span></span><br><span class="line"><span class="comment">earth : brown</span></span><br><span class="line"><span class="comment">sun : warm</span></span><br><span class="line"><span class="comment">dancing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>关联数组中的基本方法是<strong>put()</strong>和<strong>get()</strong>,<strong>toString()</strong>方法被覆盖为可以打印键-值对，<strong>main()</strong>用字符串加载了一个<strong>AssociativeArray</strong>，并打印所产生的映射表，随后是获取一个值的<strong>get()</strong>。</p></li><li><p>上面中为了使用<strong>get()</strong>方法，你需要传递想要查找的<strong>key</strong>，然后它会将于之相关联的值作为结果返回，或者在找不到的情况下返回<strong>null</strong>，<strong>get()</strong>方法使用的是效率最差的方式来定位值的：从数组的头部开始，使用<strong>equals()</strong>方法依次比较键。</p></li><li><p>上面示例中的版本是说明性的，但是缺乏效率，并且由于固定的尺寸而显得很不灵活，但是在<strong>java.util</strong>中的各种<strong>Map</strong>都没有这些问题，并且可以替代到上面的示例中。</p></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>性能是映射表中的一个重要问题，当在<strong>get()</strong>中使用线性搜索时，执行速度会相当地慢，而这正是<strong>HashMap</strong>提高速度的地方。<strong>HashMap</strong>使用了特殊的值，称为散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的，用以代表对象的<strong>int</strong>值，它是通过将该对象的某些信息进行转换而生成的。<strong>hashCode()</strong>是根类<strong>Object</strong>中的方法，因此所有<strong>Java</strong>对象都能产生散列码。</li><li>HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。</li></ul><table><thead><tr><th>名称</th><th>概述</th></tr></thead><tbody><tr><td><strong>HashMap</strong>(默认选择)</td><td><strong>Map</strong>基于==散列表的实现==(它取代了<strong>Hashtable</strong>)。==插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。==</td></tr><tr><td><strong>LinkedHashMap</strong></td><td>类似于<strong>HashMap</strong>，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(<strong>LRU</strong>)的次序。==只比<strong>HashMap</strong>慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。==</td></tr><tr><td><strong>TreeMap</strong></td><td>基于红黑树的实现。==看“键“或”键值对“时，它们会被排序(次序由<strong>Comparable</strong>或<strong>Comparator</strong>决定)。====<strong>TreeMap</strong>的特点在于，所得到的结果是经过排序的。<strong>TreeMap</strong>是唯一的带有<strong>subMap()</strong>方法的<strong>Map</strong>，他可以返回一个子树。==</td></tr><tr><td><strong>WeakHashMap</strong></td><td>弱键(<strong>weak key</strong>)映射，允许释放映射所指向的对象；==这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个”键”，则此”键“可以被垃圾收集器回收。==</td></tr><tr><td><strong>ConcurrentHashMap</strong></td><td>一种线程安全的<strong>Map</strong>，它不涉及同步加锁。</td></tr><tr><td><strong>IdentityHashMap</strong></td><td>==使用代替<strong>equals()</strong>对”键“进行比较的散列映射，专为解决特殊问题而设计的。==</td></tr></tbody></table><ul><li>散列是映射中存储元素时最常用的方式。</li><li>对<strong>Map</strong>中使用的键的要求与对<strong>Set</strong>中的元素的要求一样，任何键都必须具有一个<strong>equals()</strong>方法；如果键被用于散列<strong>Map</strong>，那么它必须还具有恰当的<strong>hashCode()</strong>方法，如果键被用于<strong>TreeMap</strong>，那么它还必须实现<strong>Comparable</strong>。</li></ul><h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h4><ul><li>使用<strong>SortedMap</strong>(==<strong>TreeMap</strong>是现阶段的唯一实现==)，==可以确保键处于排序状态==，这使得它具有额外的功能，这些功能由<strong>SortedMap</strong>接口中的以下方法提供：</li></ul><table><thead><tr><th>方法</th><th>概述</th></tr></thead><tbody><tr><td><strong>Comparator comparator()</strong></td><td>返回当前<strong>Map</strong>使用的<strong>Comparator</strong>；或者返回<strong>null</strong>，表示以自然方式排序。</td></tr><tr><td><strong>T firstKey()</strong></td><td>返回<strong>Map</strong>中的第一个键。</td></tr><tr><td><strong>T lastKey()</strong></td><td>返回<strong>Map</strong>中的最末一个键。</td></tr><tr><td><strong>SortedMap subMap(fromKey,toKey)</strong></td><td>生成此<strong>Map</strong>的子集，范围由<strong>fromKey</strong>(包含)到<strong>toKey</strong>(不包含)的键确定。</td></tr><tr><td><strong>SortedMap headMap(toKey)</strong></td><td>生成此<strong>Map</strong>的子集，由键小于<strong>toKey</strong>的所有键值对组成。</td></tr><tr><td><strong>SortedMap tailMap(fromKey)</strong></td><td>生成此<strong>Map</strong>的子集，由键大于或等于<strong>fromKey</strong>的所有键值对组成。</td></tr></tbody></table><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul><li>为了==提高速度==，<strong>LinkedHashMap</strong>==散列化所有元素==，但是在==遍历键值对==时，却又==以元素的插入顺序返回键值对==(<strong>System.out.println()</strong>会迭代遍历该映射，因此可以看到遍历的结果)。此外，可以在构造器中设定<strong>LinkedHashMap</strong>，使之采用基于访问的==最近最少使用(<strong>LRU</strong>)算法==，于是==没有被访问过的==(可被看作需要删除的)==元素就会出现在队列的前面==。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</li></ul><h3 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h3><ul><li><p>当你自己创建用作<strong>HashMap</strong>的键的类，==有可能会忘记在其中放置必须的方法==，而这是通常会犯的一个错误。如：一个天气预报系统，将<strong>Groundhog</strong>对象与<strong>Prediction</strong>对象练习起来。创建这两个类，使用<strong>Groundhog</strong>作为键，<strong>Prediction</strong>作为值。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        number = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Groundhog&#123;"</span> +</span><br><span class="line">                <span class="string">"number="</span> + number +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow = rand.nextDouble() &gt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shadow)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of Winter!"</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog = type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map = <span class="keyword">new</span> HashMap&lt;Groundhog,Prediction&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">            System.out.println(<span class="string">"map="</span>+map);</span><br><span class="line">            Groundhog gh = ghog.newInstance(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"Looking up prediction for "</span>+gh);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(gh))</span><br><span class="line">                System.out.println(map.get(gh));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"Key not found:"</span> + gh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        detectSpring(Groundhog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#5=Early Spring, Groundhog#9=Six more weeks of Winter!, Groundhog#8=Six more weeks of Winter!, Groundhog#7=Early Spring, Groundhog#1=Six more weeks of Winter!, Groundhog#3=Early Spring, Groundhog#6=Early Spring, Groundhog#0=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#4=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Key not found:Groundhog#3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>每个<strong>Groundhog</strong>被给予一个标识数字，于是可以在<strong>HashMap</strong>中这样查找<strong>Prediction</strong>,“给我与<strong>Groundhog#3</strong>相关的<strong>Prediction</strong>”。<strong>Prediction</strong>类包含一个<strong>boolean</strong>值和一个<strong>toString()</strong>方法。<strong>boolean</strong>值使用<strong>java.util.random()</strong>来初始化；而<strong>toString()</strong>方法则解释结果。<strong>detectSpring()</strong>方法使用反射机制来实例化及使用<strong>Groundhog</strong>类或任何从<strong>Groundhog</strong>派生出来的类。如果我们为解决当前问题从<strong>Groundhog</strong>继承创建了一个新类型的时候，<strong>detectSpring()</strong>方法使用的这个技巧就变得很有用了。</p></li><li><p>首先会使用<strong>Groundhog</strong>和与之相关联的<strong>prediction</strong>填充<strong>HashMap</strong>，然后打印<strong>HashMap</strong>，以便可以观察它是否被填入了一些内容。然后使用标识数字为3的<strong>Groundhog</strong>作为键，查找与之对应的预报内容。</p></li><li><p>但是它不工作，它无法找到数字3这个键，问题出在<strong>Groundhog</strong>自动的继承自基类<strong>Object</strong>，所以这里使用<strong>Object</strong>的<strong>hashCode()</strong>方法生成散列码，而==它默认是使用对象的地址计算散列码。==</p></li><li><p>也许你会认为，==只需要恰当的<strong>hashCode()</strong>方法的覆盖版本即可。但是它仍然无法正常运行，除非你同时覆盖<strong>equals()</strong>方法，==它也是<strong>Object</strong>的一部分。<strong>HashMap</strong>使用<strong>equals()</strong>判断当前的键是否与表中存在的键相同。</p></li><li><p>正确的<strong>equals()</strong>方法必须满足下面==5个条件==：</p><ol><li>==自反性。对任意x,x.equals(x)一定返回true。==</li><li>==对称性。对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。==</li><li>==传递性。对任意x,y,z,如果有x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。==</li><li>==一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。==</li><li>==对任何不是null的x，x.equals(null)一定返回false。==</li></ol></li><li><p>默认的<strong>Object.equals()</strong>只是==比较对象的地址==，所以一个<strong>Groundhog(3)</strong>并不等于另一个<strong>Groundhog(3)</strong>。因此，==<u>如果要使自己的类作为<strong>HashMap</strong>的键，必须同时重载<strong>hashCode()</strong>和<strong>equals()</strong></u>==</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog2</span> <span class="keyword">extends</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Groundhog2 &amp;&amp;</span><br><span class="line">                (number == ((Groundhog2)obj).number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringDetector.detectSpring(Groundhog2.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#0=Six more weeks of Winter!, Groundhog#1=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#3=Early Spring, Groundhog#4=Six more weeks of Winter!, Groundhog#5=Early Spring, Groundhog#6=Early Spring, Groundhog#7=Early Spring, Groundhog#8=Six more weeks of Winter!, Groundhog#9=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Early Spring</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>尽管<strong>equals()</strong>方法只是检查其参数是否为<strong>Groundhog2</strong>的实例，但是<strong>instanceof</strong>悄悄地检查了此对象是否为<strong>null</strong>，因为如果<strong>instanceof</strong>左边的参数为<strong>null</strong>，它会返回<strong>false</strong>。如果<strong>equals()</strong>的参数不为<strong>null</strong>且类型正确，则基于每个对象中实际的<strong>number</strong>数值进行比较。</p></li><li><p>当在HashSet中使用自己的类作为键时，必须注意这个问题。</p></li></ul><h4 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h4><ul><li>上面说明了，如果不为你的键覆盖<strong>hashCode()</strong>和<strong>equals()</strong>，那么使用散列的数据结构(<strong>HashSet</strong>,<strong>HashMap</strong>,<strong>LinkedHashSet</strong>或<strong>LinkedHashMap</strong>)就无法正确处理你的键。</li><li>使用散列的目的在于：想要使用一个对象来查找另一个对象。</li><li>不过使用<strong>TreeMap</strong>或者你实现的<strong>Map</strong>也可以达到此目的。</li></ul><h4 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h4><ul><li>==散列的价值在于速度：散列使得查询得以快速进行==。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用<strong>Collections.binarySearch()</strong>进行查询。</li><li>散列则更近一步，它将键保存在某处，以便能很快找到，存储一组元素最快的数据结构是数组，所以使用它来表示键的信息，但是因为数组不能调整容量，因此会出现问题，我们希望在<strong>Map</strong>中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办？</li><li>解决方案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在<strong>Object</strong>中的，且可能由你的类覆盖的<strong>hashCode()</strong>方法(在计算机科学的术语中称为散列函数)生成。</li><li>查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突(如果值的数量是固定的，那么就有可能)，那可就有一个完美的散列函数，但是这种情况只是特例。通常，冲突由外部链接处理：==数组并不能直接保存值，而是保存值的<strong>list</strong>。==然后对<strong>list</strong>中的值使用<strong>equals()</strong>方法进行线性查询，这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个<strong>list</strong>，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是<strong>HashMap</strong>会如此之快的原因。</li></ul><h4 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h4><ul><li><p>设计<strong>hashCode()</strong>时最重要的因素就是：无论何时，对同一个对象调用<strong>hashCode()</strong>都应该生成同样的值。如果在将一个对象用<strong>put()</strong>添加进<strong>HashMap</strong>时产生一个<strong>hashCode()</strong>值，而用<strong>get()</strong>取出时却产生另一个<strong>hashCode()</strong>值，那么就无法重新取得该对象了。</p></li><li><p>此外，也不应该使<strong>hashCode()</strong>依赖于具有唯一性的对象信息，尤其是使用<strong>this</strong>的值，这只能产生糟糕的<strong>hashCode()</strong>。因为这样做无法生成一个新的键，使之与<strong>put()</strong>中原始的键值对中的键相同。</p></li><li><p><strong>String</strong>有个特点：==如果程序中有多个<strong>String</strong>对象，都包含相同的字符串序列，那么这些<strong>String</strong>对象都映射到同一块内存区域。==所以<strong>new String(“hello”)</strong>生成的两个实例，虽然是相互独立的，但是对它们使用<strong>hashCode()</strong>应该生成同样的结果。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] hellos = <span class="string">"Hello Hello"</span>.split(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(hellos[<span class="number">0</span>].hashCode());</span><br><span class="line">        System.out.println(hellos[<span class="number">1</span>].hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>对<strong>String</strong>而言，<strong>hashCode()</strong>明显是基于<strong>String</strong>的内容的。</p></li><li><p>要想使<strong>hashCode()</strong>实用，它必须基于对象的内容生成散列码。(散列码不必是独一无二的，但是通过<strong>hashCode()</strong>和<strong>equals()</strong>，必须能够完全确定对象的身份)</p></li><li><p>因为在生成桶的下标前，<strong>hashCode()</strong>还需要做进一步的处理，所以散列码的生成范围并不重要，只要是<strong>int</strong>即可。</p></li><li><p>好的<strong>hashCode()</strong>应该产生分布均匀的散列码。如果散列码都集中在一块，那么<strong>HashMap</strong>或者<strong>HashSet</strong>在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p></li></ul><h3 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h3><ul><li><strong>Hashtable</strong>,<strong>Vector</strong>和<strong>Stack</strong>的“<strong>特征</strong>”是，它们是过去遗留下来的类，目的是为了支持老的程序(最好不要在新的程序中使用它们)</li><li>容器之间的区别通常归结为由什么在背后“支持”它们。也就是说，==所使用的接口是由什么样的数据结构实现的。==</li></ul><h4 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h4><ul><li>对于背后有数组支撑的<strong>List</strong>和<strong>ArrayList</strong>，无论列表的大小如何，访问都很快速和一致，而对于<strong>LinkedList</strong>，访问时间对于较大的列表将明显增加。显然，如果你需要执行大量的随机访问，链表不会是一种好的选择。</li><li>当在列表中间插入新的元素。对于<strong>ArrayList</strong>，当列表变大时，其开销将变得很高昂，但是对于<strong>LinkedList</strong>，相对来说比较低廉，并且不随列表尺寸而发生变化。这是因为<strong>ArrayList</strong>在插入时，必须创建空间并将它的所有引用向前移动，这会随<strong>ArrayList</strong>的尺寸增加而产生高昂的代价。<strong>LinkedList</strong>只需链接新的元素，而不必修改列表中剩余的元素。</li><li><strong>LinkedList</strong>对<strong>List</strong>的端点会进行特殊处理，这使得在将<strong>LinkedList</strong>用作<strong>Queue</strong>时，速度可以得到提高。但是，如果你在列表的中间增加或移除元素，其中会包含随机访问的代价，这在不同的<strong>List</strong>实现中变化很大。</li><li>在<strong>LinkedList</strong>中的插入和移除代价相当低廉，并且不随列表尺寸发生变化，但是对于<strong>ArrayList</strong>，插入操作代价特别高昂，并且其代价将随列表尺寸的增加而增加。</li><li>对于随机访问的<strong>get()</strong>和<strong>set()</strong>操作，背后有数组支撑的<strong>List</strong>只比<strong>ArrayList</strong>稍快一点，但是对于<strong>LinkedList</strong>，同样的操作会变得异常的高昂。因为它本身就不是针对随机访问操作而设计的。</li><li>==最佳的做法可能是将<strong>ArrayList</strong>作为默认首选==，只有你需要使用额外的功能，或者当程序的性能因为经常从表中进行插入和删除而变差的时候，才去选择<strong>LinkedList</strong>。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支撑的<strong>List</strong>(就像<strong>Arrays.asList()</strong>产生的列表)，也可以选择真正的数组。</li><li><strong>CopyOnWriteArrayList</strong>是<strong>List</strong>的特殊实现，专门用于并发编程。</li></ul><h4 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h4><ul><li><strong>HashSet</strong>的性能基本上总是比<strong>TreeSet</strong>好，特别是在添加和查询元素时，<strong>TreeSet</strong>存在的唯一原因是它可以维持元素的排序状态；所以，只有当需要一个排好序的<strong>Set</strong>时，才用<strong>TreeSet</strong>。因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，所以，用<strong>TreeSet</strong>迭代通常比用<strong>HashSet</strong>要快。</li><li>对于插入操作，<strong>LinkedHashSet</strong>比<strong>HashSet</strong>的代价更高；这是由维护链表所带来额外开销造成的。</li></ul><h4 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h4><ul><li>除了<strong>IdentityHashMap</strong>,所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。</li><li><strong>Hashtable</strong>的性能大体上与<strong>HashMap</strong>相当。因为<strong>HashMap</strong>是用来替代<strong>Hashtable</strong>的，因此它们使用了相同的底层存储和查找机制。</li><li><strong>TreeMap</strong>通常比<strong>HashMap</strong>要慢。与使用<strong>TreeSet</strong>一样，<strong>TreeMap</strong>是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。</li><li>当使用<strong>Map</strong>时，你的第一选择应该是<strong>HashMap</strong>,只有在你要求<strong>Map</strong>始终保持有序时，才需要使用<strong>TreeMap</strong>。</li><li><strong>LinkedHashMap</strong>在插入时比<strong>HashMap</strong>慢一点，因为它维护散列数据结构的同时还要维护链表(以保持插入顺序)。正是由于这个列表，使得其迭代速度更快。</li><li><strong>IdentityHashMap</strong>则具有完全不同的性能，==因为它使用的是<strong>==</strong>而不是<strong>equals()</strong>来比较元素。==</li></ul><h5 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h5><ul><li>我们可以通过手工调整<strong>HashMap</strong>来提高其性能，从而满足我们特定应用的需求。为了在调整<strong>HashMap</strong>时理解性能问题，下面术语必要了解以下：<ul><li>==<strong>容量</strong>==：表中的桶位数。</li><li>==<strong>初始容量</strong>==：表在创建时所拥有的桶位数。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定初始容量的构造器。</li><li>==<strong>尺寸</strong>==：表中当前存储的项数。</li><li>==<strong>负载因子</strong>==：尺寸/容量。==空表的负载因子是0==，==而半满表的负载因子是0.5，以此类推==。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的(但是会减慢使用迭代器进行遍历的过程)。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量(桶位数),实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中(这被称为再散列)。<strong>HashMap</strong>使用的默认负载因子是==0.75==(只有当表达到3/4满时，才进行再散列)，这个因子在时间和空间代价之间达到了平衡。</li></ul></li><li>如果你知道将要在<strong>HashMap</strong>中存储多少项，那么==创建一个具有恰当大小的初始容量将可以避免自动在散列的开销==。</li></ul><h4 id="Collection或Map的同步控制"><a href="#Collection或Map的同步控制" class="headerlink" title="Collection或Map的同步控制"></a>Collection或Map的同步控制</h4><ul><li><p>Collections类有办法能够自动同步整个容器。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; tSet = Collections.synchronizedSet(<span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; mm = Collections.synchronizedMap(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面直接将新生成的容器传递给了适当的“同步”方法；这样做就不会有任何机会暴露出不同步的版本。</p></li></ul><h5 id="快速报错"><a href="#快速报错" class="headerlink" title="快速报错"></a>快速报错</h5><ul><li><p><strong>Java</strong>容器有一个==保护机制==，==能够防止多个进程同时修改同一个容器的内容。如果在你迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或者修改此容器内的某个对象==，那么就会出现问题。Java容器类类库采用==快速报错(<strong>fail-fast</strong>)机制==。它会探查容器上的任何除了你的进程所进行的操作外的所有变化，一旦它发现其它进程修改了容器，就会立即抛出==<strong>ConcurrentModificationException</strong>==异常。</p></li><li><p>“快速报错”机制的工作原理：只需要创建一个迭代器，然后向迭代器所指向的<strong>Collection</strong>添加点什么，如下：</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFast</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        c.add(<span class="string">"An Object"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = it.next();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>程序运行时发生了异常，因为在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。此例中，应该在添加完所有的元素之后，再获取迭代器。</p></li><li><p><strong>ConcurrentHashMap</strong>,<strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>都使用了可以避免<strong>ConcurrentModificationException</strong>的技术。</p></li></ul><h3 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h3><ul><li><strong>java.lang.ref</strong>类库包含了一组类，这些类为==垃圾回收提供了更大的灵活性==。==当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。==有三个继承自抽象类<strong>Reference</strong>的类：<strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>。当垃圾回收器正在考察的对象只能通过某个<strong>Reference</strong>对象才“==可获得==”时，上述这些不同的派生类==为垃圾回收器提供了不同级别的间接性指示==。</li><li>对象是可获得的(reachable)，是指此对象可在程序中的某处找到。这意味着你在栈中有一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对象含有另一个引用指向正在讨论的对象；也可能有更多的中间链接。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序将无法使用到它，所以将其回收是安全的。</li><li>如果想继续持有对某个对象的引用，希望后续还能够访问到该对象，但是也希望能够允许垃圾回收器释放它，这时就应该使用<strong>Reference</strong>对象。这样，你可以继续使用该对象，而在内存消耗殆尽的时候又允许释放该对象。</li><li>以<strong>Reference</strong>对象作为你和普通引用之间的媒介(代理)，另外，一定不能有普通的引用指向那个对象，这样就能达到上述目的。(普通的引用指没有经<strong>Reference</strong>对象包装过的引用)。如果垃圾回收器发现某个对象通过普通引用可获得的，该对象就不会被释放。</li><li><strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>由强到弱排列，对应不同的级别的“可获得性”。<strong>Softreference</strong>用以实现内存敏感的告诉缓存。<strong>WeakReference</strong>是为实现“规范映射”而设计的，它不妨碍垃圾回收器回收映射的“键”(或“值”)。“规范映射”中的实例可以在程序的多处被同时使用，以节省存储空间。<strong>PhantomReference</strong>用以调度回收前的清理工作，它比Java终止机制更灵活。</li><li>使用<strong>SoftReference</strong>和<strong>WeakReference</strong>时，可以选择是否要将它们放入<strong>ReferenceQueue</strong>(用作“回收前清理工作”的工具)。而<strong>PhantomReference</strong>只能依赖于<strong>ReferenceQueue</strong>。</li></ul><h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><ul><li><p>容器类中有一种特殊的<strong>Map</strong>，即<strong>WeakHashMap</strong>,它被用来保存<strong>WeakReference</strong>。在这种映射中，每个值只保存一份实例以节省存储空间。当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它(而不是重新在创建)。映射可将值作为其初始化中的一部分，不过通常是在需要的时候才生成“值”。</p></li><li><p>==这是一种节约存储空间的技术，因为<strong>WeakHashMap</strong>允许垃圾回收器自动清理键和值。允许清理元素的触发条件是，不再需要此键了。==</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        ident = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Element</span><br><span class="line">                &amp;&amp; ident.equals(((Element) o).ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span> + getClass().getSimpleName() + <span class="string">" "</span> + ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            Key[] keys = <span class="keyword">new</span> Key[size];</span><br><span class="line">            WeakHashMap&lt;Key,Value&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Key k = <span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">                Value v = <span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    keys[i] = k;</span><br><span class="line">                    map.put(k,v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行此程序，会看到垃圾回收器每隔三个键就跳过一个，因为指向那个键的普通引用被存入了<strong>keys</strong>数组，所以那些对象不能被垃圾回收器回收。</p></li></ul><h3 id="Java-1-0-1-1的容器"><a href="#Java-1-0-1-1的容器" class="headerlink" title="Java 1.0/1.1的容器"></a>Java 1.0/1.1的容器</h3><h4 id="Vector和Enumeration"><a href="#Vector和Enumeration" class="headerlink" title="Vector和Enumeration"></a>Vector和Enumeration</h4><ul><li>在<strong>Java 1.0/1.1</strong>中，<strong>Vector</strong>是==唯一可以自我扩展的序列==。基本上，可以将其看作是<strong>ArrayList</strong>。但是具有有长有难记的方法名，在订正过的<strong>Java</strong>容器类类库中，<strong>Vector</strong>被改造过，可将其归类为<strong>Collection</strong>和<strong>List</strong>。</li><li><strong>Java 1.0/1.1</strong>版的迭代器发明了一个新的名字—<strong>枚举</strong>，取代了为人熟知的术语(<strong>迭代</strong>器)。此<strong>Enumeration</strong>接口比<strong>Iterator</strong>小，只有两个名字很长的方法：</li></ul><table><thead><tr><th>方法</th><th>概述</th></tr></thead><tbody><tr><td>boolean hasMoreElements()</td><td>如果此枚举包含更多的元素，该方法就返回true</td></tr><tr><td>Object nextElement()</td><td>该方法返回此枚举中的下一个元素(如果还有的话)，否则抛出异常。</td></tr></tbody></table><ul><li><strong>Enumeration</strong>只是接口而不是实现，所以有时新的类库仍然使用了旧的<strong>Enumeration</strong>。虽然在你的代码中应该尽量使用<strong>Iterator</strong>，但也得有准备，类库可能会返回给你一个<strong>Enumeration</strong>。</li></ul><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul><li><strong>Java 1.0/1.1</strong>的<strong>Stack</strong>很奇怪，竟然不是用<strong>Vector</strong>来构建<strong>Stack</strong>，而是继承<strong>Vector</strong>。所以它拥有<strong>Vector</strong>所有的特点和行为，再加上一些额外的<strong>Stack</strong>行为。(很难理解设计者是否意识到这样做特别有用处，或者只是一个幼稚的设计，但是你永远都不应该使用它)</li></ul><h4 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h4><ul><li>如果想要高效地存储大量“开/关”信息，<strong>BitSet</strong>是很好的选择。不过它的效率仅是对空间而言；如果想要高效的访问时间，<strong>BitSet</strong>比本地数组稍慢一点。</li><li><strong>BitSet</strong>的最小容量是<strong>long</strong>：<strong>64</strong>位。如果要存储的内容比较小，那么<strong>BitSet</strong>就浪费了一些空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第十七章-容器深入研究&quot;&gt;&lt;a href=&quot;#第十七章-容器深入研究&quot; class=&quot;headerlink&quot; title=&quot;第十七章 容器深入研究&quot;&gt;&lt;/a&gt;第十七章 容器深入研究&lt;/h2&gt;&lt;h3 id=&quot;完整的容器分类法&quot;&gt;&lt;a href=&quot;#完整的容器分类法&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想第二章</title>
    <link href="http://yoursite.com/2019/11/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/11/17/java编程思想第二章/</id>
    <published>2019-11-17T12:46:59.000Z</published>
    <updated>2019-11-17T13:32:05.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java编程思想总结"><a href="#java编程思想总结" class="headerlink" title="java编程思想总结"></a>java编程思想总结</h1><h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章:一切都是对象"></a>第二章:一切都是对象</h2><h3 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1. 用引用操作对象"></a>1. 用引用操作对象</h3><ul><li><h5 id="在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference"><a href="#在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference" class="headerlink" title="在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)"></a>在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)</h5></li><li><p>你拥有一个引用,并不一定需要一个对象与他关联.(String s;)</p></li></ul><h3 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2. 必须由你创建所有对象"></a>2. 必须由你创建所有对象</h3><ul><li>一旦创建一个引用,就希望他能与一个新的对象产生关联,通常用==new==来实现这一目的,new的意思是给我一个新对象</li></ul><h3 id="3-存储到什么地方"><a href="#3-存储到什么地方" class="headerlink" title="3.存储到什么地方"></a>3.存储到什么地方</h3><ul><li>寄存器:这是最快的存储区,位于不同于其他存储区的位置——-处理器内部,但是寄存器数量极其有限,所以寄存器根据需求进行分配,不能直接控制.</li><li>堆栈:位于通用RAM(随机访问存储器),通过堆栈指针可以从处理器哪里获得直接支持,堆栈指针若向下移动,则分配新内存,若向上移动,则释放哪些内存,这是一种快速有效的存储方式,仅次于寄存器,创建程序时,java必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针,java对象的引用存储在堆栈,但是java对象并不存储于其中.</li><li>堆:一种通用的内存池(位于ram区)用于存放java对象,不同于堆栈的好处是:编译器不需要知道存储的数据在堆里能存活多长时间,因此,在堆里分配存储有很大的灵活性,当我们在new一个对象的时候,会自动地在堆里进行存储分配,当然,为这种灵活性必须付出代价,用堆进行存储分配和清理可能会比用堆栈进行存储分配需要更多时间.</li><li>常量存储:常量值通常直接存放在程序代码内部,这样做是安全的,因为他们永远不会被改变.</li><li>非RAM存储:如果数据完全存活于程序之外,那么他可以不受程序的任何控制,在程序没有运行时也可以存在,两个最基本的例子就是”流对象”,”持久化对象”,在”流对象”中,对象转换成字节流,通常被发送给另一台机器,在”持久化对象”中,对象被存放在磁盘上.</li></ul><h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><ul><li><p>在程序中经常用到一系列类型,他们需要被特殊对待,可以把他们想象成”基本”类型,之所以被特殊对待,是因为==<strong>new将对象存储在”堆”里</strong>==,故用new创建一个对象,特别是小的简单的变量,不是很有效,对于这些类型,我们不用new来创建变量,而是创建一个并非是引用的”自动”变量,这个变量直接存储”值”并置放于堆栈中,效率更高.</p></li><li><p>java要确定每种基本类型所占存储空间的大小,他们的大小不像其他语言那样随机器硬件架构的变化而变化,正是这种原因使得java程序更具有可移植性.</p><table><thead><tr><th align="left">基本类型</th><th align="left">大小</th><th align="left">最小值</th><th align="left">最大值</th><th align="left">包装器类型</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">——–</td><td align="left">——–</td><td align="left">——–</td><td align="left">Boolean</td></tr><tr><td align="left">char</td><td align="left">16 bit</td><td align="left">Unicode 0</td><td align="left">Unicode 0</td><td align="left">Character</td></tr><tr><td align="left">byte</td><td align="left">8 bit</td><td align="left">-128</td><td align="left">127</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">16 bit</td><td align="left">$-2^{15}$</td><td align="left">$2^{15}-1$</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">32 bit</td><td align="left">$-2^{31}$</td><td align="left">$2^{31}-1$</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">64 bit</td><td align="left">$-2^{63}$</td><td align="left">$2^{63}-1$</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">32 bit</td><td align="left">IEEE754</td><td align="left">IEEE754</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">64 bit</td><td align="left">IEEE754</td><td align="left">IEEE754</td><td align="left">Double</td></tr><tr><td align="left">void</td><td align="left">——–</td><td align="left">——–</td><td align="left">——–</td><td align="left">Void</td></tr></tbody></table></li><li><p>高精度数字</p><ul><li>java提供了用于高精度计算的类:<strong>BigInteger</strong>(整数)和<strong>BigDecimal</strong>(小数)(用于精确的货币计算)</li></ul></li></ul><h3 id="5-永远不需要销毁对象"><a href="#5-永远不需要销毁对象" class="headerlink" title="5.永远不需要销毁对象"></a>5.永远不需要销毁对象</h3><ul><li><p>作用域(scope)</p><ul><li>作用域决定了在其内部定义的变量名的可见性和生命周期,作用域由花括号的位置决定.</li></ul></li><li><p>对象的作用域</p><ul><li>java有一个垃圾回收器,用于监视用new创建的所有对象,并辨别那些不会在被引用的对象,随后,释放这些对象的内存空间,以便供其他新的对象使用.</li></ul></li><li><p>默认成员类型</p><ul><li><p>若类的某个成员是基本数据类型,即使没有初始化,java也会确保它获得一个默认值,前提必须是作为<strong>成员变量</strong>使用.</p><table><thead><tr><th>基本类型</th><th>默认值</th></tr></thead><tbody><tr><td>boolean</td><td>f</td></tr><tr><td>char</td><td>‘\u0000’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常运行输出0</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果作为局部变量,会报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/11/17/java编程思想第二章/1559358469727-1573995008036.png" alt="1559358469727"></p><h3 id="6-static"><a href="#6-static" class="headerlink" title="6.static"></a>6.static</h3><ol><li>优势<ul><li>只想为某特定域分配单一存储空间,而不去考虑究竟要创建多少对象,甚至根本不用创建对象.</li><li>希望某个方法不与包含他的类的任何对象关联在一起,也就是说,即使没有创建对象,也能够调用这个方法.</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java编程思想总结&quot;&gt;&lt;a href=&quot;#java编程思想总结&quot; class=&quot;headerlink&quot; title=&quot;java编程思想总结&quot;&gt;&lt;/a&gt;java编程思想总结&lt;/h1&gt;&lt;h2 id=&quot;第二章-一切都是对象&quot;&gt;&lt;a href=&quot;#第二章-一切都是对象&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="java编程思想" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/java/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java编程思想" scheme="http://yoursite.com/tags/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud快速入门</title>
    <link href="http://yoursite.com/2019/07/20/Spring-Cloud%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/07/20/Spring-Cloud快速入门/</id>
    <published>2019-07-20T10:14:02.000Z</published>
    <updated>2019-07-21T12:21:13.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><ul><li>Spring Cloud是一系列框架的有序集合。它利用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767" target="_blank" rel="noopener">Spring Boot</a>的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。(<a href="https://baike.baidu.com/item/spring%20cloud/20269825?fr=aladdin" target="_blank" rel="noopener">引自百度百科</a>)</li></ul><h2 id="Spring-Cloud与单体架构"><a href="#Spring-Cloud与单体架构" class="headerlink" title="Spring Cloud与单体架构"></a>Spring Cloud与单体架构</h2><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><ul><li>在微服务的概念形成之前，绝大多数的Web的应用都是使用单体建构进行构建的，在单体架构中，应用程序作为单个可部署的软件制品交付，所有的UI，业务，数据库访问逻辑都被打包在一个应用程序制品中并部署在一个应用程序服务器上面。</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190721112755.jpg" alt="微信图片_20190721112755"></p><ul><li><p>单体架构存在的问题：</p><ul><li>随着业务的发展，开发变得越来越复杂，</li><li>每当各个团队修改代码的时候，整个应用程序都需要<code>重新构建，重新测试及重新部署等。</code></li><li>一旦一个模块出现问题，整个系统就有可能…….</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/20180522084756_mmmla.jpeg" alt="20180522084756_mmmla"></p></li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>![](Spring-Cloud快速入门/spring cloud架构图.png)</p><ul><li>微服务技术，是对技术上和组织上扩大大型单体应用程序所面临的诸多挑战的直接回应。</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/%E4%BD%A0%E8%BF%87%E6%9D%A5%E5%91%80-1563680562356.webp" alt="你过来呀"></p><ul><li>微服务架构是一个小的，松耦合的分布式服务。</li><li>微服务允许将一个大型的应用分解为具有严格职责定义的便于管理的组件。</li><li>微服务通过将大型的代码分解为小型的精准定义的部分，已解决大型代码库中传统的复杂问题。</li><li>微服务的一大核心就是：分解和分离应用程序的功能，使他们完全彼此独立。如下</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/cloud.jpg" alt="cloud"></p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>各个服务的开发，测试，部署等都相互独立，开发之间不需要依赖其他服务。</li><li>构建在微服务之上的应用程序能够使用多种编程语言和技术进行构建。</li><li>一个微服务可以跨多个应用程序复用。</li><li>微服务利用其小，独立和分布式的性质，使组织拥有明确责任领域的小型开发团队。</li></ul><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>微服务的拆分是基于业务的，不是我们想怎么拆就怎么拆，给团队协作，沟通带来了挑战。</li><li>由于各个服务之间是互相独立的，数据也是独立的，当调用多个服务接口来进行操作时，如何保证各个服务之间的数据一致性。</li></ul><h2 id="主流微服务框架简单对比"><a href="#主流微服务框架简单对比" class="headerlink" title="主流微服务框架简单对比"></a>主流微服务框架简单对比</h2><table><thead><tr><th>RPC框架</th><th>dubbo</th><th>motan</th><th>thrift</th><th>grpc</th><th>spring cloud</th></tr></thead><tbody><tr><td>支持语言</td><td>java</td><td>java</td><td>跨语言</td><td>跨语言</td><td>java</td></tr><tr><td>服务治理</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>多注册中心</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>序列化方式</td><td>hessian2/lite/json/kryo</td><td>hessian2/json</td><td>thrift/json</td><td>protobuf</td><td>java/kryo</td></tr><tr><td>跨语言通讯</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td></tr></tbody></table><h2 id="微服务首要考虑因素"><a href="#微服务首要考虑因素" class="headerlink" title="微服务首要考虑因素"></a>微服务首要考虑因素</h2><p><img src="/2019/07/20/Spring-Cloud快速入门/1563696525028.png" alt="1563696525028"></p><h4 id="大小适当"><a href="#大小适当" class="headerlink" title="大小适当"></a>大小适当</h4><ul><li>如何确保正确的划分微服务的大小，可以避免微服务承担太多的职责，适当的大小允许快速的更改应用程序，降低整个应用程序中断的总体风险。</li></ul><h4 id="位置透明"><a href="#位置透明" class="headerlink" title="位置透明"></a>位置透明</h4><ul><li>在微服务应用中，多个服务实例可以快速的启动和关闭时，如何管理服务调用的物理细节。</li></ul><h4 id="有弹性"><a href="#有弹性" class="headerlink" title="有弹性"></a>有弹性</h4><ul><li>如何通过绕过失败的服务，确保采取“快速失败”的方法来保护微服务消费者和应用程序的整体完整性。</li></ul><h4 id="可重复"><a href="#可重复" class="headerlink" title="可重复"></a>可重复</h4><ul><li>如何确保提供的每个新服务实例与生产环境中的所有其他服务实例具有相同的配置和代码库。</li></ul><h4 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h4><ul><li>如何使用异步处理和事件来最小化服务之间的直接依赖关系，并确保可以优雅地扩展代码库。</li></ul><h2 id="微服务模式"><a href="#微服务模式" class="headerlink" title="微服务模式"></a>微服务模式</h2><h4 id="核心微服务开发模式"><a href="#核心微服务开发模式" class="headerlink" title="核心微服务开发模式"></a>核心微服务开发模式</h4><ul><li>核心微服务开发模式解决了构建微服务的基础问题。</li></ul><h4 id="微服务路由模式"><a href="#微服务路由模式" class="headerlink" title="微服务路由模式"></a>微服务路由模式</h4><ul><li>路由模式负责处理处理希望微服务的客户端应用程序，使客户端应用程序发现服务的位置并路由到服务。</li></ul><h4 id="微服务客户端弹性模式"><a href="#微服务客户端弹性模式" class="headerlink" title="微服务客户端弹性模式"></a>微服务客户端弹性模式</h4><ul><li>因为微服务架构是高度分布的，所以必须对如何防止单个服务中的问题级联暴露给服务的消费者十分敏感。常用的有4种客户端弹性模式：客户端负载均衡，断路器模式，后备模式和舱壁模式。</li></ul><h4 id="微服务安全模式"><a href="#微服务安全模式" class="headerlink" title="微服务安全模式"></a>微服务安全模式</h4><ul><li>常用的3种基本的安全模式：验证，授权和凭据管理和传播</li></ul><h4 id="微服务日志记录和跟踪模式"><a href="#微服务日志记录和跟踪模式" class="headerlink" title="微服务日志记录和跟踪模式"></a>微服务日志记录和跟踪模式</h4><ul><li>微服务的优点是单体应用程序被分解为可以彼此独立部署的小的功能部件，而它的缺点是调试和跟踪应用程序和服务中发生的事情要困难的多。</li><li>常用的3种核心日志记录和跟踪模式：日志关联，日志聚合和微服务跟踪。</li></ul><h4 id="微服务构建和部署模式"><a href="#微服务构建和部署模式" class="headerlink" title="微服务构建和部署模式"></a>微服务构建和部署模式</h4><ul><li>微服务架构的核心原则之一是，微服务的每个实例都应该和其他所有实例相同。</li></ul><h2 id="Spring-Cloud各模块入门"><a href="#Spring-Cloud各模块入门" class="headerlink" title="Spring Cloud各模块入门"></a>Spring Cloud各模块入门</h2><h4 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Spring-Cloud&quot;&gt;&lt;a href=&quot;#什么是Spring-Cloud&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring Cloud&quot;&gt;&lt;/a&gt;什么是Spring Cloud&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring Cloud
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化及补充</title>
    <link href="http://yoursite.com/2019/07/19/SQL%E4%BC%98%E5%8C%96%E5%8F%8A%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/07/19/SQL优化及补充/</id>
    <published>2019-07-19T07:18:15.000Z</published>
    <updated>2019-07-20T14:09:44.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建，查询，更新和删除数据，不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能，现在许多不同的数据库管理系统都支持不同的数据引擎，存储引擎主要有<ol><li>MyIsam</li><li>InnoDB</li><li>Memory</li><li>Archive</li><li>Federated</li></ol></li></ul><h4 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB(B+树)"></a>InnoDB(B+树)</h4><ul><li>InnoDB底层结构为B+树，B树的每个节点对应的InnoDB的一个page，page大小是固定的，一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563521705026.png" alt="1563521705026"></p><ul><li>适用场景<ul><li>经常更新的表，适合处理多重并发的更新请求。</li><li>支持事务。</li><li>可以从灾难中恢复(通过bin-log日志等)。</li><li>外键约束，只有他支持外键。</li><li>支持自动增加列属性auto_increment。</li></ul></li></ul><h4 id="TokuDB-Fractal-Tree节点带数据"><a href="#TokuDB-Fractal-Tree节点带数据" class="headerlink" title="TokuDB(Fractal Tree节点带数据)"></a>TokuDB(Fractal Tree节点带数据)</h4><ul><li>TokuDB底层存储结构为<code>Fractal Tree</code>,与B+树有些类似，在Fractal Tree中，<strong>每一个child指针除了需要指向一个child节点外，还会带有一个Message Buffer，这个Message Buffer是一个FIFO的队列，用来缓存更新操作。</strong></li><li>如，一次插入操作只需要落在某节点的<code>Message Buffer</code>就可以马上返回了，并不需要搜索到叶子节点，这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</li><li>完全支持事务ACID</li><li>TokuDB在线添加索引，不影响读写操作，非常快的写入性能，Fractal-tree在事务实现上有优势，它主要适用于访问频率不高的数据或历史数据归档。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563522531352.png" alt="1563522531352"></p><h4 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h4><ul><li>MySQL默认的引擎，但是它没有对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整张表，效率会低一些。</li><li>MyIsam执行读取操作的速度很快，而且不占用大量的内存和存储资源，在设计之初就预想数据组织成有固定长度的记录，按顺序存储的，MyIsam是一种静态的索引结构。缺点是不支持事务。</li></ul><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul><li>Memory(也叫做HEAP)堆内存:使用存在内存中的内容来创建表，每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。MEMORY同时支持散列表索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</li></ul><h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul><li>只支持insert和select操作(支持行级锁和缓冲区，可以提高实现高并发的插入)</li><li>只允许在自增ID列上加索引。</li><li>Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。当数据量非常大的时候Archive的插入性能表现会较MyISAM为佳。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>索引(index)是帮助MySQL高效获取数据的数据结构，常见的查询算法，顺序查找，二分查找，二叉树排序查找，哈希散列法，分块查找，平衡多路搜索树B树。</li></ul><h4 id="优缺点及特点"><a href="#优缺点及特点" class="headerlink" title="优缺点及特点"></a>优缺点及特点</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>可以加快数据库的检索速度</li><li>降低数据库插入，修改，删除等维护的速度</li><li>只能创建在表上，不能创建到视图上。</li><li>既可以直接创建又可以间接创建。</li><li>可以在优化隐藏中使用索引。</li><li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引。</li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>创建唯一性索引，保证数据表中每一行数据的唯一性。</li><li>大大加快数据的检索速度，这是创建索引的最主要原因。</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加，删除和修改的时候，索引也需要维护，降低数据维护的速度。</li></ol><h4 id="常见的索引原则"><a href="#常见的索引原则" class="headerlink" title="常见的索引原则"></a>常见的索引原则</h4><ol><li><strong>选择唯一性索引</strong>:唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录。</li><li><strong>为经常需要排序，分组和联合操作的字段建立索引</strong>。</li><li><strong>为常作为查询条件的字段建立索引。</strong></li><li><strong>限制索引的数目</strong>：越多的索引，会使更新表变得很浪费时间。</li><li><strong>尽量使用数据量少的索引</strong>：如果索引的值很长，那查询的速度会收到影响。</li><li><strong>尽量使用前缀来索引</strong>：如果索引字段的值很长，最好使用值的前缀来索引。</li><li><strong>删除不再使用或很少使用的前缀。</strong></li><li><strong>最左前缀匹配原则，非常重要的原则。</strong></li><li><strong>尽量选择区分度高的列作为索引</strong>：区分度的公式是表示字段不重复的比例。</li><li><strong>索引列不能参与计算，保持列“干净”，带函数的查询不参与索引。</strong></li><li><strong>尽量的扩展索引，不要新建索引。</strong></li></ol><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li><strong>组合索引</strong>：实质上是将多个字段建到一个索引里，列指的组合必须唯一。</li><li><strong>聚集索引</strong>：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</li><li><strong>非聚集索引</strong>：唯一索引，普通索引，主键索引，全文索引。</li><li><strong>UNIQUE(唯一索引)</strong>：不可以出现相同的值，可以有NULL值。</li><li><strong>INDEX(普通索引)</strong>：允许出现相同的索引内容。</li><li><strong>PROMARY KEY(主键索引)</strong>：不允许出现相同的值。</li><li><strong>fulltext index(全文索引)</strong>：可以针对值中的某个单词，但效率呵呵。</li></ol><h4 id="MySQL如何为表字段添加索引"><a href="#MySQL如何为表字段添加索引" class="headerlink" title="MySQL如何为表字段添加索引"></a>MySQL如何为表字段添加索引</h4><ol><li>添加PRIMARY KEY(主键索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add primary key (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li>添加UNIQUE(唯一索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add unique (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="3"><li>添加INDEX(普通索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add index indexname (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="4"><li>添加FULLTEXT(全文索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tablename add fulltext (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>添加多列索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; addd indexname (&apos;column1&apos;,&apos;column2&apos;,&apos;column3&apos;)</span><br></pre></td></tr></table></figure><h2 id="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"><a href="#当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施" class="headerlink" title="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"></a>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施</h2><h4 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h4><ul><li>务必禁止不带任何限制数据范围条件的查询语句，比如：在查询订单历史时，我们可以控制在一个月的范围内。</li></ul><h4 id="读-写分离"><a href="#读-写分离" class="headerlink" title="读/写分离"></a>读/写分离</h4><ul><li>数据库拆分，主库负责写，从库负责读。</li></ul><h4 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h4><ul><li><strong>根据数据库中的数据表的相关性进行拆分</strong>，如：用户表中既有用户的登录信息又有用户的基本信息，可以把用户表拆成两张表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张表列比较多的表拆分为多张表。如下</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563531655922.png" alt="1563531655922"></p><ul><li><strong>垂直拆分优点</strong>：可以使行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区让事务变得更加复杂。</li></ul><h4 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h4><ul><li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的，水平拆分可以支撑非常大的数据量。</strong>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表数据拆成多张表来存放。如：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成的影响。</li><li>水平拆分可以支持非常大的数据量，需要注意的是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。<strong>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决</strong>，跨界点Join性能较差，逻辑复杂。</li><li><strong>尽量不要对数据进行分片，以为拆分会带来逻辑，部署，运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片的架构，这样可以减少一次和中间件的网络I/O。</li></ul><h4 id="数据库分片常见方案"><a href="#数据库分片常见方案" class="headerlink" title="数据库分片常见方案"></a>数据库分片常见方案</h4><ul><li><strong>客户端代理，分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现</strong>。当当网的ShardingJDBC,阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：在应用和数据中间加了一个代理层，分片逻辑统一维护在中间件服务中</strong>。Mycat，360的Atlas，网易的DDB等等都是这种架构实现的。</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol><li>对查询进行优化，应尽量避免全表扫面，首先应考虑在<code>where</code>及<code>order by</code>涉及的列上建立索引。</li><li>索引并不是越多越好，会降低维护的效率。</li><li><code>in</code>和<code>not in</code>要慎用。</li><li>避免在字段上进行计算操作。</li><li>临时表也可以用，要记得显式的删除。</li><li>避免频繁的创建删除数据表。</li><li>拆分大的<code>insert</code> <code>update</code>操作，提高并发性能。</li><li><strong>避免在<code>where</code>子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</li><li>避免在<code>where</code>子句中对字段进行<code>null</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>避免在<code>where</code>子句中使用<code>or</code>来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>………………………………</li></ol><h2 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h2><ol><li>SQL语句以及索引的优化。</li><li>数据库表结构的优化。</li><li><strong>数字类型</strong>：非万不得已不要使用DOUBLE。</li><li><strong>字符类型</strong>：非万不得已不要使用TEXT数据类型。</li><li><strong>时间类型</strong>：尽量使用<code>TIMESTAMP</code>类型，因为其存储空间只需要<code>DATETIME</code>类型的一半，对于只需要精确到某一天的数据类型，建议使用<code>DATE</code>类型，因为他们的存储空间只需要3个字节，比<code>TIMESTAMP</code>还少。</li><li>数据库引擎选择，对于<code>select</code>执行比较多的操作，很少插入删除更新的表使用<code>MyIsam</code>引擎。</li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><ul><li>事务是逻辑上的一组操作，要么都执行，要么都不执行</li></ul><h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><ul><li>事务的最小执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用。</li></ul><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><ul><li>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><ul><li>并发访问数据库时，一个用户的事务不被其他的事务所干扰，各并发之间数据库是独立的。</li></ul><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><ul><li>一个事务被提交后。它对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><ul><li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是”脏数据“，依据”脏数据“所作的操作可能是不正确的。</li></ul><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><ul><li>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为”丢失修改“。如：事务1读取表中的数据为A=20，事务2也读取为A=20，事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19，事务1的修改丢失。</li></ul><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><ul><li>指在一个事务内多次读同一个数据，在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li></ul><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><ul><li>幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称之为幻读。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a>READ-UNCOMMITTED(读未提交)</h5><ul><li>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读，幻读或不可重复读。</strong></li></ul><h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)"></a>READ-COMMITTED(读已提交)</h5><ul><li>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。</strong></li></ul><h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)"></a>REPEATABLE-READ(可重复读)</h5><ul><li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li></ul><h5 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h5><ul><li>最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读，不可重复读以及幻读。</strong></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">数据库默认隔离级别</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">o</td><td align="center">o</td><td align="center">o</td><td align="center"></td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">x</td><td align="center">o</td><td align="center">o</td><td align="center">oracle/SQL server</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">x</td><td align="center">x</td><td align="center">o</td><td align="center">MySQL</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center"></td></tr></tbody></table><h2 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h2><ul><li>并发控制一般采用三种方法：<strong>乐观锁</strong>，<strong>悲观锁</strong>和<strong>时间戳</strong>。</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul><li>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul><li>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</li></ul><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><ul><li>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</li></ul><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul><li>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：<ul><li><code>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE  [OF columns][WAIT n | NOWAIT]</code>;</li><li><code>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</code></li><li><code>使用 COMMIT 或 ROLLBACK 语句释放锁</code></li></ul></li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul><li>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</li></ul><h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><ul><li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</li></ul><h2 id="基于Redis分布式锁"><a href="#基于Redis分布式锁" class="headerlink" title="基于Redis分布式锁"></a>基于Redis分布式锁</h2><ul><li>获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁</li><li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>分库分表有<strong>垂直切分</strong>和<strong>水平切分</strong>两种</li></ul><h4 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分(按照功能模块)"></a>垂直切分(按照功能模块)</h4><ul><li>将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563525859253.png" alt="1563525859253"></p><h4 id="水平切分-按照规划划分存储"><a href="#水平切分-按照规划划分存储" class="headerlink" title="水平切分(按照规划划分存储)"></a>水平切分(按照规划划分存储)</h4><ul><li>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563525903133.png" alt="1563525903133"></p><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><h4 id="柔性事务-1"><a href="#柔性事务-1" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul><li>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</li><li>通常所说的柔性事务分别为：<strong>两阶段型</strong>，<strong>补偿型</strong>，<strong>异步确保型</strong>，<strong>最大努力通知型</strong>几种。</li></ul><h5 id="两阶段型："><a href="#两阶段型：" class="headerlink" title="两阶段型："></a>两阶段型：</h5><ul><li>就是分布式事务两阶段提交，对应技术上的XA，JTA/JTS。这是分布式环境下事务处理的典型模式。</li></ul><h5 id="补偿型："><a href="#补偿型：" class="headerlink" title="补偿型："></a>补偿型：</h5><ul><li>TCC型事务(Try/Confirm/Cancel)可以归为补偿型。</li><li>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563526421770.png" alt="1563526421770"></p><h5 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h5><ul><li>通过将一系列同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563526497943.png" alt="1563526497943"></p><h5 id="最大努力通知型-多次尝试"><a href="#最大努力通知型-多次尝试" class="headerlink" title="最大努力通知型(多次尝试)"></a>最大努力通知型(多次尝试)</h5><ul><li>这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <strong>允许在达到最大重试次数之后正常结束事务。</strong></li></ul><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability<br>（可用性）、Partition tolerance（分区容错性），三者不可得兼。</li></ul><h4 id="一致性-C"><a href="#一致性-C" class="headerlink" title="一致性(C)"></a>一致性(C)</h4><ul><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值(等同于所有节点访问同一份最新的数据副本)</li></ul><h4 id="可用性-A"><a href="#可用性-A" class="headerlink" title="可用性(A)"></a>可用性(A)</h4><ul><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</li></ul><h4 id="分区容忍性-P"><a href="#分区容忍性-P" class="headerlink" title="分区容忍性(P)"></a>分区容忍性(P)</h4><ul><li>以实际效果而言，分区相当于对通信的时限要求，系统如果不能在1时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://yoursite.com/2019/07/19/%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/07/19/网络/</id>
    <published>2019-07-19T05:55:15.000Z</published>
    <updated>2019-07-20T14:10:49.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络7层协议"><a href="#网络7层协议" class="headerlink" title="网络7层协议"></a>网络7层协议</h2><ol><li><strong>物理层</strong>：主要定义物理设备标准，如：网线，光纤接口类型，各种传输介质的传输速率等。它主要作用是传输比特流(就是由1.0转换为电流强弱来进行传输，到达目的地后在转换为1，0，也就是我们常说的<strong>模数转换与数据转换</strong>)。这一层的数据叫做比特。</li><li><strong>数据链路层</strong>：主要将从物理层接受的数据进行<strong>MAC地址(网卡的地址)的封装与解封装</strong>。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</li><li><strong>网络层</strong>：主要将从下一层接收到的数据<strong>进行IP地址的封装与解封装</strong>，在这一层工作的设备是<strong>路由器</strong>，常把这一层的数据叫做数据包。</li><li><strong>传输层</strong>：定义了一些<strong>传输数据的协议和端口号</strong>(WWW端口80等)，如<strong>TCP</strong>(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，<strong>UDP</strong>(用户数据报协议，与TCP特性相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将从下层接收的数据进行传输，到达目的地后再进行重组。常常把这一层数据叫做段。</li><li><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)<strong>建立数据传输的通路</strong>，主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li><strong>表示层</strong>：主要是进行对接收的数据进行<strong>解释，加密与解密，压缩与解压缩等</strong>（也就是把计算机能够识别的东西转换成人能够识别的东西，如：图片，声音等）。</li><li><strong>应用层</strong>：主要是一些终端的应用，比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（简单说就是我们可以在电脑屏幕上看见的东西，就属于终端）。</li></ol><p><img src="/2019/07/19/网络/timg.jpg" alt="timg"></p><h2 id="TCP-IP原理"><a href="#TCP-IP原理" class="headerlink" title="TCP/IP原理"></a>TCP/IP原理</h2><ul><li><p><strong>TCP/IP协议不是TCP和IP这两个协议的合称</strong>，而是指因特网整个TCP/IP协议族，从协议分层模型方面讲，TCP/IP由四个层次组成：<strong>网络接口层</strong>，<strong>网络层</strong>，<strong>传输层</strong>，<strong>应用层</strong>。</p><p><img src="/2019/07/19/网络/timg.jpg%E7%9A%84%E5%A4%A7%E8%8B%8F%E6%89%93.jpg" alt="timg.jpg的大苏打"></p></li></ul><h4 id="网络访问层"><a href="#网络访问层" class="headerlink" title="网络访问层"></a>网络访问层</h4><ul><li>有时也称作数据链路层或网络接口层，在TCP/IP参考模型中并没有详细描述，<strong>只是指出主机必须使用某种协议与网络相连</strong>。</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>是整个体系结构中的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立的转向目标，这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同，高层如果需要顺序收发，那么就必须自行处理对分组的排序。<strong>互联网层使用因特网协议（IP）</strong>。</li></ul><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul><li>传输层使源端和目的端机器上的对等实体可以进行会话，<strong>在这一层定义了两个端到端的协议</strong>：传输控制协议（TCP，UDP）<strong>TCP是面向连接的协议</strong>，它提供可靠的报文传输和对上层应用的连接服务，为此，除了基本的数据传输外，它还有可靠性保证，流量控制，多路复用，优先权和安全性控制等功能。<strong>UDP是面向无连接的不可靠传输的协议</strong>，主要用于步需要TCP的排序和流量控制等功能的应用程序。</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>应用层包含所有的高层协议，包括：<strong>虚拟终端协议（Telnet）,文件传输协议（FTP），电子邮件协议（SMTP）,域名服务（DNS），超文本传输协议（HTTP）等。</strong></li></ul><h2 id="TCP三次握手-四次挥手"><a href="#TCP三次握手-四次挥手" class="headerlink" title="TCP三次握手/四次挥手"></a>TCP三次握手/四次挥手</h2><ul><li>TCP在传输之前会进行三次沟通，一般称之为“三次握手”，传输完数据断开的时候要进行四次沟通，一般称之为“四次挥手”。</li></ul><h4 id="数据包简要概述"><a href="#数据包简要概述" class="headerlink" title="数据包简要概述"></a>数据包简要概述</h4><ol><li><strong>源端口号</strong>（16位）：它（连同源主机IP地址）标识源主机的一个应用进程。</li><li><strong>目的端口号</strong>（16位）：它（连同目的主机IP地址）标识目的主机的一个应用进程，<strong>这两个值加上IP报头中的源主机IP地址和目的主机IP地址确定唯一一个TCP连接</strong>。</li><li><strong>顺序号</strong>（32位）：<strong>用来标识从TCP源端向TCP目的端发送的数据字节流，他表示在这个报文段中的第一个数据字节的顺序号</strong>。如果将字节流看作在两个应用程序讲的单行流动，<strong>则TCP用顺序号对应每个字节进行计数</strong>。序号是32bit的无符号数，<strong>序号到达$$2^{32}-1$$后又从0开始，当建立一个新的连接时，SYN标志变1</strong>，顺序号字段包含由这个主板选择的该连接的初始顺序号ISN（Initial Sequence Number）。</li><li><strong>确认号ack</strong>（32位）：<strong>包含发送确认的一端所期望收到的下一个顺序号</strong>，因此，确认序号应当是上次已成功收到数据字节顺序号加1，<strong>只有ACK标志为1时确认序号字段才有效</strong>。TCP为应用层提供全双工服务，这意味着能在两个方向上独立地进行传输。因此，连接的每一端必须保证每个方向上的传输数据顺序号。</li><li><strong>TCP报头长度</strong>（4位）：给出报头中32bit字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部，然而，没有任选字段，正常的长度是20字节。</li><li><strong>保留数</strong>（6位）：保留给将来使用，目前必须置为0。</li><li><strong>控制位</strong>（6位）：在TCP报头中有6个标志比特，它们中有多个可同时被设置为1。依次为：<ol><li>URG：为1标识紧急指针有效，为0则忽略紧急指针值。</li><li>ACK：为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。</li><li>PSH：为1表示是带有PUSH标志的数据，<strong>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</strong></li><li>RST：<strong>用于复位由于主机崩溃或其他原因而出现错误的连接</strong>，它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个RST为1的报文，那么一定发生了某些问题。</li><li>SYN：同步序号，<strong>为1表示连接请求</strong>，用于建立连接和使顺序号同步。</li><li>FIN：<strong>用于释放连接</strong>，为1表示发送方已经没有数据发送了，即关闭本方数据流。</li></ol></li><li><strong>窗口大小</strong>（16位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。</li><li><strong>校验和</strong>（16位）：此校验和是对整个的TCP报文段，<strong>包括TCP头部和TCP数据，以16位字进行计算所得</strong>，这是一个强制性的字段，一定是由发送端计算和存储，<strong>并由接收端进行验证</strong>。</li><li><strong>紧急指针</strong>（16位）：只有当URG标志置位1时紧急指针才有效。<strong>TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</strong></li><li><strong>选项</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size）。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项，<strong>它指明本端所能接收的最大长度的报文段</strong>。选项长度不一定是32位字的整数倍，所以要加填充位，使得报头长度成为整字数。</li><li><strong>数据</strong>：TCP报文段中的数据部分是可选的，在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首段，如果一方没有数据要发送，也使用没有任何数据的首段来确认收到的数据，在处理超时的许多情况中，也会发送不带任何数据的报文段。</li></ol><p><img src="/2019/07/19/网络/1563431855650.png" alt="1563431855650"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>第一次握手：主机A发送位码为<code>syn=1</code>，随机产生<code>seq number=1234567</code>的数据包到服务器，主机B由SYN=1知道，A要求建立联机。</li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=<code>(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包</code>。</li><li>第三次握手：<code>主机A收到后检查ack number是否正确</code>，即第一次发送的seq number+1，以及位码ack是否为1，若正确，<code>主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功</code>。</li></ul><p><img src="/2019/07/19/网络/1563432346818.png" alt="1563432346818"></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>TCP建立连接要进行三次握手，而断开连接要进行四次，这是由于TCP的半关闭造成的。因为TCP连接是全双工的（即数据可在两个方向上同时传递）所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫做半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。</li><li>第一次挥手：关闭客户端到服务器的连接，首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认，其中终值标志位FIN=1，序列号seq=u。</li><li>第二次挥手：服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。</li><li>第三次挥手：关闭服务器到客户端的连接：也是发送一个FIN给客户端。</li><li>第四次挥手：客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li><li>主机A发送FIN后，进入终止等待状态，服务器B收到主机A连接释放报文段后，就立即给主机A发送确定，然后服务器B就进入<code>close-wait</code>状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。此时。若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入<code>time-wait</code>，注意，此时TCP连接还没有释放掉，然后经过时间等待计数器设置的2MSL后，A才进入到close状态。</li></ul><p><img src="/2019/07/19/网络/1563435685702.png" alt="1563435685702"></p><h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p><img src="/2019/07/19/网络/1563454607638.png" alt="1563454607638"></p><h4 id="对应的协议不同"><a href="#对应的协议不同" class="headerlink" title="对应的协议不同"></a>对应的协议不同</h4><h6 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h6><ol><li><strong>FTP</strong>：定义了文件传输协议，使用<code>21端口</code>。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li><li><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是纯字符界面的，<code>支持BBS的服务器将23端口打开，对外提供服务</code>。</li><li><strong>SMTP</strong>：定义了简单邮件传输协议，现在很多邮件服务器都用的是这个协议，用于邮件发送。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有SMTP端口设置，<code>服务器开放的是25端口</code>。</li><li><strong>POP3</strong>：和SMTP对应，POP3用于接收邮件。通常情况下，<code>POP3协议所用的是110端口</code>。也就是说，只要你有相应的使用POP3协议的程序，就可以不以Web方式登录进邮箱页面，直接用邮件程序就可以收到邮件。</li><li><strong>HTTP协议</strong>：是从Web服务器传输超文本到本地浏览器的传输协议。</li></ol><h6 id="UDP对应的协议"><a href="#UDP对应的协议" class="headerlink" title="UDP对应的协议"></a>UDP对应的协议</h6><ol><li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。<code>DNS用的是53端口</code>。</li><li><strong>SNMP</strong>：简单的网络协议，<code>使用161端口</code>，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li><strong>TFTP</strong>：简单文件传输协议，该协议在<code>端口69上使用UDP服务</code>。<h2 id="TCP如何保证可靠性传递"><a href="#TCP如何保证可靠性传递" class="headerlink" title="TCP如何保证可靠性传递"></a>TCP如何保证可靠性传递</h2></li></ol><ul><li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并不给出响应，这是TCP发送数据端超时后会重发数据。</li><li><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。</li><li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据。</li><li><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。</li><li><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h2 id="TCP流量控制-拥塞控制"><a href="#TCP流量控制-拥塞控制" class="headerlink" title="TCP流量控制/拥塞控制"></a>TCP流量控制/拥塞控制</h2><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul><li><strong>原因</strong>：如果发送方把数据发送的过快，接收方可能来不及接收，这就会造成数据的丢失。</li><li><strong>原理</strong>：是利用滑动窗口实现的，接收方告诉发送方自己的接收窗口大小，然后发送方发送窗口不能超过接收方给出的接收窗口值。</li></ul><h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><ul><li>发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。</li><li>慢开始的算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li><li>这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下：</li></ul><p><img src="/2019/07/19/网络/1563459696361.png" alt="1563459696361"></p><ul><li>上图中，发送方每收到一个确认就cwnd+1，也就是说发送发发送2就收到2个，所以就是cwnd就是4，也就是翻倍成长的道理，每次都是翻倍，也就是指数增长。为了防止cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。用法如下：<ul><li>当cwnd &lt; ssthresh时，使用慢开始算法。</li><li>当cwnd &gt; ssthresh时，改用拥塞避免算法。</li><li>当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</li></ul></li></ul><h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul><li>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到1确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判断，所以都当作拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法，如下：</li></ul><p><img src="/2019/07/19/网络/1563463668758.png" alt="1563463668758"></p><h4 id="快速重传快速恢复"><a href="#快速重传快速恢复" class="headerlink" title="快速重传快速恢复"></a>快速重传快速恢复</h4><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为了使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，如下</li></ul><p><img src="/2019/07/19/网络/1563503812096.png" alt></p><ul><li><p>快重传配合使用的还有快速恢复算法，有两个特点：</p><ul><li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 <code>ssthresh</code>门限减半。但是接下去并不执行慢开始算法。</p></li><li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将<code>cwnd 设置为 ssthresh</code>的大小，然后执行拥塞避免算法。如下</p><p><img src="/2019/07/19/网络/1563504121286.png" alt></p></li></ul></li></ul><h2 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h2><p><img src="/2019/07/19/网络/1563508119629.png" alt="1563508119629"></p><ol><li><p><strong>CLOSED</strong>：起始点，在超时或者连接关闭时进入此状态。</p></li><li><p><strong>LISTEN</strong>：svr端在等待连接过来时候的状态，svr端为此要调用<code>socket，bind，listen函数</code>，就能进入此状态。此称为应用程序被动打开(等待客户端来连接)。</p></li><li><p><strong>STN_SENT</strong>：客户端发起连接，发送SYN给服务器端。如果服务器端不能连接，则直接进入<code>CLOSED状态</code>。</p></li><li><p><strong>SYN_RCVD</strong>：跟3对应，服务器端接收客户端的<code>SYN请求</code>，服务器端由<code>LISTEN状态进入SYN_RCVD状态</code>。同时<code>服务器端要回应一个ACK</code>，<code>同时发送一个SYN给客户端</code>；另外一种情况，<code>客户端在发起SYN的同时接收到服务器端的SYN请求，客户端就会由SYN_SENT到SYN_RCVD状态</code>。</p></li><li><p><strong>ESTABLISHED</strong>：服务器和客户端在完成3次握手后进入状态，说明已经可以开始传输数据了。</p></li><li><p><strong>FIN_WAIT_1</strong>：主动关闭的一方，由状态5进入此状态，具体的动作时发送FIN给对方。</p></li><li><p><strong>FIN_WAIT_2</strong>：主动关闭的一方，接收到对方的<code>FIN ACK</code>，进入此状态。由此不能再接收对方的数据，但是能够向对方发送数据。</p></li><li><p><strong>CLOSE_WAIT</strong>：接收到<code>FIN</code>以后，被动关闭的一方进入此状态，具体动作时接收到<code>FIN</code>，同时发送<code>ACK</code>。</p></li><li><p><strong>LAST_ACK</strong>：被动关闭的一方，发起关闭请求，由状态8进入此状态。具体动作时发送FIN给对方，<code>同时在接收到ACK时进入CLOSED状态</code>。</p></li><li><p><strong>CLOSING</strong>：两边同时发起关闭请求时，会由<code>FIN_WAIT_1</code>进入此状态。<code>具体动作是，接收到FIN请求，同时响应一个ACK</code>。</p></li><li><p><strong>TIME_WAIT</strong>：从图中可以看到，有三个状态可以转化为此状态</p><p>   a.<code>由FIN_WAIT_2进入此状态</code>：在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态。</p><p>   b. <code>由CLOSING状态进入</code>：双方同时发起关闭，都做了发起FIN的请求1，同时接收到了FIN并做了ACK的情况下，由CLOSINT状态进入。</p><p>   c. <code>由FIN_WAIT_1状态进入</code>：同时接收到FIN（对方发起），ACK（本身发起的FIN回应），与b的区别在于本身发起的FIN回应的ACK先于对方的FIN请求到达，而b是FIN先到达。这种国情况概率最小。</p></li></ol><h4 id="当一个tcp监听了80端口后，udp还能否监听80端口"><a href="#当一个tcp监听了80端口后，udp还能否监听80端口" class="headerlink" title="当一个tcp监听了80端口后，udp还能否监听80端口"></a>当一个tcp监听了80端口后，udp还能否监听80端口</h4><ul><li>：由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个 255 号端口，UDP 也可以有一个 255 号端口，二者并不冲突。</li></ul><h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><ul><li>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。</li></ul><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><ul><li>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。</li></ul><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><ul><li><p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成：发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。</p><ul><li>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。</li><li>p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。</li><li>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</li></ul><p><img src="/2019/07/19/网络/1563507810510.png" alt="1563507810510"></p></li></ul><h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><ul><li>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。</li><li>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</li></ul><p><img src="/2019/07/19/网络/1563507862436.png" alt="1563507862436"></p><h4 id="连续ARQ的注意事项"><a href="#连续ARQ的注意事项" class="headerlink" title="连续ARQ的注意事项"></a>连续ARQ的注意事项</h4><ul><li>同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</li><li>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。</li><li>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h4 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h4><ul><li>关于 SYN Flood 攻击。一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫tcp_syncookies 的参数来应对这个事——当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，请先千万别用 tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li></ul><h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ul><li>DDoS 攻击是 Distributed Denial of Service 的缩写，即不法黑客组织通过控制服务器等资源，发动对包括国家骨干网络、重要网络设施、政企或个人网站在内的互联网上任一目标的攻击，致使目标服务器断网，最终停止提供服务。</li><li>预防:1.高防服务器 主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等 2.DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。3.CDN加速 在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</li></ul><h4 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h4><ul><li>DNS 欺骗就是攻击者冒充 域名服务器 的一种欺骗行为。</li><li>预防：<ul><li>1.使用入侵检测系统 </li><li>2.使用 DNSSEC</li></ul></li></ul><h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><ul><li>重放攻击又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。</li><li>预防：<ul><li>1.加随机数 </li><li>2.加时间戳</li></ul></li></ul><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><ul><li><p>所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。</p></li><li><p>预防：</p><ul><li><p>1.加密处理 将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令。</p></li><li><p>2.确保数据库安全 只给访问数据库的 web 应用功能所需的最低的权限，撤销不必要的公共许可 。</p></li><li><p>3.输入验证 检查用户输入的合法性，确信输入的内容只包含合法的数据。数据检查应当在客户端和服务器端都执行之所以要执行服务器端验证，是为了弥补客户端验证机制脆弱的安全性。</p></li></ul></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>HTTP是一个无状态协议。无状态是指客户端(Web浏览器)和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务端发出请求，然后服务器返回响应（response），连接就被关闭了，再服务器端不保留连接的有关信息。HTTP遵循请求（Requset）/应答（Response）模型。客户机（浏览器）向服务器发送请求。服务器处理请求并返回适当的应答。所有HTTP连接都被构成一套请求和响应。</li></ul><h4 id="http请求报文与响应报文"><a href="#http请求报文与响应报文" class="headerlink" title="http请求报文与响应报文"></a>http请求报文与响应报文</h4><ul><li><strong>http请求报文</strong><ul><li>HTTP请求报文由请求行，请求头，空行和请求数据4部分组成。</li><li>请求行：(get/post方法，url中的path路径，http版本)</li><li>请求头（header）关键字/值对组成。</li><li>请求数据（body）：http响应报文由状态行，响应头部，空行，响应数据组成。</li></ul></li><li><strong>http响应报文</strong><ul><li>HTTP响应由四个部分组成：<ul><li>状态码（Status Code）：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码<code>HttpServletResponse.SC_OK</code>。</li><li>HTTP头部（HTTP Header）：它们包含了更多的关于相应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。</li><li>空行</li><li>主体（Body）：包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</li></ul></li></ul></li></ul><h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h4><ol><li><strong>地址解析</strong></li></ol><ul><li>如用客户端请求页面:<code>http://localhost:8080/index.html</code>从中分解出协议名，主机名，端口，对象路径等部分。对于这个地址解析后如下：<ul><li>协议名：<code>http</code></li><li>主机名：<code>localhost</code></li><li>端口：<code>8080</code></li><li>对象路径：<code>/index.html</code></li></ul></li><li>在这一步，需要域名系统DNS解析域名得到主机的IP地址。</li></ul><ol start="2"><li><strong>封装HTTP请求数据包</strong></li></ol><ul><li>把上面的部分结合本机自己的信息，封装成一个HTTP请求数据包。</li></ul><ol start="3"><li><strong>封装成TCP包并建立连接</strong></li></ol><ul><li>封装成TCP包，建立TCP连接(TCP的三次握手)</li></ul><ol start="4"><li><strong>客户机发送请求命令</strong></li></ol><ul><li>客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)，协议版本号，后面是MIME信息包括请求修饰符，客户机信息和内容。</li></ul><ol start="5"><li><strong>服务器响应</strong></li></ol><ul><li>服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号，一个成功或错误的代码，后面是MIME信息包括服务器信息，实体信息和可能的内容。</li></ul><ol start="6"><li><strong>服务器关闭TCP连接</strong></li></ol><ul><li>服务器关闭TCP连接，一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<code>Connection:keep-alive</code>,TCP连接在发送后任然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ul><p><img src="/2019/07/19/网络/1563437731001.png" alt="1563437731001"></p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li><p>HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443。过程大致如下：</p><ol><li><p><strong>建立连接获取证书</strong></p><ol><li>SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其他一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）。</li></ol></li><li><p><strong>证书验证</strong></p><ol><li>Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li></ol></li><li><p><strong>数据加密和传输</strong></p><ol><li>如果确认证书有效，那么生成对称密钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li></ol><p><img src="/2019/07/19/网络/1563438724225.png" alt="1563438724225"></p></li></ol></li></ul><h4 id="SSL工作原理"><a href="#SSL工作原理" class="headerlink" title="SSL工作原理"></a>SSL工作原理</h4><ul><li><p><strong>RSA握手协议</strong></p><ul><li>Client 给出协议版本号、一个客户端生成的随机数（Client random），<br>以及客户端支持的加密方法。</li><li>Server 确认双方使用的加密方法，并给出数字证书、以及一个服务器<br>生成的随机数（Server random）。</li><li>Client 确认数字证书有效，然后生成一个新的随机数（Premaster secr<br>et），并使用数字证书中的公钥，加密这个随机数，发给 Server。</li><li>Server 使用自己的私钥，获取 Client 发来的随机数（即 Premaster se<br>cret）。</li><li>Client 和 Server 根据约定的加密方法，使用前面的三个随机数，生成” 对话密钥”（session key），用来加密接下来的整个对话过程。</li></ul></li><li><p><strong>记录协议</strong></p><ul><li>记录协议 对数据传输提供保密性和完整性。</li><li>记录协议过程。</li></ul><p><img src="/2019/07/19/网络/InkedSnipaste_2019-07-19_13-45-11_LI.jpg" alt="InkedSnipaste_2019-07-19_13-45-11_LI"></p></li><li><p><strong>警报协议</strong></p><ul><li>如果是警告，则值为1，如果是致命错误，则值为2。</li></ul></li></ul><h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><table><thead><tr><th>方法</th><th>描述</th><th>HTTP版本</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td><td>1.0</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（如：提交表单或上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有的资源的修改。</td><td>1.0</td></tr><tr><td>HEAD</td><td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td><td>1.0</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td><td>1.1</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td><td>1.1</td></tr><tr><td>PATCH</td><td>是对PUT方法的补充，用来对已知资源进行局部更新</td><td>1.1</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的信息</td><td>1.1</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td><td>1.1</td></tr><tr><td>CONNECT</td><td>HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td><td>1.1</td></tr></tbody></table><h4 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h4><ul><li>GET被强制服务器支持</li><li>浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li><li>GET请求发送的数据更小(IE2048/firefox65536/chrome8182/opera190000字符)</li><li>GET请求是不安全的</li><li>GET请求是幂等的</li><li>POST请求不能被缓存</li><li>POST请求相对于GET请求是安全的</li><li>以下情况，请使用POST请求<ul><li>无法使用缓存文件(更新服务器上的文件或数据库)</li><li>向服务器发送大量数据(POST没有数据量限制)</li><li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li></ul></li><li>GET使用URL或Cookie传参。而POST将数据放在Body中。GET的URL会有长度上的限制，则POST的数据则可以非常大。POST比GET安全，因为数据在地址栏上不可见。</li><li>幂等<ul><li>从定义上看，HTTP方法的幂等性是指一次或多次请求某一个资源应该具有相同的副作用。</li><li>POST并不是幂等的。</li></ul></li></ul><h4 id="Http长连接-短连接"><a href="#Http长连接-短连接" class="headerlink" title="Http长连接/短连接"></a>Http长连接/短连接</h4><ul><li><strong>无状态</strong>：HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议(无连接)。</li><li><strong>长连接</strong>：从HTTP1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<code>Keep-Alive</code>不会永久保持连接，他有一个保持时间，可以在不同的服务器软件(如：Apache)中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li><li><strong>短链接</strong>：在HTTP1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问某个HTML或其他类型的web页中包含有其他的web资源(如:js，图像，css等)，每遇到这样一个web资源，浏览器就会重新建立一个HTTP会话。</li><li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</li></ul><h4 id="什么时候用长连接，短连接"><a href="#什么时候用长连接，短连接" class="headerlink" title="什么时候用长连接，短连接"></a>什么时候用长连接，短连接</h4><ul><li><strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况下</strong>。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。</li><li>短连接一般用于web网站的http服务，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。</li></ul><h4 id="http1-1和1-0的区别"><a href="#http1-1和1-0的区别" class="headerlink" title="http1.1和1.0的区别"></a>http1.1和1.0的区别</h4><ul><li>1.0需要<code>keep-alive</code>参数来告知服务器要建立一个长连接，而1.1默认支持长连接。</li><li>1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401时候，客户端就可以不用发送请求body了，节约了带宽。</li><li>host域，1.0没有host域，1.1才开始支持</li><li>带宽优化及网络连接的使用，1.0中，存在一些浪费带宽的现象，如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，1.1则在请求头引入<code>range头域</code>，它允许只请求资源的某个部分，即返回码是206，这样方便了开发者自由的选择以便充分利用带宽和连接。</li></ul><h4 id="http2-0和1-0的区别"><a href="#http2-0和1-0的区别" class="headerlink" title="http2.0和1.0的区别"></a>http2.0和1.0的区别</h4><ul><li><strong>新的二进制</strong>(Binary Format):Http1.x的解析是基于文本的。基于文本协议的格式解析存在缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑Http2.0的协议解析决定采用二进制形式，实现方便且健壮。</li><li><strong>多路复用</strong>(MultiPlexing):即连接共享，建立起一个连接请求后，可以在这个链接上一直发送，不要等待上一次发送完并且收到回复后才能发送下一个(Http1.0是这样的)，是可以同时发送多个请求，互相并不干扰。</li><li><strong>header压缩</strong>:Http1.x的header带有大量信息，而且每次都要重复发送，Http2.0利用了<code>Hpack</code>对消息进行压缩传输，客户端和服务器维护一个动态链表(当一个头部没有出现的时候，就插入，已经出现了就用表中的索引值进行代替)，避免了重复header的传输，又减少了需要传输的大小。</li><li><strong>服务端推送</strong>(server push):就是客户端请求html的时候，服务器顺带把此html需要的css,js也一起发送给客户端，而不像1.0中需要请求一次html，然后再请求一次css，然后再请求一次js。</li></ul><h4 id="http与https区别"><a href="#http与https区别" class="headerlink" title="http与https区别"></a>http与https区别</h4><ul><li>https 协议需要申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl加密传输协议</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li><li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。<ul><li>HTTP 的 URL 以 http:// 开头 ，而 HTTPS 的 URL 以 https://<br>开头</li><li>HTTP 是不安全的，而 HTTPS 是安全的</li><li>在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层</li><li>HTTP 无需加密，而 HTTPS 对传输的数据进行加密</li><li>HTTP 无需证书，而 HTTPS 需要认证证书</li></ul></li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ul><li>CDN一般包含<strong>分发服务系统，负载均衡系统和管理系统</strong>。</li></ul><p><img src="/2019/07/19/网络/CDN%E6%9E%B6%E6%9E%84.jpg" alt="CDN架构"></p><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul><li>其基本工作单元就是各个<code>Cache</code>服务器。负责直接响应用户请求，将内容快速分发到用户；同时负责内容更新，保证和源站内容的同步。</li><li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务，流媒体加速服务，应用加速服务等。每个子服务系统都是分布式的服务集群，由功能类似，地域接近的分布部署的<code>Cache</code>集群组成。</li><li>在承担内容同步，更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个<code>Cache</code>设备的健康状况，响应情况，内容缓存状况等，以便管理调度系统能够根据设定的策略决定由那个<code>Cache</code>设备来响应用户的请求。</li></ul><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul><li>负载均衡系统是整个CDN系统的中枢，负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li><li>使用分级实现，最基本的两级调度体系包括全局负载均衡(GSLB)和本地负载均衡(SLB)。</li><li>GSLB根据用户地址和用户请求的内容，<strong>主要根据就近性原则，确定向用户服务的节点。一般通过DNS解析或者应用层重定向(HTTP 3XX重定向)的方式实现。</strong></li><li>SLB主要负责节点内部的负载均衡。当用户请求从GSLB调度到SLB时，SLB会根据节点内各个Cache设备的工作状况和内容分布情况等对用户请求重定向。<strong>SLB的实现有四层调度（LVS），七层调度（Nginx）和链路负载调度等。</strong></li></ul><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul><li>分为运营管理和网络管理子系统。</li><li>网络管理系统实现对CDN系统的设备管理，拓扑管理，链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用web方式实现。</li><li>运营管理是对CDN系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集，整理，交付工作。<strong>包括用户管理，产品管理，计费管理，统计分析等。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络7层协议&quot;&gt;&lt;a href=&quot;#网络7层协议&quot; class=&quot;headerlink&quot; title=&quot;网络7层协议&quot;&gt;&lt;/a&gt;网络7层协议&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;物理层&lt;/strong&gt;：主要定义物理设备标准，如：网线，光纤接口类型，各种传输
      
    
    </summary>
    
      <category term="HTTP/TCP/IP" scheme="http://yoursite.com/categories/HTTP-TCP-IP/"/>
    
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
      <category term="tcp/ip" scheme="http://yoursite.com/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>Java并发补充</title>
    <link href="http://yoursite.com/2019/07/16/Java%E5%B9%B6%E5%8F%91%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/07/16/Java并发补充/</id>
    <published>2019-07-16T08:10:17.000Z</published>
    <updated>2019-07-20T14:08:17.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul><li><p>线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行，他的主要特点为：<strong>线程复用，控制最大并发数，管理线程</strong>。</p></li><li><p><strong>线程复用</strong></p><ul><li>每一个Thread的类都有一个start()方法，当调用start()启动线程时Java虚拟机会调用该类的run()方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。<strong>我们可以继承重写Thread类，在其start()方法中添加不断循环调用传递过来的Runnable对象</strong>。这就是线程池的实现原理。<strong>循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的</strong>。</li></ul></li><li><p><strong>线程池的组成</strong></p><ul><li>一般的线程池主要分为4个组成部分<ul><li>线程池管理器：用于创建并管理线程池。</li><li>工作线程：线程池中的线程。</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行。</li><li>任务队列：用于存放处理的任务，提供一种缓冲机制。</li></ul></li><li>Java中的线程池1是通过Executor实现的。</li></ul><p><img src="/2019/07/16/Java并发补充/1563331336349.png" alt="1563331336349"></p><ul><li><code>ThreadPoolExecutor</code>中的构造方法<ul><li><code>corePoolSize</code>：指定了线程池中的线程数量。</li><li><code>maximumPoolSize</code>:指定了线程池中的最大线程数量。</li><li><code>keepAliveTime</code>：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li><code>utnit</code>:keepAliveTime的单位。</li><li><code>workQueue</code>:任务队列，被提交但尚未被执行的任务。</li><li><code>threadFactory</code>:线程工厂，用于创建线程，一般使用默认值。</li><li><code>handler</code>:拒绝策略，当任务太多来不及处理，如何拒绝任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="keyword">this</span>(corePoolSize,maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>拒绝策略</strong></p><ul><li>线程池中的线程已经用完，无法继续为新任务服务，同时，等待队列也已经排满，再也塞不下新的任务，这时我们就需要拒绝策略机制合理的处理这个问题。</li><li>JDK内置的拒绝策略如下：<ul><li><code>AbortPolicy</code>:直接抛出异常，阻止系统正常运行。</li><li><code>CallerRunsPolicy</code>:只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li><code>DiscardOldestPolicy</code>:丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li><code>DiscardPolicy</code>:该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，这是最好的一种方案。</li><li>上述内置拒绝策略实现了<code>RejectedExecutionHandler</code>接口，若以上策略仍无法满足实际需要，完全可以自己扩展<code>RejectedExecutionHandler</code>接口。</li></ul></li></ul></li><li><p><strong>线程池工作过程</strong></p><ol><li>线程池刚创建时，里面没有一个线程，任务队列是作为参数传递进来的，不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个任务时，线程池会做以下判断：<ol><li>如果正在运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行这个队列。</li><li>如果正在运行的线程数大于或等于<code>corePoolSize</code>,那么将这个任务放入队列。</li><li>如果这时队列满了，而且正在运行的线程数小于<code>maximumPoolSize</code>，那么还要创建非核心线程立即运行这个任务。</li><li>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>,那么线程池会抛出异常<code>RejectExecutionException</code>。</li></ol></li><li>当一个线程完成任务时，他会从队列中取出下一个任务来执行。</li><li>当一个线程无事可做时，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li></ol></li></ul><h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><ul><li><p>在阻塞队列中，线程阻塞分为两种情况。</p><ul><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。</li></ul><p><img src="/2019/07/16/Java并发补充/1563336228088.png" alt="1563336228088"></p><ul><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。</li></ul><p><img src="/2019/07/16/Java并发补充/1563336249697.png" alt="1563336249697"></p></li></ul><h4 id="阻塞队列主要方法"><a href="#阻塞队列主要方法" class="headerlink" title="阻塞队列主要方法"></a>阻塞队列主要方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：抛出一个异常。</li><li>特殊值：返回一个特殊值(null或false，视情况而定)。</li><li>阻塞：在成功操作之前，一直阻塞线程。</li><li>超时：放弃前只在最大的时间内阻塞。</li></ul><ul><li><p><strong>插入操作</strong></p><ul><li><code>public abstract boolean add(E paramE)</code>:将指定元素插入到此队列中(如果立即可行且不会违反容量限制)，成功时返回true,如果当前没有可用的空间，则抛出<code>IllegalStateException</code>.如果该元素是NULL，则会抛出<code>NullPointerException</code>异常。</li><li><code>public abstract boolean offer(E paramE)</code>:将指定元素插入此队列中(如果立即可行且不会违反容量限制)，成功时返回<code>true</code>，如果当前没有可用的空间，则返回<code>false</code>。</li><li><code>public abstract void put(E paramE) throws InterruptedException</code>:将指定元素插入到此队列中，将等待可用的空间(如果有必要)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> checkNotNull(paramE);</span><br><span class="line"> ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;</span><br><span class="line"> localReentrantLock.lockInterruptibly();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length)</span><br><span class="line">     <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">     enqueue(paramE);</span><br><span class="line">         localReentrantLock.unlock();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> localReentrantLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>offer(E o,long timeout,TimeUnit unit)</code>:可以设定等待时间，如果在指定的时间内，还不能往队列中加入<code>BlockingQueue</code>,则返回失败。</li></ul></li><li><p><strong>获取数据操作</strong></p><ul><li><code>poll(time)</code>取出<code>BlockingQueue</code>里面排在首位的对象，若不能立即取出，则可以等待time参数规定的时间，取不到时返回<code>null</code>。</li><li><code>poll(long timeout,TimeUnit unit)</code>:从<code>BlockingQueue</code>取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，返回失败。</li><li><code>take()</code>:取出<code>BlockingQueue</code>里排在首位的对象，若<code>BlockingQueue</code>为空，阻断进入等待状态直到<code>BlockintQueue</code>有新的数据被加入。</li><li><code>drainTo()</code>:一次性从<code>BlockingQueue</code>获取所有可用的数据对象(还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率，不需要多次分批加锁或释放锁。</li></ul></li></ul><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul><li><code>ArrayBlockingQueue</code>:由数组结构组成的有界阻塞队列(公平，非公平)。<ul><li>用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序，<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平的访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素，通常情况下为了保证公平性会降低吞吐量，我们可以使用代码创建一个公平的阻塞队列<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true)；</code>。</li></ul></li><li><code>LinkedBlockingQueue</code>:由链表结构组成的有界阻塞队列(两个独立锁提高并发)。<ul><li>基于链表的阻塞队列，同<code>ArrayListBlockQueue</code>类似，此队列按照先进先出(FIFO)的原则对元素进行排序，而<code>LinkedBlockingQueue</code>之所以能高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<code>LinkedBlockingQueue会默认一个类似无限大小地容量(Integer.MAX_VALUE)</code>。</li></ul></li><li><code>PriorityBlockingQueue</code>:支持优先级排序的无界阻塞队列(compareTo排序实现优先)。<ul><li>是一个支持优先队列的无界队列，默认情况下元素采取自然顺序升序排列，可以自定义实现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序，需要注意的是不能保证同优先级元素的顺序。</li></ul></li><li><code>DelayQueue</code>:使用优先级队列实现的无界阻塞队列(缓存失效，定时任务)。<ul><li><strong>是一个支持延迟获取元素的无界阻塞队列</strong>，队列使用<code>PriorityQueue</code>来实现，队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素，我们可以将<code>DelayQueue</code>运用到如下场景<ul><li>缓存系统的设计，可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行。比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li></ul></li></ul></li><li><code>SynchronousQueue</code>:不存储元素的阻塞队列(不存储数据，可用于传递数据)。<ul><li><strong>是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素</strong>。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li></ul></li><li><code>LinkedTransferQueue</code>:由链表结构组成的无界阻塞队列。<ul><li>是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列，相对于其他阻塞队列，LinkedTransferQueue多了<code>tryTransfer()和transfer()</code>方法</li><li><strong>transfer()方法</strong>：如果当前有消费者正在等待接收元素(消费者使用take()方法或者带时间限制的poll()方法时)，<strong>transfer()方法可以把生产者传入的元素立即transfer给消费者.如果没有消费者在等待接收元素，transfer()方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</strong></li><li><strong>tryTransfer()方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者，如果没有消费者等待接收元素，则返回false。和<code>transfer()</code>的区别是<code>tryTransfer()</code>无论消费者是否接收，方法立即返回，而<code>transfer()</code>是必须等到消费者消费了才返回。</li><li>对于带有时间限制的<code>tryTransfer(E e,long timeout,TimeUnit unit)</code>方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li></ul></li><li><code>LinkedBlockingDeque</code>:由链表结构组成的双向阻塞队列。<ul><li>是一个由链表组成的<strong>双向阻塞队列</strong>。<strong>所谓的双向队列指的是你可以从队列的两端插入和移除元素</strong>。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst(),addLast(),offerFirst(),offerLast(),peekFirst(),peekLast()</code>等方法，以First结尾的方法，表示插入，获取或移除双端队列的第一个元素，以Last结尾的方法，表示插入，获取和移除双端队列的最后一个元素。另外插入方法add()等同于addLast(),移除方法remove()等同于removeFirst()。但是take()方法却等同于takeFirst()。</li><li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀，另外双向队列可以用在“工作窃取”模式中。</li></ul></li></ul><h2 id="CyclicBarrier-CountDownLatch和Semaphore的用法"><a href="#CyclicBarrier-CountDownLatch和Semaphore的用法" class="headerlink" title="CyclicBarrier,CountDownLatch和Semaphore的用法"></a>CyclicBarrier,CountDownLatch和Semaphore的用法</h2><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h4><ul><li><code>CountDownLatch</code>位于java.util.concurrent包下，使用它可以实现类似计数器的功能。如有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以利用CountDownLatch来实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"等待2个子线程执行完毕"</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)"></a>CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</h4><ul><li><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code>可以被重用，暂且把这个状态叫做barrier,当调用<code>await()</code>之后，线程就处于barrier。CyclicBarrier中最重要的方法就是<code>await()</code>,它有两个重载版本：</p><ol><li><code>public int await()</code>:用来挂起当前线程，直至所有线程都到达<strong>barrier状态</strong>再同时执行后续任务。</li><li><code>pubilc int await(long timeout,TimeUnit unit)</code>:让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><ul><li><p><strong>Semaphore可以控制同时访问的线程个数</strong>，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。</p></li><li><p>Semaphore常用的方法：</p><ol><li><code>public void acquire()</code>:用来获取一个许可，若无许可能够获取，则会一直等待，直到获得许可。</li><li><code>public void acquire(int permits)</code>:获取permits许可。</li><li><code>public void release()</code>:释放许可(在释放许可之前，必须先获得许可)。</li><li><code>public void release(int permits)</code>:释放permits个许可。</li></ol></li><li><p>上述4个方法都会被阻塞，如果想立即得到执行结果，可以使用下述方法。</p><ol><li><code>public boolean tryAcquire()</code>:尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li><li><code>public boolean tryAcquire(long timeout,TimeUnit unit)</code>:尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。</li><li><code>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)</code>:尝试获取permits个许可，若在指定的时间内获取成功，则返回true，否则返回false。</li><li><code>public boolean tryAcquire(int permits)</code>:尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li><li>还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完</span></span><br><span class="line"><span class="comment"> 了，其他工人才能继续使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，<strong>CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</strong></li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul><li><strong><em>newCachedThreadPool</em></strong><ul><li>创建一个可根据需要创建新线程的线程池，但是在以前已经构造的线程可用时将重用它们，对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能，调用<strong>execute</strong>将重用以前构造的线程(如果线程可用)，如果现有线程没有可用的，则创建一个新的线程并添加到线程池中，终止并从缓存中移除那些已有60秒未被使用的线程，因此，长时间保持空闲的线程池不会使用任何资源。</li></ul></li><li><strong>newFixedThreadPool</strong><ul><li>创建一个可重用固定线程数的线程池，以共享的无界队列来运行这些线程，在任意点，在大多数nThreads线程会处于处理任务的活动状态，如果在所有线程处于活动时提交附加任务，则在有可用线程之前，附加1任务将在队列中等待，如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个线程将代替它执行后续的任务(如果需要),在某个线程被显式地关闭之前，池中的线程将一直存在。</li></ul></li><li><strong>newScheduledThreadPool</strong><ul><li>创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。</li></ul></li><li><strong>newSingleThreadExecutor</strong><ul><li><strong>Executors.newSingleThreadExecutor()</strong>返回一个线程池(只有一个线程),这个线程池可以在线程死后(或发生异常)重新启动一个线程来代替原有的线程继续执行下去。</li></ul></li></ul><h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p><img src="/2019/07/16/Java并发补充/1563288982967.png" alt="1563288982967"></p><ul><li><strong>线程等待(wait)</strong><ul><li>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁，因此，wait()方法一般用在同步方法或同步代码块中。</li></ul></li><li><strong>线程睡眠(sleep)</strong><ul><li>sleep导致当前线程休眠，与wait不同的是sleep不会释放当前占用的锁，sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态。</li></ul></li><li><strong>线程让步(yield)</strong><ul><li>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片，一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li></ul></li><li><strong>线程中断(interrupt)</strong><ul><li>调用interrupt()方法并不会中断一个正在运行的线程，就是说处于Running状态的线程并不会因为被中止而被终止，仅仅改变了内部维护的中断标识位而已。</li><li>若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出<strong>InterruptedException</strong>,从而使线程提前结束TIMED-WATING状态。</li><li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li><li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</li></ul></li><li><strong>Join等待其他线程终止</strong><ul><li>join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待CPU的执行。</li></ul></li><li><strong>线程唤醒(notify)</strong><ul><li>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与该对象上主动同步的其他所有线程进行竞争，类似的方法还有notifyAll(),唤醒在此监视器上等待的所有线程。</li></ul></li><li><strong>其他常用方法</strong><ul><li><code>isAlive()</code>:判断一个线程是否存活。</li><li><code>activeCount()</code>:程序中活跃的线程数。</li><li><code>enumerate()</code>:枚举程序中的线程。</li><li><code>currentThread()</code>:得到当前线程。</li><li><code>isDaemon()</code>:一个线程是否为守护线程。</li><li><code>setDaemon()</code>:设置一个线程为守护线程。</li><li><code>setName()</code>:为线程设置名称。</li><li><code>setPriority()</code>:设置一个线程的优先级。</li><li><code>getPriority()</code>:获得一个线程的优先级。</li></ul></li></ul><h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><ul><li><strong>同步锁</strong><ul><li>当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种问题的出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据，Java中可已使用synchronized关键字来取得一个对象的同步锁。</li></ul></li><li><strong>死锁</strong><ul><li>就是多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。</li></ul></li></ul><h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><ul><li>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</li></ul><h4 id="变量可见性"><a href="#变量可见性" class="headerlink" title="变量可见性"></a>变量可见性</h4><ul><li>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</li></ul><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul><li>volatile禁止了指令重排。</li></ul><h4 id="比Synchronized更轻量级的同步锁"><a href="#比Synchronized更轻量级的同步锁" class="headerlink" title="比Synchronized更轻量级的同步锁"></a>比Synchronized更轻量级的同步锁</h4><ul><li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比Synchronized更轻量级的同步机制，volatile适合于这种场景：“<strong>一个变量被多个线程共享，线程直接给这个变量赋值</strong>”。</li><li>当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读写变量都从内存中读，跳过CPU cache这一步。</li></ul><p><img src="/2019/07/16/Java并发补充/1563354774642.png" alt="1563354774642"></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<ol><li>对变量的些操作不依赖于当前值(如i++)，或者说是单纯的1变量赋值(boolean flag = true)</li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用<code>volatile</code>。</li></ol></li></ul><h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><ul><li>进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性JVM解决了可见性和有序性的问题，而锁解决了原子性的问题，在理想的情况下我们希望做到“同步”和“互斥”，有以下的实现方式.</li></ul><h4 id="将数据抽象为一个类，并将数据的操作作为这个类的方法"><a href="#将数据抽象为一个类，并将数据的操作作为这个类的方法" class="headerlink" title="将数据抽象为一个类，并将数据的操作作为这个类的方法"></a>将数据抽象为一个类，并将数据的操作作为这个类的方法</h4><ul><li>将数据抽象为一个类，并将对这个数据的操作作为这个类的方法，这样可以很容易做到同步，只要在方法上加上<code>synchronized</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data= data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.dec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(add).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable对象作为一个类的内部类"><a href="#Runnable对象作为一个类的内部类" class="headerlink" title="Runnable对象作为一个类的内部类"></a>Runnable对象作为一个类的内部类</h4><ul><li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><ul><li>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</li></ul><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ol><li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</li><li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li><li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null</code>;</li></ol><p><img src="/2019/07/16/Java并发补充/1563357402171.png" alt="1563357402171"></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>最常用于解决数据库连接，Session管理等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">     Session s = (Session) threadSession.get(); </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">             s = getSessionFactory().openSession(); </span><br><span class="line">             threadSession.set(s); </span><br><span class="line">             &#125; </span><br><span class="line">     &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>都是用来协调多线程对共享对象，变量的访问。</li><li>都是可重入锁，同一线程可以多次获得同一个锁。</li><li>都保证了可见性和互斥性。</li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的<br>不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻<br>塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言<br>实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等</li></ol><h2 id="Volatile和Synchronized的区别"><a href="#Volatile和Synchronized的区别" class="headerlink" title="Volatile和Synchronized的区别"></a>Volatile和Synchronized的区别</h2><ol><li>volatile不会进行加锁操作。</li><li>volatile变量作用类似于同步变量读写操作。</li><li>volatile不如Synchronized安全。</li><li>volatile无法同时保证内存可见性和原子性。</li></ol><h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul><li>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li></ul><h4 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h4><ul><li>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</li><li>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</li></ul><h4 id="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><a href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成" class="headerlink" title="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"></a>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</h4><ul><li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li></ul><p><img src="/2019/07/16/Java并发补充/1563358149513.png" alt="1563358149513"></p><h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul><li>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</li></ul><h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><ul><li>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</li></ul><h4 id="JVM的线程调度实现-抢占式调度"><a href="#JVM的线程调度实现-抢占式调度" class="headerlink" title="JVM的线程调度实现(抢占式调度)"></a>JVM的线程调度实现(抢占式调度)</h4><ul><li>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</li></ul><h4 id="线程让出cpu的情况"><a href="#线程让出cpu的情况" class="headerlink" title="线程让出cpu的情况"></a>线程让出cpu的情况</h4><ol><li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li><li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li><li>当前运行线程结束，即运行完 run()方法里面的任务。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><ul><li><strong>先来先服务调度算法(FCDS)</strong><ul><li>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</li></ul></li><li><strong>短作业(进程)优先调度算法</strong><ul><li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</li></ul></li></ul><h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><ul><li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</li><li><strong>非抢占式优先权算法</strong><ul><li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li></ul></li><li><strong>抢占式优先权调度算法</strong><ul><li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li></ul></li><li><strong>高响应比优先调度算法</strong><ul><li>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</li></ul></li></ul><p><img src="/2019/07/16/Java并发补充/1563358860683.png" alt="1563358860683"></p><h4 id="基于时间片的轮询调度算法"><a href="#基于时间片的轮询调度算法" class="headerlink" title="基于时间片的轮询调度算法"></a>基于时间片的轮询调度算法</h4><ul><li><strong>时间片轮转法</strong><ul><li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</li></ul></li><li><strong>多级反馈队列调度算法</strong><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li></ol></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h4 id="概念特性"><a href="#概念特性" class="headerlink" title="概念特性"></a>概念特性</h4><ul><li>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</li><li>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</li></ul><h4 id="原子包java-util-concurrent-atomic-锁自旋"><a href="#原子包java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包java.util.concurrent.atomic(锁自旋)"></a>原子包java.util.concurrent.atomic(锁自旋)</h4><ul><li>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">        <span class="keyword">return</span> current; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul><li>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li><li>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li><li>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</li></ul><h2 id="什么是AQS-抽象的队列同步器"><a href="#什么是AQS-抽象的队列同步器" class="headerlink" title="什么是AQS(抽象的队列同步器)"></a>什么是AQS(抽象的队列同步器)</h2><ul><li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</li></ul><p><img src="/2019/07/16/Java并发补充/1563360810227.png" alt="1563360810227"></p><ul><li>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br><strong>getState()，setState()，compareAndSetState()</strong>。</li><li>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li></ol></li></ul><h4 id="AQS资源共享方式"><a href="#AQS资源共享方式" class="headerlink" title="AQS资源共享方式"></a>AQS资源共享方式</h4><ul><li><strong>Exclusive独占资源-ReentrantLock</strong><ul><li>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</li></ul></li><li><strong>Share 共享资源-Semaphore/CountDownLatch</strong><ul><li>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</li></ul></li></ul><h4 id="同步器的实现ABS核心-state资源状态计数"><a href="#同步器的实现ABS核心-state资源状态计数" class="headerlink" title="同步器的实现ABS核心(state资源状态计数)"></a>同步器的实现ABS核心(state资源状态计数)</h4><ul><li>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</li></ul><h4 id="ReentrantReadWriteLock实现独占和共享两种方式"><a href="#ReentrantReadWriteLock实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock实现独占和共享两种方式"></a>ReentrantReadWriteLock实现独占和共享两种方式</h4><ul><li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="-java -并发" scheme="http://yoursite.com/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Collection总结</title>
    <link href="http://yoursite.com/2019/07/15/Collection%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/15/Collection总结/</id>
    <published>2019-07-15T09:02:37.000Z</published>
    <updated>2019-07-20T14:07:39.842Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="集合架构图"></p><h2 id="图中大体概述"><a href="#图中大体概述" class="headerlink" title="图中大体概述"></a>图中大体概述</h2><ul><li>Iterator:可以通过迭代器遍历集合中的数据</li><li>Collection:是集合list,set,Queue的最基本的接口</li><li>Map：是映射表的基础接口</li></ul><h4 id="List接口详解"><a href="#List接口详解" class="headerlink" title="List接口详解"></a>List接口详解</h4><ul><li><p>List作为有序的Collection的代表，共有三个实现类，分别为<strong>ArrayList</strong>,<strong>LinkedList</strong>,<strong>Vector</strong>。</p></li><li><p><strong>ArrayList</strong></p><ul><li><p>内部是通过数组实现的，它允许对元素进行快速随机访问，缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中，当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制，移动，代价比较高，因此，它适合于随机查找与遍历，不适合插入和删除。</p><p><img src="/2019/07/15/Collection总结/1563183452932.png" alt="1563183452932"></p></li></ul></li><li><p><strong>LinkList</strong></p><ul><li><p>内部是双链表结构存储数据，适合数据的插入与删除，随机访问和遍历速度比较慢，此外，还提供了List接口中没有定义的方法，专门用于操作表头和表位元素，可以当作堆栈，队列和双向队列使用。</p><p><img src="/2019/07/15/Collection总结/1563183654460.png" alt="1563183654460"></p></li></ul></li><li><p><strong>Vector</strong></p><ul><li>与ArrayList一样，也是通过数组结构实现的，不同于它的是Vector支持线程的同步，避免多线程同时而引起的不一致性，但实现同步需要很高的花费，因此，效率不及ArrayList。</li></ul></li><li><p><strong>List简单总结</strong></p></li></ul><table><thead><tr><th>名称</th><th>底层结构</th><th>优缺点</th><th>线程安全性</th><th>扩容</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组</td><td>查询快 ，插入/删除慢</td><td>不安全</td><td>当前容量*1.5+1</td></tr><tr><td>LinkList</td><td>双链表</td><td>插入/删除快，查找慢</td><td>不安全</td><td>———–</td></tr><tr><td>Vector</td><td>数组</td><td>查询快，插入/删除慢</td><td>安全</td><td>默认一倍扩容</td></tr></tbody></table><h4 id="Set集合详解"><a href="#Set集合详解" class="headerlink" title="Set集合详解"></a>Set集合详解</h4><ul><li><p>Set重视元素的唯一性，用于存储无序(存和取的顺序不一定相同)元素，值不能重复，根据对象的hashCode值进行判断的，如果想要让两个对象视为相等的，就必须覆盖Object的hashCode和equals方法。它的主要实现类：<strong>HashSet</strong>，<strong>TreeSet</strong>，<strong>LinkHashSet</strong>。</p></li><li><p><strong>HashSet</strong></p><ul><li>HashSet存储元素的顺序不是按照存入时的顺序，而是按照哈希值来存取数据的，元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先会判断两个元素的哈希值，如果哈希值一样，再比较equals，如果equals相等就视为同一个元素，否则就不是同一个元素。</li><li>哈希值相同equals为false的元素的存储问题，当出现这种情况是会在相同的哈希值下顺延，也就是哈希一样的存一列，HashSet通过hashCode值来确定元素在内存中的位置，一个hashCode位置上可以存放多个元素。</li></ul></li><li><p><strong>TreeSet</strong></p><ul><li>TreeSet是使用二叉树对新add()的对象按照指定的顺序排序(升序，降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li><li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</li><li>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序。</li><li>比较次对象与指定对象的顺序，如果该对象小于，等于或大于指定对象，则分别返回负整数，零或正整数。</li></ul></li><li><p><strong>LinkHashSet</strong></p><ul><li><p>LinkHashSet继承HashSet和LinkedHashMap来实现的，LinkedHashSet底层使用LinkHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p><table><thead><tr><th>名称</th><th>底层结构</th><th>优缺点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashSet</td><td>HashMap</td><td>存取快，排列无序，不可重复,可为null</td><td>不安全</td></tr><tr><td>TreeSet</td><td>二叉树</td><td>排列有序，不可重复</td><td>安全</td></tr><tr><td>LinkHashSet</td><td>Hash表+双向链表</td><td>排列有序，不可重复</td><td>不安全</td></tr></tbody></table></li></ul></li></ul><h4 id="Map集合详解"><a href="#Map集合详解" class="headerlink" title="Map集合详解"></a>Map集合详解</h4><ul><li><p><strong>HashMap</strong></p><ul><li>HashMap(1.7)是数组和链表的结合体，数组每个元素存的是链表的头结点，往hashmap里面放键值对的时候先得到key的hashcode，然后重新计算hashcode，然后与length-1按位与，计算数组下标1，如果该下标对应的链表为空，则直接把键值对作为链表头结点，如果不为空，则1遍历链表看是否有key值相同，有就把value替换，没有就把该对对象作为链表的第一个节点，原有的节点为它的后续节点。</li></ul><p><img src="/2019/07/15/Collection总结/Inked1.7_LI.jpg" alt="Inked1.7_LI"></p><ul><li><p>HashMap(1.8)是数组+链表+红黑树，当链表长度&gt;=8时转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入，删除，查找等算法。</p><p><img src="/2019/07/15/Collection总结/1563193744210.png" alt="1563193744210"></p></li><li><p>HashMap扩容</p><ul><li>初始容量16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。</li><li>扩容机制：使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有的Entry数的元素拷贝到新的Entry数组中，Java1.7重新计算每个元素在数组中的位置，Java1.8中不是从新计算，而是使用的是2次幂的扩展，所以，元素的位置要么是在原来的位置，要么是在原位置再移动2次幂的位置在扩展HashMap的时候，不需要像1.7的实现那样重新计算hash，只需要看看原来的hash值新增加的那个bit是1还是0就行了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</li></ul></li><li><p>HashMap为什么线程不安全(hash碰撞和扩容导致)</p><ul><li>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。加入A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</li><li>删除键值对的代码如上：当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写回到该数组位置去，其实写回的时候可能其他的线程已经把这个位置给修改过了，就会覆盖其他线程的修改当多个线程同时检测到总数量超过门限制的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有一个线程生成新的数组被赋给table变量，其他线程的均会丢失，而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</li><li>想要实现线程安全，那么就要调用collections类的静态方法<strong>synchronizeMap()</strong>实现</li></ul></li><li><p><strong>HashTable</strong></p><ul><li>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</li></ul></li><li><p><strong>TreeMap</strong></p><ul><li>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</li></ul></li><li><p><strong>LinkedHashMap</strong></p><ul><li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li></ul></li><li><p><strong>ConcurrentHashMap</strong></p><ul><li><p>Segment</p><ul><li>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。</li></ul></li><li><p>线程安全</p><ul><li>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。</li></ul><p><img src="/2019/07/15/Collection总结/1563194323007.png" alt="1563194323007"></p></li><li><p>并行度</p><ul><li>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</li></ul></li><li><p>Java8实现</p><ul><li>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</li></ul><p><img src="/2019/07/15/Collection总结/1563194333363.png" alt="1563194333363"></p></li></ul></li></ul></li></ul><table><thead><tr><th>名称</th><th>底层</th><th>优缺点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashMap</td><td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td><td>key/value都可为null，查询快，递增排序</td><td>不安全</td></tr><tr><td>HashTable</td><td>散列表</td><td>key和Value都不可为null，递减排序</td><td>安全</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>递增排序</td><td>不安全</td></tr><tr><td>ConcurrentHashMap</td><td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td><td>递增排序</td><td>安全</td></tr><tr><td>LinkedHashMap</td><td>链表+哈希</td><td>存取一致</td><td>不安全</td></tr></tbody></table><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><strong>Iterator和ListIterator的区别</strong><ul><li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul></li><li><strong>快速失败(fail-fast)和安全失败(fail-safe)的区别</strong><ul><li>Iterator的安全失败是基于对底层集合做拷贝，因此，不受原集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下的所有类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全1失败的迭代器永远不会抛出这样的异常。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png&quot; alt=&quot;集合架构图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;图中大体概述&quot;&gt;&lt;a href=&quot;#图中大体概述&quot; 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JVM(五)GC分析</title>
    <link href="http://yoursite.com/2019/07/14/JVM-%E4%BA%94-GC%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/14/JVM-五-GC分析/</id>
    <published>2019-07-14T04:03:44.000Z</published>
    <updated>2019-07-20T14:08:58.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-GC分析"><a href="#Java-GC分析" class="headerlink" title="Java GC分析"></a>Java GC分析</h2><h4 id="什么是Java-GC"><a href="#什么是Java-GC" class="headerlink" title="什么是Java GC"></a>什么是Java GC</h4><ul><li>Java GC(Garbage Collection,垃圾收集,垃圾回收)机制,是Java与C++/C的主要区别之一,作为Java开发者,不需要专门编写内存回收和垃圾清理代码,对内存泄露和溢出问题,这是因为在Java虚拟机中,存在自动内存管理和垃圾收集机制,该机制对JVM中的内存进行标记,并确定那些内存需要回收,根据一定的回收策略,自动的回收内存,永不停息的保证JVM中的内存空间,防止出现内存泄漏和溢出问题，Java GC机制已经日益完善，几乎可以自动的为我们做绝大多数事情，但是，如果开发大型的软件开发，就必须要研究Java GC机制。</li><li>简单总结下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。</li></ul><h4 id="如何获取Java-GC日志"><a href="#如何获取Java-GC日志" class="headerlink" title="如何获取Java GC日志"></a>如何获取Java GC日志</h4><ul><li><p><strong>命令获取Java GC日志</strong></p><ul><li>Java自动的工具行命令，jstat可以动态的监控JVM内存的使用，统计垃圾回收的各项信息。</li><li>如：<code>jstat -gc</code>统计垃圾回收堆的行为</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gc.png" alt="gc"></p><ul><li>也可以设置时间打印(图中每100ms打印一次，共打印200次)</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gctime.png" alt="gctime"></p></li><li><p><strong>GC参数</strong></p><ul><li>JVM的GC日志的主要参数包括如下：<ul><li><code>-XX:+PrintGC</code>输出GC日志</li><li><code>-XX:+PrintGCDetails</code>输出GC的详细日志</li><li><code>-XX:+PrintGCTimeStamps</code>输出GC的时间戳(以基准时间的形式)</li><li><code>-XX:+PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如2019-7-14T17:17:17.177+0800)</li><li><code>-XX:PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</li></ul></li><li>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</li></ul></li><li><p><strong>Tomcat配置示例</strong></p><ul><li>在Tomcat的启动参数中添加JVM的相关参数，如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"><span class="string">-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"><span class="string">-Djava.awt.headless=true </span></span><br><span class="line"><span class="string">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"><span class="string">-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"><span class="string">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure><ul><li>参数概况<ul><li><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</li><li><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是<br>Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young<br>genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio<br>设置成比较大的值（比如65536)来做到。</li><li><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</li><li><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li><li><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code><br>设置gc日志的格式。</li><li><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔。</li><li><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代。</li></ul></li></ul><h4 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h4><ul><li>Young GC回收日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">18.093</span>+<span class="number">0800</span>: <span class="number">25.395</span>: [GC [PSYoungGen: <span class="number">274931</span>K-&gt;<span class="number">10738</span>K(<span class="number">274944</span>K)] <span class="number">371093</span>K-&gt;<span class="number">147186</span>K(<span class="number">450048</span>K), <span class="number">0.0668480</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.08</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure><ul><li>Full GC回收日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">19.160</span>+<span class="number">0800</span>: <span class="number">25.462</span>: [Full GC [PSYoungGen: <span class="number">10738</span>K-&gt;<span class="number">0</span>K(<span class="number">274944</span>K)] [ParOldGen: <span class="number">136447</span>K-&gt;<span class="number">140379</span>K(<span class="number">302592</span>K)] <span class="number">147186</span>K-&gt;<span class="number">140379</span>K(<span class="number">577536</span>K) [PSPermGen: <span class="number">85411</span>K-&gt;<span class="number">85376</span>K(<span class="number">171008</span>K)], <span class="number">0.6763541</span> secs] [Times: user=<span class="number">1.75</span> sys=<span class="number">0.02</span>, real=<span class="number">0.68</span> secs]</span><br></pre></td></tr></table></figure><ul><li><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young<br>gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。</p></li><li><p>通过两张图非常明显看出GC日志构成：</p><ul><li>Young GC日志：</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/%E5%89%8D%E5%8D%8A%E6%AE%B5%E5%88%86%E6%9E%90.jpg" alt="前半段分析"></p><ul><li>Full GC日志：</li></ul></li></ul><p>![full GC_LI](JVM-五-GC分析/full GC_LI.jpg)</p></li></ul><h4 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h4><ul><li><p><strong>GChisto</strong></p><ul><li>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</li><li>配置好本地的jdk环境后，双击GChisto.jar，在弹出的输入框点击add选择gc.log日志。<br><img src="/2019/07/14/JVM-五-GC分析/gc1.jpg" alt="gc1"></li><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gc2.jpg" alt="gc2"></p><ul><li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p></li><li><p>GC Timeline：显示整个时间线上的垃圾收集<img src="/2019/07/14/JVM-五-GC分析/gc3.jpg" alt="gc3"></p></li><li><p>这款工具已经不再维护了。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-GC分析&quot;&gt;&lt;a href=&quot;#Java-GC分析&quot; class=&quot;headerlink&quot; title=&quot;Java GC分析&quot;&gt;&lt;/a&gt;Java GC分析&lt;/h2&gt;&lt;h4 id=&quot;什么是Java-GC&quot;&gt;&lt;a href=&quot;#什么是Java-GC&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(四)JVM优化</title>
    <link href="http://yoursite.com/2019/07/13/JVM-%E5%9B%9B-JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/07/13/JVM-四-JVM优化/</id>
    <published>2019-07-13T03:28:30.000Z</published>
    <updated>2019-07-20T14:08:50.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的JVM优化工具介绍"><a href="#常用的JVM优化工具介绍" class="headerlink" title="常用的JVM优化工具介绍"></a>常用的JVM优化工具介绍</h2><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>​    JVM Process Status Tool,显式指定系统内所有的HotSpot虚拟机进程.</p><ul><li><p><strong>命令格式</strong></p><p><code>jps [options] [hostid]</code></p></li><li><p><strong>option参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l:输出主类全名或jar路径</span><br><span class="line">-q:只输出LVMID</span><br><span class="line">-m:输出JVM启动时传递给main()的参数</span><br><span class="line">-v:输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure></li><li><p><strong>演示</strong></p></li></ul><p><img src="/2019/07/13/JVM-四-JVM优化/jps%E6%BC%94%E7%A4%BA.png" alt="jps演示"></p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>​    jstat(JVM statisics Monitoring)是用于监视虚拟机运行时状态信息的命令,可以显示出虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据</p><ul><li><p><strong>命令格式</strong></p><p><code>jstat [option] LVMID [interval] [count]</code></p></li><li><p><strong>参数</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option]:操作参数</span><br><span class="line"><span class="function"> LVMID:本地虚拟机进程<span class="title">ID</span></span></span><br><span class="line"><span class="function">[<span class="title">interval</span>]:连续输出的时间间隔</span></span><br><span class="line"><span class="function">[<span class="title">count</span>]:连续输出的次数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>option参数讲解</strong></p><ol><li>class:监视类加载,卸载数量,总空间以及耗费的时间</li></ol></li></ul><p><img src="/2019/07/13/JVM-四-JVM优化/jstatclass.png" alt="jstatclass"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Loader:加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes:class</span>字节大小</span></span><br><span class="line"><span class="function"><span class="title">Unloaded</span>:未加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes</span>:未加载<span class="title">class</span>的字节大小</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:加载时间</span></span><br></pre></td></tr></table></figure><pre><code>2. compiler:输出JIT编译过的方法数量耗时等</code></pre><p><img src="/2019/07/13/JVM-四-JVM优化/compiler.png" alt="compiler"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compiled:编译数量</span></span><br><span class="line"><span class="function"><span class="title">Failed</span>:编译失败数量</span></span><br><span class="line"><span class="function"><span class="title">Invalid</span>:无效数量</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:编译耗时</span></span><br><span class="line"><span class="function"><span class="title">FailedType</span>:失败类型</span></span><br><span class="line"><span class="function"><span class="title">FailedMethod</span>:失败方法的全限定名</span></span><br></pre></td></tr></table></figure><ol start="3"><li>gc:垃圾回收堆的行为统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gc.png" alt="gc"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">PC 当前perm的容量 (KB)</span><br><span class="line">PU perm的使用 (KB)</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11660 5000 100</span><br><span class="line"><span class="meta">#</span> 每隔5000ms输出11660的gc情况,一共输出100次</span><br></pre></td></tr></table></figure><ol start="4"><li>gccapacity:与gc相同,不过还会输出Java堆各区域使用到的最大,最小空间</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gccapacity.png" alt="gccapacity"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure><ol start="5"><li>gcutil:同gc,不过输出的是已使用空间占总空间的百分比</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcutil.png" alt="gcutil"></p><ol start="6"><li>gccause:垃圾收集统计概述,附加最近两次垃圾回收事件到的原因</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gccause.png" alt="gccause"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LGCC:最近垃圾回收的原因</span></span><br><span class="line"><span class="function"><span class="title">GCC</span>:当前垃圾回收的原因</span></span><br></pre></td></tr></table></figure><ol start="7"><li>gcnew:统计新生代1的行为</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcnew.png" alt="gcnew"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure><ol start="8"><li>gcnewcapacity:新生代与其相应的内存空间的统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcnewcapacity.png" alt="gcnewcapacity"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NGC:当前年轻代的容量 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0CMX</span>:最大的<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0C</span>:当前<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">ECMX</span>:最大<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">EC</span>:当前<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br></pre></td></tr></table></figure><ol start="9"><li>gcold:统计旧生代的行为</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcold.png" alt="gcold"></p><ol start="10"><li>gcoldcapacity:统计旧生代的大小和空间</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcoldcapacity.png" alt="gcoldcapacity"></p><ol start="11"><li>printcompilation:hotspot编译方法统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/Snipaste_2019-07-13_16-55-48.png" alt="Snipaste_2019-07-13_16-55-48"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line"><span class="built_in">Type</span>：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul><li><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump : 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat : to <span class="built_in">print</span> permanent generation statistics</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure></li><li><p>演示</p></li></ul><ol><li><p>dump常用格式</p><p><code>-dump::live,format=b,file=&lt;filename&gt; pid</code></p><p>dump堆到文件,format指定输出格式,live指是活着的对象,file指文件名</p></li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/dump.png" alt="dump"></p><ol start="2"><li>finalizerinfo:打印等待回收对象的信息</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/info.png" alt="info"></p><p>​    可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行的finalizer方法的对象</p><ol start="3"><li><p>heap:打印heap的概要信息,GC使用的算法,heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">finalizerinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Number</span> <span class="title">of</span> <span class="title">objects</span> <span class="title">pending</span> <span class="title">for</span> <span class="title">finalization</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">heap</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">using</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">object</span> <span class="title">allocation</span>.</span></span><br><span class="line"><span class="function"><span class="title">Parallel</span> <span class="title">GC</span> <span class="title">with</span> 4 <span class="title">thread</span>(<span class="title">s</span>)//<span class="title">GC</span>方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Configuration</span>://堆内存初始化配置</span></span><br><span class="line"><span class="function">   <span class="title">MinHeapFreeRatio</span>         = 0</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapFreeRatio</span>         = 100</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapSize</span>              = 734003200 (700.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewSize</span>                  = 44564480 (42.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxNewSize</span>               = 244318208 (233.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">OldSize</span>                  = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewRatio</span>                 = 2</span></span><br><span class="line"><span class="function">   <span class="title">SurvivorRatio</span>            = 8</span></span><br><span class="line"><span class="function">   <span class="title">MetaspaceSize</span>            = 21807104 (20.796875<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">CompressedClassSpaceSize</span> = 1073741824 (1024.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxMetaspaceSize</span>         = 17592186044415 <span class="title">MB</span></span></span><br><span class="line"><span class="function">   <span class="title">G1HeapRegionSize</span>         = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Usage</span>://堆内存使用情况</span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Young</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function"><span class="title">Eden</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 34078720 (32.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 19266416 (18.373886108398438<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 14812304 (14.126113891601562<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   56.5350341796875% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">From</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 4417480 (4.212837219238281<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 825400 (0.7871627807617188<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   84.25674438476562% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.0% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Old</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 90128 (0.0859527587890625<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 89563120 (85.41404724121094<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.10052954244334796% <span class="title">used</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5507 <span class="title">interned</span> <span class="title">Strings</span> <span class="title">occupying</span> 497712 <span class="title">bytes</span>.</span></span><br></pre></td></tr></table></figure></li><li><p>histo:打印堆的对象统计,包括对象数,内存大小等等</p></li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/histo.png" alt="histo"></p><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>​    jhat命令是与jmap搭配使用,用来分析jmap生成的dump,jhat内置了一个微型的HTTP/HTML服务器,生成dump的分析结果后,可以在浏览器中查看,在此需要注意,一般不会直接在服务器上进行分析,因为jhat是一个耗时并且耗费硬件资源的过程,一般把服务器生成的dump文件复制到本地或其他机器上进行分析.</p><ul><li><p>命令格式</p><p><code>jhat [dumpfile]</code></p></li><li><p>参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line"></span><br><span class="line">-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line"></span><br><span class="line">-port port-number 设置 jhat HTTP server 的端口号. 默认值 <span class="number">7000</span>.&gt;</span><br><span class="line"></span><br><span class="line">-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line"></span><br><span class="line">-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as <span class="keyword">not</span> being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line"></span><br><span class="line">-debug int 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line"></span><br><span class="line">-version 启动后只显示版本信息就退出&gt;</span><br><span class="line"></span><br><span class="line">-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure></li><li><p>演示</p><p>​    第一步:导出堆</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">dump:live</span>,<span class="title">file</span>=<span class="title">a.map</span> 11660</span></span><br><span class="line"><span class="function"><span class="title">Dumping</span> <span class="title">heap</span> <span class="title">to</span> <span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">a.map</span> ...</span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">dump</span> <span class="title">file</span> <span class="title">created</span></span></span><br></pre></td></tr></table></figure><p>​    第二步:分析堆文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jhat</span> <span class="title">a.map</span></span></span><br><span class="line"><span class="function"><span class="title">Reading</span> <span class="title">from</span> <span class="title">a.map</span>...</span></span><br><span class="line"><span class="function"><span class="title">Dump</span> <span class="title">file</span> <span class="title">created</span> <span class="title">Sat</span> <span class="title">Jul</span> 13 18:51:20 <span class="title">CST</span> 2019</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">read</span>, <span class="title">resolving</span>...</span></span><br><span class="line"><span class="function"><span class="title">Resolving</span> 2299776 <span class="title">objects</span>...</span></span><br><span class="line"><span class="function"><span class="title">Chasing</span> <span class="title">references</span>, <span class="title">expect</span> 459 <span class="title">dots</span>.............................</span></span><br><span class="line"><span class="function"><span class="title">Eliminating</span> <span class="title">duplicate</span> <span class="title">references</span>.........................</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">resolved</span>.</span></span><br><span class="line"><span class="function"><span class="title">Started</span> <span class="title">HTTP</span> <span class="title">server</span> <span class="title">on</span> <span class="title">port</span> 7000</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>.</span></span><br></pre></td></tr></table></figure><p>​    第三步:查看HTML</p><p><img src="/2019/07/13/JVM-四-JVM优化/1563015344059.png" alt="1563015344059"></p></li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>​    jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native<br>stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java<br>stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。    </p><ul><li><p>命令格式</p><p><code>jstack [option] LVMID</code></p></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure></li><li><p>演示</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jstack</span> -<span class="title">l</span> 11660|<span class="title">more</span></span></span><br><span class="line"><span class="function">2019-07-13 18:58:09</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">OpenJDK</span> 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (25.152-<span class="title">b11</span> <span class="title">mixed</span> <span class="title">mode</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 216" #550 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7ba000</span> <span class="title">nid</span>=0<span class="title">x1d5c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005dbef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.getTask</span>(<span class="title">ThreadPoolExecutor.java</span>:1066)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.runWorker</span>(<span class="title">ThreadPoolExecutor.java</span>:1127)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor</span>$<span class="title">Worker.run</span>(<span class="title">ThreadPoolExecutor.java</span>:617)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">Thread.java</span>:745)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">Locked</span> <span class="title">ownable</span> <span class="title">synchronizers</span>:</span></span><br><span class="line"><span class="function">        - <span class="title">None</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 215" #549 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7c0000</span> <span class="title">nid</span>=0<span class="title">x3b44</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005daef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">-- <span class="title">More</span>  --</span></span><br></pre></td></tr></table></figure><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>​    jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p></li><li><p>命令格式</p><p><code>jinfo [option] [args] LVMID</code></p></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure></li><li><p>演示</p></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">System</span> <span class="title">Properties</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">java.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">preload.project.path</span> = <span class="title">D</span>:/<span class="title">code</span>/<span class="title">IdeaProjects</span>/<span class="title">JVM</span></span></span><br><span class="line"><span class="function"><span class="title">sun.java.launcher</span> = <span class="title">SUN_STANDARD</span></span></span><br><span class="line"><span class="function"><span class="title">idea.config.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span></span></span><br><span class="line"><span class="function"><span class="title">sun.management.compiler</span> = <span class="title">HotSpot</span> 64-<span class="title">Bit</span> <span class="title">Tiered</span> <span class="title">Compilers</span></span></span><br><span class="line"><span class="function"><span class="title">sun.nio.ch.bugLevel</span> =</span></span><br><span class="line"><span class="function"><span class="title">idea.paths.selector</span> = <span class="title">IntelliJIdea2017</span>.3</span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.client.alive.path</span> = "<span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">AppData</span>\<span class="title">Local</span>\<span class="title">Temp</span>\<span class="title">kotlin</span>-<span class="title">idea</span>-4516842704025065651-<span class="title">is</span>-<span class="title">running</span>"</span></span><br><span class="line"><span class="function"><span class="title">os.name</span> = <span class="title">Windows</span> 10</span></span><br><span class="line"><span class="function"><span class="title">sun.boot.class.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">resources.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">rt.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">sunrsasign.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jsse.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jce.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">charsets.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jfr.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">classes</span></span></span><br><span class="line"><span class="function"><span class="title">sun.desktop</span> = <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">idea.plugins.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span>\<span class="title">plugins</span></span></span><br><span class="line"><span class="function"><span class="title">java.vm.specification.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">java.runtime.version</span> = 1.8.0<span class="title">_102</span>-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">io.netty.serviceThreadPrefix</span> = <span class="title">Netty</span></span></span><br><span class="line"><span class="function"><span class="title">user.name</span> = 严茂</span></span><br><span class="line"><span class="function"><span class="title">kotlin.incremental.compilation</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">idea.home.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">JetBrains</span>\<span class="title">IntelliJ</span> <span class="title">IDEA</span> 2017.3.4</span></span><br><span class="line"><span class="function"><span class="title">user.language</span> = <span class="title">zh</span></span></span><br><span class="line"><span class="function"><span class="title">jdt.compiler.useSingleThread</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">sun.boot.library.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">bin</span></span></span><br><span class="line"><span class="function"><span class="title">java.version</span> = 1.8.0<span class="title">_102</span></span></span><br><span class="line"><span class="function"><span class="title">user.timezone</span> = <span class="title">Asia</span>/<span class="title">Shanghai</span></span></span><br><span class="line"><span class="function"><span class="title">java.net.preferIPv4Stack</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.enabled</span> =</span></span><br><span class="line"><span class="function"><span class="title">sun.arch.data.model</span> = 64</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用的JVM优化工具介绍&quot;&gt;&lt;a href=&quot;#常用的JVM优化工具介绍&quot; class=&quot;headerlink&quot; title=&quot;常用的JVM优化工具介绍&quot;&gt;&lt;/a&gt;常用的JVM优化工具介绍&lt;/h2&gt;&lt;h4 id=&quot;jps&quot;&gt;&lt;a href=&quot;#jps&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(三)GC算法-垃圾收集器</title>
    <link href="http://yoursite.com/2019/07/12/JVM-%E4%B8%89-GC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/07/12/JVM-三-GC算法-垃圾收集器/</id>
    <published>2019-07-12T12:02:02.000Z</published>
    <updated>2019-07-20T14:08:41.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    垃圾收集通常被称之为”<strong>GC</strong>“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生成,随线程的销毁而销毁,栈帧随着方法的进入和退出做入栈和出栈操作,实现了自动的内存清理,因此,内存垃圾回收主要集中在java堆和方法区中,在程序运行期间,这部分的内存的分配和使用1都是动态的.</p><h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活一般有两种方式.</p><ul><li><p><strong>引用计数</strong>:每个对象有一个计数属性,新增一个引用时计数加1,引用释放时计数减1,计数为0时可以回收,此方法简单,无法解决对象相互循环引用的问题.</p></li><li><p><strong>可达性分析</strong>:从GC Roots开始向下搜寻,搜寻所走过的路径称之为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明对象是不可用的,不可达对象.</p></li><li><p>在Java中,GC Roots包括:</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态属性实体引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li></ul></li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    <strong>标记-清除</strong>算法分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象,之所以说它是最基础的收集算法,是因为后续的收集算法都是基于这种思路并对其缺点进行改善而得到的.</p><p>​    它主要有两个缺点:<strong>一是效率问题</strong>,标记和清除过程的效率都不高,<strong>二是空间问题</strong>,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致,当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作.</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​    GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>​    “<strong>分代收集</strong>”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    如果说收集算法是内存回收的方法论,垃圾收集器就是内存回收的具体实现</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>​    串行收集器是最稳定,效率最高的收集器,可能会产生较长的停顿,只使用一个线程去回收,新生代,老年代使用串行回收;新生代复制算法,老年代标记-压缩;垃圾收集的过程中会服务暂停.</p><p>参数控制:<code>-XX:+UseSerialGC</code>串行收集器</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="串行收集器"></p><p>​    ParNew收集器ParNew收集器就是Serial收集器的多线程版本,新生代并行,老年代串行;新生代复制算法,老年代标记-压缩.</p><p>参数控制:</p><ul><li><p><code>-XX:+UseParNewGC</code>ParNew收集器</p></li><li><p><code>-XX:ParallelGCThreads</code>限制线程数量</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt="串行收集器2"></p></li></ul><h4 id="Paralle收集器"><a href="#Paralle收集器" class="headerlink" title="Paralle收集器"></a>Paralle收集器</h4><p>​    Parallel   Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p><p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>​    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p><p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>​    从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>​        其中初始标记、重新标记这两个步骤仍然需要“Stop  The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>​    由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p><p>​    <strong>优点</strong>: 并发收集、低停顿<br>​    <strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p><p>参数控制:</p><p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）    </p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/CMS.jpg" alt="CMS"></p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>​    G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：</p><ul><li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></li><li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></li></ul><p>​        上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/G1.jpg" alt="G1"></p><p>​    G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p>收集步骤：</p><p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p><p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p><p>3、Concurrent  Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young  GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE2.png" alt="图2"></p><p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE3.png" alt="图3"></p><p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%A4%8D%E5%88%B6%E6%B8%85%E9%99%A4.jpg" alt="复制清除"></p><h4 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h4><table><thead><tr><th></th><th>新生代GC策略</th><th>老年代GC策略</th><th align="left">说明</th></tr></thead><tbody><tr><td>组合1</td><td>Serial</td><td>Serial Old</td><td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td></tr><tr><td>组合2</td><td>Serial</td><td>CMS+Serial Old</td><td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td></tr><tr><td>组合3</td><td>ParNew</td><td>CMS</td><td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 <code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td></tr><tr><td>组合4</td><td>ParNew</td><td>Serial Old</td><td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td></tr><tr><td>组合5</td><td>Parallel Scavenge</td><td>Serial Old</td><td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td></tr><tr><td>组合6</td><td>Parallel Scavenge</td><td>Parallel Old</td><td align="left">Parallel Old是Serial Old的并行版本</td></tr><tr><td>组合7</td><td>G1GC</td><td>G1GC</td><td align="left"><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code> #暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code> #暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小； <code>-XX:SurvivorRatio=6</code> #幸存区比例</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​    垃圾收集通常被称之为”&lt;strong&gt;GC&lt;/strong&gt;“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(二)java类的加载机制</title>
    <link href="http://yoursite.com/2019/07/11/JVM-%E4%BA%8C-java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/11/JVM-二-java类的加载机制/</id>
    <published>2019-07-11T10:18:10.000Z</published>
    <updated>2019-07-20T14:08:32.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1. 什么是类加载"></a>1. 什么是类加载</h3><ul><li>类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个<strong>java.lang.Class</strong>对象,用来封装类在方法区内的数据结构,类的加载的最终是位于堆中的<strong>Class对象</strong>,Class对象封装了类在方法区的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口.</li><li>类加载器并不需要等到某个类被初次主动使用时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件异常问题,类加载器必须在程序首次主动使用该类时才报告错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误.</li></ul><p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p><ul><li>加载.class文件的方式<ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip,jar等文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul><h3 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类的加载过程"></h3><ul><li>一个java类的完整生命周期会经历<strong>加载,连接,初始化,使用和卸载</strong>五个阶段,其中,加载,验证,准备和初始化这四个阶段发生的顺序是确定的,但解析阶段则不一定,在某些情况下可以在初始化阶段之后开始,这是为了支持Java的运行时绑定.此外还需要注意这里的几个阶段是按顺序开始的,而不是按顺序进行或完成,因为这些阶段通常都是互相交叉混合进行的,通常在一个阶段执行的过程中调用或激活另一个阶段.</li><li><strong>加载</strong><ul><li>查找并加载类的二进制数据是类加载过程的第一个阶段,在加载阶段,虚拟机需要完成以下三件事.<ul><li>通过一个类的全限定类名来获取其定义的二进制字节流.</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象,作为对方法区中这些数据的访问入口.</li></ul></li><li>相对于类加载的其他阶段而言,加载阶段是可控性最强的阶段,因此开发者即可以使用系统提供的类加载器来完成加载,也可以自定义自己的类加载器来完成加载.</li><li>加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象,这样便可以通过该对象访问方法区中的这些数据.</li></ul></li><li><strong>连接</strong><ul><li><strong>验证:确保被加载的类的正确性.</strong><ul><li>验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全,验证阶段大致会完成4个阶段的检验动作.<ul><li><strong>文件格式验证</strong>:验证字节流是否符合Class文件格式的规范,如:是否以<code>0xCAFEBABE</code>开头,主次版本号是否在当前虚拟机的处理范围之内,常量池中的常量是否有不被支持的阶段.</li><li><strong>元数据验证</strong>:对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求;如:这个类是否有父类,除了<code>java.lang.Object</code>之外的.</li><li><strong>字节码验证</strong>:通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的.</li><li><strong>符号引用验证</strong>:确保解析动作能正确执行.</li></ul></li><li>验证阶段是非常重要的,但不是必须的,它对程序运行期没有影响,如果所引用的类经过反复验证,那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间.</li></ul></li><li><strong>准备:为类的静态变量分配内存,并将其初始化为默认值</strong><ul><li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配,对于该阶段的注意事项.<ul><li>这时进行内存分配的仅包括类变量(static),而不包括实例变量,实例变量会在对象实例化时随着对象一块分配在Java堆中.</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如:0,0L,null,false等等),而不是被在Java代码中被显式地赋予的值.</li><li>如果类字节地字段属性表中存在<code>ConstantValue</code>属性,即同时被final和static修饰,那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值.</li></ul></li></ul></li><li><strong>解析:把类中的符号引用转换为直接引用</strong><ul><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用进行,符号引用就是一组符号来描述目标,可以是任何字面量.</li><li>直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄.</li></ul></li></ul></li><li><strong>初始化</strong><ul><li>初始化,为类的静态变量赋予正确的初始值,JVM负责对类进行初始化,主要对类变量进行初始化,在Java中对类变量进行初始值设定有两种方式.<ul><li>声明类变量是指定初始化</li><li>使用静态代码块为类变量指定初始值</li></ul></li><li>JVM初始化步骤<ul><li>加入这个类还没有被加载和连接,则程序先加载并连接该类</li><li>假如该类的直接父类还没有被1初始化,则先加载其直接父类</li><li>假如类中有初始化语句,则系统依次执行这些初始化语句</li></ul></li><li>类初始化时机:只有当对类的主动使用的时候才会导致类的初始化,类的主动使用包括以下六种<ul><li>创建类的实例,也就是new的方法</li><li>访问某个类或接口的静态变量,或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化某个类的子类,则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类,直接使用java.exe命令来运行某个主类.</li></ul></li></ul></li><li><strong>结束生命周期</strong><ul><li>在这几种情况下,Java虚拟机将结束生命周期<ul><li>执行了<code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul></li></ul></li></ul><h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>先看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">     System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>可以看到,没有获取到ExtClassLoader的父Loader,原因是Bootstrap Loadder是用C写的,找不到一个确定的返回父Loader的方法,于是就返回null.</p><ul><li>类加载器的层次关系图</li></ul><p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="类加载器"></p><ul><li><strong>启动类加载器</strong>:负责加载存放在<code>JDK/jre/lib</code>下,或被<code>-Xbootclasspath</code>参数指定的路径中的,并且能被虚拟机识别的类库,启动类加载器是无法被Java程序直接引用的.</li><li><strong>扩展类加载器</strong>:该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,他负责加载<code>JDK/jre/lib/ext</code>目录中,或者由<code>java.ext.dirs</code>系统变量指定的路径中的所由类库,开发者可以直接使用扩展类加载器.</li><li><strong>应用程序类加载器</strong>:该类加载器由<code>sun.misc.Launcher#AppClassLoader</code>来实现,它负责加载用户类路径所指定的类,开发者可以直接使用该类加载器,如果程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器.</li></ul><h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><ul><li><strong>全盘负责</strong>:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Classs也将由该类加载器负责载入,除非显式使用另外一个类加载器来载入.</li><li><strong>父类委派</strong>:先让父类加载器试图加载该类,只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类.</li><li><strong>缓存机制</strong>:缓存价值将会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,只有缓存区不存在,系统才会读取该类对应的二进制数据,并将其转换为Class对象,存入缓存区,这就是为什么修改Class后,必须重启JVM,程序的修改才会生效.</li></ul><h3 id="4-类的加载"><a href="#4-类的加载" class="headerlink" title="4. 类的加载"></a>4. 类的加载</h3><ul><li>类的加载有三种方式<ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2", false, loader); </span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块执行了);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><code>Class.forName()</code>:将类的.class文件加载到JVM中之外1,还会对类进行解释,执行类中的static块.</li><li><code>ClassLoader.loadClass()</code>:只干一件事,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newlnstance才会去执行static块</li><li><code>Class.forName(name,initialize,loader)带参函数也可以控制是否加载static块,并且只有调用newInstance()方法采用调用构造函数,创建类的对象</code>.</li></ul><h3 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h3><ul><li>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li><li>双亲委派机制<ul><li>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li><li>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li><li>如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li></ul></li><li>双亲委派模型意义<ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul></li></ul><h3 id="6-自定义类加载器"><a href="#6-自定义类加载器" class="headerlink" title="6. 自定义类加载器"></a>6. 自定义类加载器</h3><ul><li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输<br>Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classData = loadClassData(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.ym.jvm.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意<ul><li>这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的.</li><li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式.</li><li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是类加载&quot;&gt;&lt;a href=&quot;#1-什么是类加载&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是类加载&quot;&gt;&lt;/a&gt;1. 什么是类加载&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(一)内存结构</title>
    <link href="http://yoursite.com/2019/07/11/JVM-%E4%B8%80-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/11/JVM-一-内存结构/</id>
    <published>2019-07-11T05:33:12.000Z</published>
    <updated>2019-07-20T14:09:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1562826662961.jpg" alt="jvm内存结构"></p><p>​    JVM内存结构主要有三大块:<strong>堆内存</strong>,<strong>方法区</strong>和<strong>栈</strong></p><p>​    <strong>堆内存</strong>是JVM内存中最大的一块区域,由年轻代和老年代组成,而年轻代由可分为三部分,EdenSpace,FromSpace,ToSpace,默认情况下三者比例为8:1:1的比例.</p><p>​    <strong>方法区</strong>存储类信息,常量,静态变量等数据,是线程共享的区域.</p><p>​    <strong>栈</strong>又可以分为java虚拟机栈和本地方法栈主要用于方法的执行</p><h3 id="2-JVM内存区域分配"><a href="#2-JVM内存区域分配" class="headerlink" title="2.JVM内存区域分配"></a>2.JVM内存区域分配</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1562827418260.jpg" alt="jvm内存分配"></p><ul><li>图中控制参数说明<ul><li>-Xmx:设置堆内存的最大值</li><li>-Xms:设置堆内存的最小值</li><li>-XX:MaxNewSize:设置新生代内存的最大值</li><li>-XX:NewSize:设置新生代内存的最小值</li><li>-XX:MaxPermSize:设置永久代内存的最大值</li><li>-XX:PermSize:设置永久代内存的最小值</li><li>-Xss:设置每个线程的堆栈大小</li></ul></li></ul><h3 id="3-JVM与系统之间调用关系"><a href="#3-JVM与系统之间调用关系" class="headerlink" title="3. JVM与系统之间调用关系"></a>3. JVM与系统之间调用关系</h3><p><img src="/2019/07/11/JVM-一-内存结构/JVM%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1562828203417.jpg" alt="JVM与系统调用"></p><ul><li>方法区,堆属于所有线程间所共享的,而栈,程序计数器是属于线程私有的.</li><li><strong>java堆</strong><ul><li>对于大多数应用来说,java堆是java虚拟机所管理的内存中最大的一块,java堆是所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.</li><li>java堆时垃圾收集器管理的主要区域,因此很多时候也被称之为”<strong>GC堆</strong>“.</li><li>java堆可以位于物理上不连续的内存空间中,只要逻辑上时连续的即可</li><li>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出<strong>OutOfMemoryError</strong>异常.</li></ul></li><li><strong>方法区</strong><ul><li>与java堆一样,是各个线程间共享的内存区域,它主要用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</li><li>方法区与java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾回收.(垃圾回收在方法区出现的频率很小)</li><li>当方法区无法满足内存分配需求时,将抛出<strong>OutOfMemoryError</strong>异常.</li><li>方法区的执行都是随着线程的,原始类型的本地变量以及引用都存放在线程栈中,而引用关联的对象,都存在堆中.</li></ul></li><li><strong>程序计数器</strong><ul><li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码的信号指示器,在虚拟机的概念模型中字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</li><li>由于java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器只会执行一条独立的程序计数器,各条线程之间的1计数器互不影响,独立存储,我们称这种内存区域为”线程私有”的内存.</li><li>如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址,如果正在执行的是Natvie方法,这个计数器值则为空.</li></ul></li><li><strong>JVM栈</strong><ul><li>同程序计数器,java虚拟机栈也是线程私有的,<strong>它的生命周期与线程一样,虚拟机描述的是java方法执行的内存模型</strong>,每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表,朝左栈,动态链接,方法出口等信息.<strong>每一个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机中从入栈到出栈的过程.</strong></li><li>局部变量表存放了编译器可知的各种基本类型数据类型,对象引用(reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</li><li>在java虚拟机规范中,对这个区域规定了两种异常状况,如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<strong>StackOverFlowError</strong>异常,如果虚拟机可以动态的扩展,当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常.</li></ul></li><li><strong>本地方法栈</strong><ul><li>本地方法栈与虚拟机栈所发挥的作用时非常相似的,区别不过时虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务,虚拟机规范中对本地方法栈中的方法使用的语言,使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由的实现它.</li><li>与虚拟机栈一样,本地方法栈区域也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常</li></ul></li></ul><h3 id="4-使用JConsole查看java的相关信息"><a href="#4-使用JConsole查看java的相关信息" class="headerlink" title="4. 使用JConsole查看java的相关信息."></a>4. 使用JConsole查看java的相关信息.</h3><ul><li><p>找到%JAVA_HOME%\bin目录<img src="/2019/07/11/JVM-一-内存结构/javahome.png" alt="javahome"></p></li><li><p>执行cmd,输入jconsole命令,将会打开JConsole面板.<img src="/2019/07/11/JVM-一-内存结构/Jconsole.png" alt="Jconsole"></p></li><li><p>选择你要查看的进程点击连接,成功后如下.<img src="/2019/07/11/JVM-一-内存结构/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="控制面板"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;h3 id=&quot;1-JVM内存结构&quot;&gt;&lt;a href=&quot;#1-JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
</feed>
