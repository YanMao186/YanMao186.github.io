<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>None Bug</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-23T11:13:33.213Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yan Mao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>111</title>
    <link href="http://yoursite.com/2019/07/23/111/"/>
    <id>http://yoursite.com/2019/07/23/111/</id>
    <published>2019-07-23T11:13:33.000Z</published>
    <updated>2019-07-23T11:13:33.213Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud快速入门</title>
    <link href="http://yoursite.com/2019/07/20/Spring-Cloud%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/07/20/Spring-Cloud快速入门/</id>
    <published>2019-07-20T10:14:02.000Z</published>
    <updated>2019-07-21T12:21:13.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><ul><li>Spring Cloud是一系列框架的有序集合。它利用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767" target="_blank" rel="noopener">Spring Boot</a>的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。(<a href="https://baike.baidu.com/item/spring%20cloud/20269825?fr=aladdin" target="_blank" rel="noopener">引自百度百科</a>)</li></ul><h2 id="Spring-Cloud与单体架构"><a href="#Spring-Cloud与单体架构" class="headerlink" title="Spring Cloud与单体架构"></a>Spring Cloud与单体架构</h2><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><ul><li>在微服务的概念形成之前，绝大多数的Web的应用都是使用单体建构进行构建的，在单体架构中，应用程序作为单个可部署的软件制品交付，所有的UI，业务，数据库访问逻辑都被打包在一个应用程序制品中并部署在一个应用程序服务器上面。</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190721112755.jpg" alt="微信图片_20190721112755"></p><ul><li><p>单体架构存在的问题：</p><ul><li>随着业务的发展，开发变得越来越复杂，</li><li>每当各个团队修改代码的时候，整个应用程序都需要<code>重新构建，重新测试及重新部署等。</code></li><li>一旦一个模块出现问题，整个系统就有可能…….</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/20180522084756_mmmla.jpeg" alt="20180522084756_mmmla"></p></li></ul><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>![](Spring-Cloud快速入门/spring cloud架构图.png)</p><ul><li>微服务技术，是对技术上和组织上扩大大型单体应用程序所面临的诸多挑战的直接回应。</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/%E4%BD%A0%E8%BF%87%E6%9D%A5%E5%91%80-1563680562356.webp" alt="你过来呀"></p><ul><li>微服务架构是一个小的，松耦合的分布式服务。</li><li>微服务允许将一个大型的应用分解为具有严格职责定义的便于管理的组件。</li><li>微服务通过将大型的代码分解为小型的精准定义的部分，已解决大型代码库中传统的复杂问题。</li><li>微服务的一大核心就是：分解和分离应用程序的功能，使他们完全彼此独立。如下</li></ul><p><img src="/2019/07/20/Spring-Cloud快速入门/cloud.jpg" alt="cloud"></p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>各个服务的开发，测试，部署等都相互独立，开发之间不需要依赖其他服务。</li><li>构建在微服务之上的应用程序能够使用多种编程语言和技术进行构建。</li><li>一个微服务可以跨多个应用程序复用。</li><li>微服务利用其小，独立和分布式的性质，使组织拥有明确责任领域的小型开发团队。</li></ul><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>微服务的拆分是基于业务的，不是我们想怎么拆就怎么拆，给团队协作，沟通带来了挑战。</li><li>由于各个服务之间是互相独立的，数据也是独立的，当调用多个服务接口来进行操作时，如何保证各个服务之间的数据一致性。</li></ul><h2 id="主流微服务框架简单对比"><a href="#主流微服务框架简单对比" class="headerlink" title="主流微服务框架简单对比"></a>主流微服务框架简单对比</h2><table><thead><tr><th>RPC框架</th><th>dubbo</th><th>motan</th><th>thrift</th><th>grpc</th><th>spring cloud</th></tr></thead><tbody><tr><td>支持语言</td><td>java</td><td>java</td><td>跨语言</td><td>跨语言</td><td>java</td></tr><tr><td>服务治理</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>多注册中心</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>序列化方式</td><td>hessian2/lite/json/kryo</td><td>hessian2/json</td><td>thrift/json</td><td>protobuf</td><td>java/kryo</td></tr><tr><td>跨语言通讯</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td></tr></tbody></table><h2 id="微服务首要考虑因素"><a href="#微服务首要考虑因素" class="headerlink" title="微服务首要考虑因素"></a>微服务首要考虑因素</h2><p><img src="/2019/07/20/Spring-Cloud快速入门/1563696525028.png" alt="1563696525028"></p><h4 id="大小适当"><a href="#大小适当" class="headerlink" title="大小适当"></a>大小适当</h4><ul><li>如何确保正确的划分微服务的大小，可以避免微服务承担太多的职责，适当的大小允许快速的更改应用程序，降低整个应用程序中断的总体风险。</li></ul><h4 id="位置透明"><a href="#位置透明" class="headerlink" title="位置透明"></a>位置透明</h4><ul><li>在微服务应用中，多个服务实例可以快速的启动和关闭时，如何管理服务调用的物理细节。</li></ul><h4 id="有弹性"><a href="#有弹性" class="headerlink" title="有弹性"></a>有弹性</h4><ul><li>如何通过绕过失败的服务，确保采取“快速失败”的方法来保护微服务消费者和应用程序的整体完整性。</li></ul><h4 id="可重复"><a href="#可重复" class="headerlink" title="可重复"></a>可重复</h4><ul><li>如何确保提供的每个新服务实例与生产环境中的所有其他服务实例具有相同的配置和代码库。</li></ul><h4 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h4><ul><li>如何使用异步处理和事件来最小化服务之间的直接依赖关系，并确保可以优雅地扩展代码库。</li></ul><h2 id="微服务模式"><a href="#微服务模式" class="headerlink" title="微服务模式"></a>微服务模式</h2><h4 id="核心微服务开发模式"><a href="#核心微服务开发模式" class="headerlink" title="核心微服务开发模式"></a>核心微服务开发模式</h4><ul><li>核心微服务开发模式解决了构建微服务的基础问题。</li></ul><h4 id="微服务路由模式"><a href="#微服务路由模式" class="headerlink" title="微服务路由模式"></a>微服务路由模式</h4><ul><li>路由模式负责处理处理希望微服务的客户端应用程序，使客户端应用程序发现服务的位置并路由到服务。</li></ul><h4 id="微服务客户端弹性模式"><a href="#微服务客户端弹性模式" class="headerlink" title="微服务客户端弹性模式"></a>微服务客户端弹性模式</h4><ul><li>因为微服务架构是高度分布的，所以必须对如何防止单个服务中的问题级联暴露给服务的消费者十分敏感。常用的有4种客户端弹性模式：客户端负载均衡，断路器模式，后备模式和舱壁模式。</li></ul><h4 id="微服务安全模式"><a href="#微服务安全模式" class="headerlink" title="微服务安全模式"></a>微服务安全模式</h4><ul><li>常用的3种基本的安全模式：验证，授权和凭据管理和传播</li></ul><h4 id="微服务日志记录和跟踪模式"><a href="#微服务日志记录和跟踪模式" class="headerlink" title="微服务日志记录和跟踪模式"></a>微服务日志记录和跟踪模式</h4><ul><li>微服务的优点是单体应用程序被分解为可以彼此独立部署的小的功能部件，而它的缺点是调试和跟踪应用程序和服务中发生的事情要困难的多。</li><li>常用的3种核心日志记录和跟踪模式：日志关联，日志聚合和微服务跟踪。</li></ul><h4 id="微服务构建和部署模式"><a href="#微服务构建和部署模式" class="headerlink" title="微服务构建和部署模式"></a>微服务构建和部署模式</h4><ul><li>微服务架构的核心原则之一是，微服务的每个实例都应该和其他所有实例相同。</li></ul><h2 id="Spring-Cloud各模块入门"><a href="#Spring-Cloud各模块入门" class="headerlink" title="Spring Cloud各模块入门"></a>Spring Cloud各模块入门</h2><h4 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Spring-Cloud&quot;&gt;&lt;a href=&quot;#什么是Spring-Cloud&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring Cloud&quot;&gt;&lt;/a&gt;什么是Spring Cloud&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring Cloud
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="Spring Cloud" scheme="http://yoursite.com/tags/Spring-Cloud/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化及补充</title>
    <link href="http://yoursite.com/2019/07/19/SQL%E4%BC%98%E5%8C%96%E5%8F%8A%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/07/19/SQL优化及补充/</id>
    <published>2019-07-19T07:18:15.000Z</published>
    <updated>2019-07-20T14:09:44.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建，查询，更新和删除数据，不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能，现在许多不同的数据库管理系统都支持不同的数据引擎，存储引擎主要有<ol><li>MyIsam</li><li>InnoDB</li><li>Memory</li><li>Archive</li><li>Federated</li></ol></li></ul><h4 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB(B+树)"></a>InnoDB(B+树)</h4><ul><li>InnoDB底层结构为B+树，B树的每个节点对应的InnoDB的一个page，page大小是固定的，一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563521705026.png" alt="1563521705026"></p><ul><li>适用场景<ul><li>经常更新的表，适合处理多重并发的更新请求。</li><li>支持事务。</li><li>可以从灾难中恢复(通过bin-log日志等)。</li><li>外键约束，只有他支持外键。</li><li>支持自动增加列属性auto_increment。</li></ul></li></ul><h4 id="TokuDB-Fractal-Tree节点带数据"><a href="#TokuDB-Fractal-Tree节点带数据" class="headerlink" title="TokuDB(Fractal Tree节点带数据)"></a>TokuDB(Fractal Tree节点带数据)</h4><ul><li>TokuDB底层存储结构为<code>Fractal Tree</code>,与B+树有些类似，在Fractal Tree中，<strong>每一个child指针除了需要指向一个child节点外，还会带有一个Message Buffer，这个Message Buffer是一个FIFO的队列，用来缓存更新操作。</strong></li><li>如，一次插入操作只需要落在某节点的<code>Message Buffer</code>就可以马上返回了，并不需要搜索到叶子节点，这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</li><li>完全支持事务ACID</li><li>TokuDB在线添加索引，不影响读写操作，非常快的写入性能，Fractal-tree在事务实现上有优势，它主要适用于访问频率不高的数据或历史数据归档。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563522531352.png" alt="1563522531352"></p><h4 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h4><ul><li>MySQL默认的引擎，但是它没有对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整张表，效率会低一些。</li><li>MyIsam执行读取操作的速度很快，而且不占用大量的内存和存储资源，在设计之初就预想数据组织成有固定长度的记录，按顺序存储的，MyIsam是一种静态的索引结构。缺点是不支持事务。</li></ul><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul><li>Memory(也叫做HEAP)堆内存:使用存在内存中的内容来创建表，每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。MEMORY同时支持散列表索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</li></ul><h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul><li>只支持insert和select操作(支持行级锁和缓冲区，可以提高实现高并发的插入)</li><li>只允许在自增ID列上加索引。</li><li>Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。当数据量非常大的时候Archive的插入性能表现会较MyISAM为佳。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>索引(index)是帮助MySQL高效获取数据的数据结构，常见的查询算法，顺序查找，二分查找，二叉树排序查找，哈希散列法，分块查找，平衡多路搜索树B树。</li></ul><h4 id="优缺点及特点"><a href="#优缺点及特点" class="headerlink" title="优缺点及特点"></a>优缺点及特点</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>可以加快数据库的检索速度</li><li>降低数据库插入，修改，删除等维护的速度</li><li>只能创建在表上，不能创建到视图上。</li><li>既可以直接创建又可以间接创建。</li><li>可以在优化隐藏中使用索引。</li><li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引。</li></ol><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>创建唯一性索引，保证数据表中每一行数据的唯一性。</li><li>大大加快数据的检索速度，这是创建索引的最主要原因。</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加，删除和修改的时候，索引也需要维护，降低数据维护的速度。</li></ol><h4 id="常见的索引原则"><a href="#常见的索引原则" class="headerlink" title="常见的索引原则"></a>常见的索引原则</h4><ol><li><strong>选择唯一性索引</strong>:唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录。</li><li><strong>为经常需要排序，分组和联合操作的字段建立索引</strong>。</li><li><strong>为常作为查询条件的字段建立索引。</strong></li><li><strong>限制索引的数目</strong>：越多的索引，会使更新表变得很浪费时间。</li><li><strong>尽量使用数据量少的索引</strong>：如果索引的值很长，那查询的速度会收到影响。</li><li><strong>尽量使用前缀来索引</strong>：如果索引字段的值很长，最好使用值的前缀来索引。</li><li><strong>删除不再使用或很少使用的前缀。</strong></li><li><strong>最左前缀匹配原则，非常重要的原则。</strong></li><li><strong>尽量选择区分度高的列作为索引</strong>：区分度的公式是表示字段不重复的比例。</li><li><strong>索引列不能参与计算，保持列“干净”，带函数的查询不参与索引。</strong></li><li><strong>尽量的扩展索引，不要新建索引。</strong></li></ol><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li><strong>组合索引</strong>：实质上是将多个字段建到一个索引里，列指的组合必须唯一。</li><li><strong>聚集索引</strong>：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</li><li><strong>非聚集索引</strong>：唯一索引，普通索引，主键索引，全文索引。</li><li><strong>UNIQUE(唯一索引)</strong>：不可以出现相同的值，可以有NULL值。</li><li><strong>INDEX(普通索引)</strong>：允许出现相同的索引内容。</li><li><strong>PROMARY KEY(主键索引)</strong>：不允许出现相同的值。</li><li><strong>fulltext index(全文索引)</strong>：可以针对值中的某个单词，但效率呵呵。</li></ol><h4 id="MySQL如何为表字段添加索引"><a href="#MySQL如何为表字段添加索引" class="headerlink" title="MySQL如何为表字段添加索引"></a>MySQL如何为表字段添加索引</h4><ol><li>添加PRIMARY KEY(主键索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add primary key (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li>添加UNIQUE(唯一索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add unique (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="3"><li>添加INDEX(普通索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add index indexname (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="4"><li>添加FULLTEXT(全文索引)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tablename add fulltext (&apos;column&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>添加多列索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; addd indexname (&apos;column1&apos;,&apos;column2&apos;,&apos;column3&apos;)</span><br></pre></td></tr></table></figure><h2 id="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"><a href="#当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施" class="headerlink" title="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"></a>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施</h2><h4 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h4><ul><li>务必禁止不带任何限制数据范围条件的查询语句，比如：在查询订单历史时，我们可以控制在一个月的范围内。</li></ul><h4 id="读-写分离"><a href="#读-写分离" class="headerlink" title="读/写分离"></a>读/写分离</h4><ul><li>数据库拆分，主库负责写，从库负责读。</li></ul><h4 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h4><ul><li><strong>根据数据库中的数据表的相关性进行拆分</strong>，如：用户表中既有用户的登录信息又有用户的基本信息，可以把用户表拆成两张表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张表列比较多的表拆分为多张表。如下</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563531655922.png" alt="1563531655922"></p><ul><li><strong>垂直拆分优点</strong>：可以使行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区让事务变得更加复杂。</li></ul><h4 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h4><ul><li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的，水平拆分可以支撑非常大的数据量。</strong>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表数据拆成多张表来存放。如：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成的影响。</li><li>水平拆分可以支持非常大的数据量，需要注意的是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。<strong>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决</strong>，跨界点Join性能较差，逻辑复杂。</li><li><strong>尽量不要对数据进行分片，以为拆分会带来逻辑，部署，运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片的架构，这样可以减少一次和中间件的网络I/O。</li></ul><h4 id="数据库分片常见方案"><a href="#数据库分片常见方案" class="headerlink" title="数据库分片常见方案"></a>数据库分片常见方案</h4><ul><li><strong>客户端代理，分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现</strong>。当当网的ShardingJDBC,阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：在应用和数据中间加了一个代理层，分片逻辑统一维护在中间件服务中</strong>。Mycat，360的Atlas，网易的DDB等等都是这种架构实现的。</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol><li>对查询进行优化，应尽量避免全表扫面，首先应考虑在<code>where</code>及<code>order by</code>涉及的列上建立索引。</li><li>索引并不是越多越好，会降低维护的效率。</li><li><code>in</code>和<code>not in</code>要慎用。</li><li>避免在字段上进行计算操作。</li><li>临时表也可以用，要记得显式的删除。</li><li>避免频繁的创建删除数据表。</li><li>拆分大的<code>insert</code> <code>update</code>操作，提高并发性能。</li><li><strong>避免在<code>where</code>子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</li><li>避免在<code>where</code>子句中对字段进行<code>null</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>避免在<code>where</code>子句中使用<code>or</code>来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>………………………………</li></ol><h2 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h2><ol><li>SQL语句以及索引的优化。</li><li>数据库表结构的优化。</li><li><strong>数字类型</strong>：非万不得已不要使用DOUBLE。</li><li><strong>字符类型</strong>：非万不得已不要使用TEXT数据类型。</li><li><strong>时间类型</strong>：尽量使用<code>TIMESTAMP</code>类型，因为其存储空间只需要<code>DATETIME</code>类型的一半，对于只需要精确到某一天的数据类型，建议使用<code>DATE</code>类型，因为他们的存储空间只需要3个字节，比<code>TIMESTAMP</code>还少。</li><li>数据库引擎选择，对于<code>select</code>执行比较多的操作，很少插入删除更新的表使用<code>MyIsam</code>引擎。</li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><ul><li>事务是逻辑上的一组操作，要么都执行，要么都不执行</li></ul><h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><ul><li>事务的最小执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用。</li></ul><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><ul><li>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</li></ul><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><ul><li>并发访问数据库时，一个用户的事务不被其他的事务所干扰，各并发之间数据库是独立的。</li></ul><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><ul><li>一个事务被提交后。它对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><ul><li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是”脏数据“，依据”脏数据“所作的操作可能是不正确的。</li></ul><h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><ul><li>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为”丢失修改“。如：事务1读取表中的数据为A=20，事务2也读取为A=20，事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19，事务1的修改丢失。</li></ul><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><ul><li>指在一个事务内多次读同一个数据，在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li></ul><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><ul><li>幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称之为幻读。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a>READ-UNCOMMITTED(读未提交)</h5><ul><li>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读，幻读或不可重复读。</strong></li></ul><h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)"></a>READ-COMMITTED(读已提交)</h5><ul><li>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。</strong></li></ul><h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)"></a>REPEATABLE-READ(可重复读)</h5><ul><li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li></ul><h5 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h5><ul><li>最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读，不可重复读以及幻读。</strong></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">数据库默认隔离级别</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">o</td><td align="center">o</td><td align="center">o</td><td align="center"></td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">x</td><td align="center">o</td><td align="center">o</td><td align="center">oracle/SQL server</td></tr><tr><td align="center">REPEATABLE-READ</td><td align="center">x</td><td align="center">x</td><td align="center">o</td><td align="center">MySQL</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center"></td></tr></tbody></table><h2 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h2><ul><li>并发控制一般采用三种方法：<strong>乐观锁</strong>，<strong>悲观锁</strong>和<strong>时间戳</strong>。</li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul><li>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</li></ul><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul><li>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</li></ul><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><ul><li>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</li></ul><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul><li>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：<ul><li><code>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE  [OF columns][WAIT n | NOWAIT]</code>;</li><li><code>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</code></li><li><code>使用 COMMIT 或 ROLLBACK 语句释放锁</code></li></ul></li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul><li>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</li></ul><h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><ul><li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</li></ul><h2 id="基于Redis分布式锁"><a href="#基于Redis分布式锁" class="headerlink" title="基于Redis分布式锁"></a>基于Redis分布式锁</h2><ul><li>获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁</li><li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul><li>分库分表有<strong>垂直切分</strong>和<strong>水平切分</strong>两种</li></ul><h4 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分(按照功能模块)"></a>垂直切分(按照功能模块)</h4><ul><li>将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563525859253.png" alt="1563525859253"></p><h4 id="水平切分-按照规划划分存储"><a href="#水平切分-按照规划划分存储" class="headerlink" title="水平切分(按照规划划分存储)"></a>水平切分(按照规划划分存储)</h4><ul><li>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563525903133.png" alt="1563525903133"></p><h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><h4 id="柔性事务-1"><a href="#柔性事务-1" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul><li>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</li><li>通常所说的柔性事务分别为：<strong>两阶段型</strong>，<strong>补偿型</strong>，<strong>异步确保型</strong>，<strong>最大努力通知型</strong>几种。</li></ul><h5 id="两阶段型："><a href="#两阶段型：" class="headerlink" title="两阶段型："></a>两阶段型：</h5><ul><li>就是分布式事务两阶段提交，对应技术上的XA，JTA/JTS。这是分布式环境下事务处理的典型模式。</li></ul><h5 id="补偿型："><a href="#补偿型：" class="headerlink" title="补偿型："></a>补偿型：</h5><ul><li>TCC型事务(Try/Confirm/Cancel)可以归为补偿型。</li><li>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563526421770.png" alt="1563526421770"></p><h5 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h5><ul><li>通过将一系列同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响。</li></ul><p><img src="/2019/07/19/SQL优化及补充/1563526497943.png" alt="1563526497943"></p><h5 id="最大努力通知型-多次尝试"><a href="#最大努力通知型-多次尝试" class="headerlink" title="最大努力通知型(多次尝试)"></a>最大努力通知型(多次尝试)</h5><ul><li>这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <strong>允许在达到最大重试次数之后正常结束事务。</strong></li></ul><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability<br>（可用性）、Partition tolerance（分区容错性），三者不可得兼。</li></ul><h4 id="一致性-C"><a href="#一致性-C" class="headerlink" title="一致性(C)"></a>一致性(C)</h4><ul><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值(等同于所有节点访问同一份最新的数据副本)</li></ul><h4 id="可用性-A"><a href="#可用性-A" class="headerlink" title="可用性(A)"></a>可用性(A)</h4><ul><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</li></ul><h4 id="分区容忍性-P"><a href="#分区容忍性-P" class="headerlink" title="分区容忍性(P)"></a>分区容忍性(P)</h4><ul><li>以实际效果而言，分区相当于对通信的时限要求，系统如果不能在1时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://yoursite.com/2019/07/19/%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/07/19/网络/</id>
    <published>2019-07-19T05:55:15.000Z</published>
    <updated>2019-07-20T14:10:49.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络7层协议"><a href="#网络7层协议" class="headerlink" title="网络7层协议"></a>网络7层协议</h2><ol><li><strong>物理层</strong>：主要定义物理设备标准，如：网线，光纤接口类型，各种传输介质的传输速率等。它主要作用是传输比特流(就是由1.0转换为电流强弱来进行传输，到达目的地后在转换为1，0，也就是我们常说的<strong>模数转换与数据转换</strong>)。这一层的数据叫做比特。</li><li><strong>数据链路层</strong>：主要将从物理层接受的数据进行<strong>MAC地址(网卡的地址)的封装与解封装</strong>。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</li><li><strong>网络层</strong>：主要将从下一层接收到的数据<strong>进行IP地址的封装与解封装</strong>，在这一层工作的设备是<strong>路由器</strong>，常把这一层的数据叫做数据包。</li><li><strong>传输层</strong>：定义了一些<strong>传输数据的协议和端口号</strong>(WWW端口80等)，如<strong>TCP</strong>(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，<strong>UDP</strong>(用户数据报协议，与TCP特性相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将从下层接收的数据进行传输，到达目的地后再进行重组。常常把这一层数据叫做段。</li><li><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)<strong>建立数据传输的通路</strong>，主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li><li><strong>表示层</strong>：主要是进行对接收的数据进行<strong>解释，加密与解密，压缩与解压缩等</strong>（也就是把计算机能够识别的东西转换成人能够识别的东西，如：图片，声音等）。</li><li><strong>应用层</strong>：主要是一些终端的应用，比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（简单说就是我们可以在电脑屏幕上看见的东西，就属于终端）。</li></ol><p><img src="/2019/07/19/网络/timg.jpg" alt="timg"></p><h2 id="TCP-IP原理"><a href="#TCP-IP原理" class="headerlink" title="TCP/IP原理"></a>TCP/IP原理</h2><ul><li><p><strong>TCP/IP协议不是TCP和IP这两个协议的合称</strong>，而是指因特网整个TCP/IP协议族，从协议分层模型方面讲，TCP/IP由四个层次组成：<strong>网络接口层</strong>，<strong>网络层</strong>，<strong>传输层</strong>，<strong>应用层</strong>。</p><p><img src="/2019/07/19/网络/timg.jpg%E7%9A%84%E5%A4%A7%E8%8B%8F%E6%89%93.jpg" alt="timg.jpg的大苏打"></p></li></ul><h4 id="网络访问层"><a href="#网络访问层" class="headerlink" title="网络访问层"></a>网络访问层</h4><ul><li>有时也称作数据链路层或网络接口层，在TCP/IP参考模型中并没有详细描述，<strong>只是指出主机必须使用某种协议与网络相连</strong>。</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>是整个体系结构中的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立的转向目标，这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同，高层如果需要顺序收发，那么就必须自行处理对分组的排序。<strong>互联网层使用因特网协议（IP）</strong>。</li></ul><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul><li>传输层使源端和目的端机器上的对等实体可以进行会话，<strong>在这一层定义了两个端到端的协议</strong>：传输控制协议（TCP，UDP）<strong>TCP是面向连接的协议</strong>，它提供可靠的报文传输和对上层应用的连接服务，为此，除了基本的数据传输外，它还有可靠性保证，流量控制，多路复用，优先权和安全性控制等功能。<strong>UDP是面向无连接的不可靠传输的协议</strong>，主要用于步需要TCP的排序和流量控制等功能的应用程序。</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>应用层包含所有的高层协议，包括：<strong>虚拟终端协议（Telnet）,文件传输协议（FTP），电子邮件协议（SMTP）,域名服务（DNS），超文本传输协议（HTTP）等。</strong></li></ul><h2 id="TCP三次握手-四次挥手"><a href="#TCP三次握手-四次挥手" class="headerlink" title="TCP三次握手/四次挥手"></a>TCP三次握手/四次挥手</h2><ul><li>TCP在传输之前会进行三次沟通，一般称之为“三次握手”，传输完数据断开的时候要进行四次沟通，一般称之为“四次挥手”。</li></ul><h4 id="数据包简要概述"><a href="#数据包简要概述" class="headerlink" title="数据包简要概述"></a>数据包简要概述</h4><ol><li><strong>源端口号</strong>（16位）：它（连同源主机IP地址）标识源主机的一个应用进程。</li><li><strong>目的端口号</strong>（16位）：它（连同目的主机IP地址）标识目的主机的一个应用进程，<strong>这两个值加上IP报头中的源主机IP地址和目的主机IP地址确定唯一一个TCP连接</strong>。</li><li><strong>顺序号</strong>（32位）：<strong>用来标识从TCP源端向TCP目的端发送的数据字节流，他表示在这个报文段中的第一个数据字节的顺序号</strong>。如果将字节流看作在两个应用程序讲的单行流动，<strong>则TCP用顺序号对应每个字节进行计数</strong>。序号是32bit的无符号数，<strong>序号到达$$2^{32}-1$$后又从0开始，当建立一个新的连接时，SYN标志变1</strong>，顺序号字段包含由这个主板选择的该连接的初始顺序号ISN（Initial Sequence Number）。</li><li><strong>确认号ack</strong>（32位）：<strong>包含发送确认的一端所期望收到的下一个顺序号</strong>，因此，确认序号应当是上次已成功收到数据字节顺序号加1，<strong>只有ACK标志为1时确认序号字段才有效</strong>。TCP为应用层提供全双工服务，这意味着能在两个方向上独立地进行传输。因此，连接的每一端必须保证每个方向上的传输数据顺序号。</li><li><strong>TCP报头长度</strong>（4位）：给出报头中32bit字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部，然而，没有任选字段，正常的长度是20字节。</li><li><strong>保留数</strong>（6位）：保留给将来使用，目前必须置为0。</li><li><strong>控制位</strong>（6位）：在TCP报头中有6个标志比特，它们中有多个可同时被设置为1。依次为：<ol><li>URG：为1标识紧急指针有效，为0则忽略紧急指针值。</li><li>ACK：为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。</li><li>PSH：为1表示是带有PUSH标志的数据，<strong>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</strong></li><li>RST：<strong>用于复位由于主机崩溃或其他原因而出现错误的连接</strong>，它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个RST为1的报文，那么一定发生了某些问题。</li><li>SYN：同步序号，<strong>为1表示连接请求</strong>，用于建立连接和使顺序号同步。</li><li>FIN：<strong>用于释放连接</strong>，为1表示发送方已经没有数据发送了，即关闭本方数据流。</li></ol></li><li><strong>窗口大小</strong>（16位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。</li><li><strong>校验和</strong>（16位）：此校验和是对整个的TCP报文段，<strong>包括TCP头部和TCP数据，以16位字进行计算所得</strong>，这是一个强制性的字段，一定是由发送端计算和存储，<strong>并由接收端进行验证</strong>。</li><li><strong>紧急指针</strong>（16位）：只有当URG标志置位1时紧急指针才有效。<strong>TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</strong></li><li><strong>选项</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size）。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项，<strong>它指明本端所能接收的最大长度的报文段</strong>。选项长度不一定是32位字的整数倍，所以要加填充位，使得报头长度成为整字数。</li><li><strong>数据</strong>：TCP报文段中的数据部分是可选的，在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首段，如果一方没有数据要发送，也使用没有任何数据的首段来确认收到的数据，在处理超时的许多情况中，也会发送不带任何数据的报文段。</li></ol><p><img src="/2019/07/19/网络/1563431855650.png" alt="1563431855650"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>第一次握手：主机A发送位码为<code>syn=1</code>，随机产生<code>seq number=1234567</code>的数据包到服务器，主机B由SYN=1知道，A要求建立联机。</li><li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=<code>(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包</code>。</li><li>第三次握手：<code>主机A收到后检查ack number是否正确</code>，即第一次发送的seq number+1，以及位码ack是否为1，若正确，<code>主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功</code>。</li></ul><p><img src="/2019/07/19/网络/1563432346818.png" alt="1563432346818"></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>TCP建立连接要进行三次握手，而断开连接要进行四次，这是由于TCP的半关闭造成的。因为TCP连接是全双工的（即数据可在两个方向上同时传递）所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫做半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。</li><li>第一次挥手：关闭客户端到服务器的连接，首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认，其中终值标志位FIN=1，序列号seq=u。</li><li>第二次挥手：服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。</li><li>第三次挥手：关闭服务器到客户端的连接：也是发送一个FIN给客户端。</li><li>第四次挥手：客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li><li>主机A发送FIN后，进入终止等待状态，服务器B收到主机A连接释放报文段后，就立即给主机A发送确定，然后服务器B就进入<code>close-wait</code>状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。此时。若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入<code>time-wait</code>，注意，此时TCP连接还没有释放掉，然后经过时间等待计数器设置的2MSL后，A才进入到close状态。</li></ul><p><img src="/2019/07/19/网络/1563435685702.png" alt="1563435685702"></p><h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p><img src="/2019/07/19/网络/1563454607638.png" alt="1563454607638"></p><h4 id="对应的协议不同"><a href="#对应的协议不同" class="headerlink" title="对应的协议不同"></a>对应的协议不同</h4><h6 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h6><ol><li><strong>FTP</strong>：定义了文件传输协议，使用<code>21端口</code>。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li><li><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是纯字符界面的，<code>支持BBS的服务器将23端口打开，对外提供服务</code>。</li><li><strong>SMTP</strong>：定义了简单邮件传输协议，现在很多邮件服务器都用的是这个协议，用于邮件发送。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有SMTP端口设置，<code>服务器开放的是25端口</code>。</li><li><strong>POP3</strong>：和SMTP对应，POP3用于接收邮件。通常情况下，<code>POP3协议所用的是110端口</code>。也就是说，只要你有相应的使用POP3协议的程序，就可以不以Web方式登录进邮箱页面，直接用邮件程序就可以收到邮件。</li><li><strong>HTTP协议</strong>：是从Web服务器传输超文本到本地浏览器的传输协议。</li></ol><h6 id="UDP对应的协议"><a href="#UDP对应的协议" class="headerlink" title="UDP对应的协议"></a>UDP对应的协议</h6><ol><li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。<code>DNS用的是53端口</code>。</li><li><strong>SNMP</strong>：简单的网络协议，<code>使用161端口</code>，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li><li><strong>TFTP</strong>：简单文件传输协议，该协议在<code>端口69上使用UDP服务</code>。<h2 id="TCP如何保证可靠性传递"><a href="#TCP如何保证可靠性传递" class="headerlink" title="TCP如何保证可靠性传递"></a>TCP如何保证可靠性传递</h2></li></ol><ul><li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并不给出响应，这是TCP发送数据端超时后会重发数据。</li><li><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。</li><li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据。</li><li><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。</li><li><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h2 id="TCP流量控制-拥塞控制"><a href="#TCP流量控制-拥塞控制" class="headerlink" title="TCP流量控制/拥塞控制"></a>TCP流量控制/拥塞控制</h2><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul><li><strong>原因</strong>：如果发送方把数据发送的过快，接收方可能来不及接收，这就会造成数据的丢失。</li><li><strong>原理</strong>：是利用滑动窗口实现的，接收方告诉发送方自己的接收窗口大小，然后发送方发送窗口不能超过接收方给出的接收窗口值。</li></ul><h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><ul><li>发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。</li><li>慢开始的算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li><li>这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下：</li></ul><p><img src="/2019/07/19/网络/1563459696361.png" alt="1563459696361"></p><ul><li>上图中，发送方每收到一个确认就cwnd+1，也就是说发送发发送2就收到2个，所以就是cwnd就是4，也就是翻倍成长的道理，每次都是翻倍，也就是指数增长。为了防止cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。用法如下：<ul><li>当cwnd &lt; ssthresh时，使用慢开始算法。</li><li>当cwnd &gt; ssthresh时，改用拥塞避免算法。</li><li>当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</li></ul></li></ul><h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul><li>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到1确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判断，所以都当作拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法，如下：</li></ul><p><img src="/2019/07/19/网络/1563463668758.png" alt="1563463668758"></p><h4 id="快速重传快速恢复"><a href="#快速重传快速恢复" class="headerlink" title="快速重传快速恢复"></a>快速重传快速恢复</h4><ul><li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为了使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，如下</li></ul><p><img src="/2019/07/19/网络/1563503812096.png" alt></p><ul><li><p>快重传配合使用的还有快速恢复算法，有两个特点：</p><ul><li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 <code>ssthresh</code>门限减半。但是接下去并不执行慢开始算法。</p></li><li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将<code>cwnd 设置为 ssthresh</code>的大小，然后执行拥塞避免算法。如下</p><p><img src="/2019/07/19/网络/1563504121286.png" alt></p></li></ul></li></ul><h2 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h2><p><img src="/2019/07/19/网络/1563508119629.png" alt="1563508119629"></p><ol><li><p><strong>CLOSED</strong>：起始点，在超时或者连接关闭时进入此状态。</p></li><li><p><strong>LISTEN</strong>：svr端在等待连接过来时候的状态，svr端为此要调用<code>socket，bind，listen函数</code>，就能进入此状态。此称为应用程序被动打开(等待客户端来连接)。</p></li><li><p><strong>STN_SENT</strong>：客户端发起连接，发送SYN给服务器端。如果服务器端不能连接，则直接进入<code>CLOSED状态</code>。</p></li><li><p><strong>SYN_RCVD</strong>：跟3对应，服务器端接收客户端的<code>SYN请求</code>，服务器端由<code>LISTEN状态进入SYN_RCVD状态</code>。同时<code>服务器端要回应一个ACK</code>，<code>同时发送一个SYN给客户端</code>；另外一种情况，<code>客户端在发起SYN的同时接收到服务器端的SYN请求，客户端就会由SYN_SENT到SYN_RCVD状态</code>。</p></li><li><p><strong>ESTABLISHED</strong>：服务器和客户端在完成3次握手后进入状态，说明已经可以开始传输数据了。</p></li><li><p><strong>FIN_WAIT_1</strong>：主动关闭的一方，由状态5进入此状态，具体的动作时发送FIN给对方。</p></li><li><p><strong>FIN_WAIT_2</strong>：主动关闭的一方，接收到对方的<code>FIN ACK</code>，进入此状态。由此不能再接收对方的数据，但是能够向对方发送数据。</p></li><li><p><strong>CLOSE_WAIT</strong>：接收到<code>FIN</code>以后，被动关闭的一方进入此状态，具体动作时接收到<code>FIN</code>，同时发送<code>ACK</code>。</p></li><li><p><strong>LAST_ACK</strong>：被动关闭的一方，发起关闭请求，由状态8进入此状态。具体动作时发送FIN给对方，<code>同时在接收到ACK时进入CLOSED状态</code>。</p></li><li><p><strong>CLOSING</strong>：两边同时发起关闭请求时，会由<code>FIN_WAIT_1</code>进入此状态。<code>具体动作是，接收到FIN请求，同时响应一个ACK</code>。</p></li><li><p><strong>TIME_WAIT</strong>：从图中可以看到，有三个状态可以转化为此状态</p><p>   a.<code>由FIN_WAIT_2进入此状态</code>：在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态。</p><p>   b. <code>由CLOSING状态进入</code>：双方同时发起关闭，都做了发起FIN的请求1，同时接收到了FIN并做了ACK的情况下，由CLOSINT状态进入。</p><p>   c. <code>由FIN_WAIT_1状态进入</code>：同时接收到FIN（对方发起），ACK（本身发起的FIN回应），与b的区别在于本身发起的FIN回应的ACK先于对方的FIN请求到达，而b是FIN先到达。这种国情况概率最小。</p></li></ol><h4 id="当一个tcp监听了80端口后，udp还能否监听80端口"><a href="#当一个tcp监听了80端口后，udp还能否监听80端口" class="headerlink" title="当一个tcp监听了80端口后，udp还能否监听80端口"></a>当一个tcp监听了80端口后，udp还能否监听80端口</h4><ul><li>：由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个 255 号端口，UDP 也可以有一个 255 号端口，二者并不冲突。</li></ul><h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><ul><li>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。</li></ul><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><ul><li>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。</li></ul><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><ul><li><p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成：发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。</p><ul><li>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。</li><li>p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。</li><li>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</li></ul><p><img src="/2019/07/19/网络/1563507810510.png" alt="1563507810510"></p></li></ul><h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><ul><li>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。</li><li>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</li></ul><p><img src="/2019/07/19/网络/1563507862436.png" alt="1563507862436"></p><h4 id="连续ARQ的注意事项"><a href="#连续ARQ的注意事项" class="headerlink" title="连续ARQ的注意事项"></a>连续ARQ的注意事项</h4><ul><li>同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</li><li>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。</li><li>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h4 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h4><ul><li>关于 SYN Flood 攻击。一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫tcp_syncookies 的参数来应对这个事——当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，请先千万别用 tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li></ul><h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ul><li>DDoS 攻击是 Distributed Denial of Service 的缩写，即不法黑客组织通过控制服务器等资源，发动对包括国家骨干网络、重要网络设施、政企或个人网站在内的互联网上任一目标的攻击，致使目标服务器断网，最终停止提供服务。</li><li>预防:1.高防服务器 主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等 2.DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。3.CDN加速 在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</li></ul><h4 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h4><ul><li>DNS 欺骗就是攻击者冒充 域名服务器 的一种欺骗行为。</li><li>预防：<ul><li>1.使用入侵检测系统 </li><li>2.使用 DNSSEC</li></ul></li></ul><h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><ul><li>重放攻击又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。</li><li>预防：<ul><li>1.加随机数 </li><li>2.加时间戳</li></ul></li></ul><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><ul><li><p>所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。</p></li><li><p>预防：</p><ul><li><p>1.加密处理 将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令。</p></li><li><p>2.确保数据库安全 只给访问数据库的 web 应用功能所需的最低的权限，撤销不必要的公共许可 。</p></li><li><p>3.输入验证 检查用户输入的合法性，确信输入的内容只包含合法的数据。数据检查应当在客户端和服务器端都执行之所以要执行服务器端验证，是为了弥补客户端验证机制脆弱的安全性。</p></li></ul></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>HTTP是一个无状态协议。无状态是指客户端(Web浏览器)和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务端发出请求，然后服务器返回响应（response），连接就被关闭了，再服务器端不保留连接的有关信息。HTTP遵循请求（Requset）/应答（Response）模型。客户机（浏览器）向服务器发送请求。服务器处理请求并返回适当的应答。所有HTTP连接都被构成一套请求和响应。</li></ul><h4 id="http请求报文与响应报文"><a href="#http请求报文与响应报文" class="headerlink" title="http请求报文与响应报文"></a>http请求报文与响应报文</h4><ul><li><strong>http请求报文</strong><ul><li>HTTP请求报文由请求行，请求头，空行和请求数据4部分组成。</li><li>请求行：(get/post方法，url中的path路径，http版本)</li><li>请求头（header）关键字/值对组成。</li><li>请求数据（body）：http响应报文由状态行，响应头部，空行，响应数据组成。</li></ul></li><li><strong>http响应报文</strong><ul><li>HTTP响应由四个部分组成：<ul><li>状态码（Status Code）：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码<code>HttpServletResponse.SC_OK</code>。</li><li>HTTP头部（HTTP Header）：它们包含了更多的关于相应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。</li><li>空行</li><li>主体（Body）：包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</li></ul></li></ul></li></ul><h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h4><ol><li><strong>地址解析</strong></li></ol><ul><li>如用客户端请求页面:<code>http://localhost:8080/index.html</code>从中分解出协议名，主机名，端口，对象路径等部分。对于这个地址解析后如下：<ul><li>协议名：<code>http</code></li><li>主机名：<code>localhost</code></li><li>端口：<code>8080</code></li><li>对象路径：<code>/index.html</code></li></ul></li><li>在这一步，需要域名系统DNS解析域名得到主机的IP地址。</li></ul><ol start="2"><li><strong>封装HTTP请求数据包</strong></li></ol><ul><li>把上面的部分结合本机自己的信息，封装成一个HTTP请求数据包。</li></ul><ol start="3"><li><strong>封装成TCP包并建立连接</strong></li></ol><ul><li>封装成TCP包，建立TCP连接(TCP的三次握手)</li></ul><ol start="4"><li><strong>客户机发送请求命令</strong></li></ol><ul><li>客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)，协议版本号，后面是MIME信息包括请求修饰符，客户机信息和内容。</li></ul><ol start="5"><li><strong>服务器响应</strong></li></ol><ul><li>服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号，一个成功或错误的代码，后面是MIME信息包括服务器信息，实体信息和可能的内容。</li></ul><ol start="6"><li><strong>服务器关闭TCP连接</strong></li></ol><ul><li>服务器关闭TCP连接，一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<code>Connection:keep-alive</code>,TCP连接在发送后任然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ul><p><img src="/2019/07/19/网络/1563437731001.png" alt="1563437731001"></p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul><li><p>HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443。过程大致如下：</p><ol><li><p><strong>建立连接获取证书</strong></p><ol><li>SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其他一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）。</li></ol></li><li><p><strong>证书验证</strong></p><ol><li>Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li></ol></li><li><p><strong>数据加密和传输</strong></p><ol><li>如果确认证书有效，那么生成对称密钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li></ol><p><img src="/2019/07/19/网络/1563438724225.png" alt="1563438724225"></p></li></ol></li></ul><h4 id="SSL工作原理"><a href="#SSL工作原理" class="headerlink" title="SSL工作原理"></a>SSL工作原理</h4><ul><li><p><strong>RSA握手协议</strong></p><ul><li>Client 给出协议版本号、一个客户端生成的随机数（Client random），<br>以及客户端支持的加密方法。</li><li>Server 确认双方使用的加密方法，并给出数字证书、以及一个服务器<br>生成的随机数（Server random）。</li><li>Client 确认数字证书有效，然后生成一个新的随机数（Premaster secr<br>et），并使用数字证书中的公钥，加密这个随机数，发给 Server。</li><li>Server 使用自己的私钥，获取 Client 发来的随机数（即 Premaster se<br>cret）。</li><li>Client 和 Server 根据约定的加密方法，使用前面的三个随机数，生成” 对话密钥”（session key），用来加密接下来的整个对话过程。</li></ul></li><li><p><strong>记录协议</strong></p><ul><li>记录协议 对数据传输提供保密性和完整性。</li><li>记录协议过程。</li></ul><p><img src="/2019/07/19/网络/InkedSnipaste_2019-07-19_13-45-11_LI.jpg" alt="InkedSnipaste_2019-07-19_13-45-11_LI"></p></li><li><p><strong>警报协议</strong></p><ul><li>如果是警告，则值为1，如果是致命错误，则值为2。</li></ul></li></ul><h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><table><thead><tr><th>方法</th><th>描述</th><th>HTTP版本</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td><td>1.0</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（如：提交表单或上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有的资源的修改。</td><td>1.0</td></tr><tr><td>HEAD</td><td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td><td>1.0</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td><td>1.1</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td><td>1.1</td></tr><tr><td>PATCH</td><td>是对PUT方法的补充，用来对已知资源进行局部更新</td><td>1.1</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的信息</td><td>1.1</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td><td>1.1</td></tr><tr><td>CONNECT</td><td>HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td><td>1.1</td></tr></tbody></table><h4 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h4><ul><li>GET被强制服务器支持</li><li>浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li><li>GET请求发送的数据更小(IE2048/firefox65536/chrome8182/opera190000字符)</li><li>GET请求是不安全的</li><li>GET请求是幂等的</li><li>POST请求不能被缓存</li><li>POST请求相对于GET请求是安全的</li><li>以下情况，请使用POST请求<ul><li>无法使用缓存文件(更新服务器上的文件或数据库)</li><li>向服务器发送大量数据(POST没有数据量限制)</li><li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li></ul></li><li>GET使用URL或Cookie传参。而POST将数据放在Body中。GET的URL会有长度上的限制，则POST的数据则可以非常大。POST比GET安全，因为数据在地址栏上不可见。</li><li>幂等<ul><li>从定义上看，HTTP方法的幂等性是指一次或多次请求某一个资源应该具有相同的副作用。</li><li>POST并不是幂等的。</li></ul></li></ul><h4 id="Http长连接-短连接"><a href="#Http长连接-短连接" class="headerlink" title="Http长连接/短连接"></a>Http长连接/短连接</h4><ul><li><strong>无状态</strong>：HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议(无连接)。</li><li><strong>长连接</strong>：从HTTP1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<code>Keep-Alive</code>不会永久保持连接，他有一个保持时间，可以在不同的服务器软件(如：Apache)中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li><li><strong>短链接</strong>：在HTTP1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问某个HTML或其他类型的web页中包含有其他的web资源(如:js，图像，css等)，每遇到这样一个web资源，浏览器就会重新建立一个HTTP会话。</li><li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</li></ul><h4 id="什么时候用长连接，短连接"><a href="#什么时候用长连接，短连接" class="headerlink" title="什么时候用长连接，短连接"></a>什么时候用长连接，短连接</h4><ul><li><strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况下</strong>。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。</li><li>短连接一般用于web网站的http服务，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。</li></ul><h4 id="http1-1和1-0的区别"><a href="#http1-1和1-0的区别" class="headerlink" title="http1.1和1.0的区别"></a>http1.1和1.0的区别</h4><ul><li>1.0需要<code>keep-alive</code>参数来告知服务器要建立一个长连接，而1.1默认支持长连接。</li><li>1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401时候，客户端就可以不用发送请求body了，节约了带宽。</li><li>host域，1.0没有host域，1.1才开始支持</li><li>带宽优化及网络连接的使用，1.0中，存在一些浪费带宽的现象，如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，1.1则在请求头引入<code>range头域</code>，它允许只请求资源的某个部分，即返回码是206，这样方便了开发者自由的选择以便充分利用带宽和连接。</li></ul><h4 id="http2-0和1-0的区别"><a href="#http2-0和1-0的区别" class="headerlink" title="http2.0和1.0的区别"></a>http2.0和1.0的区别</h4><ul><li><strong>新的二进制</strong>(Binary Format):Http1.x的解析是基于文本的。基于文本协议的格式解析存在缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑Http2.0的协议解析决定采用二进制形式，实现方便且健壮。</li><li><strong>多路复用</strong>(MultiPlexing):即连接共享，建立起一个连接请求后，可以在这个链接上一直发送，不要等待上一次发送完并且收到回复后才能发送下一个(Http1.0是这样的)，是可以同时发送多个请求，互相并不干扰。</li><li><strong>header压缩</strong>:Http1.x的header带有大量信息，而且每次都要重复发送，Http2.0利用了<code>Hpack</code>对消息进行压缩传输，客户端和服务器维护一个动态链表(当一个头部没有出现的时候，就插入，已经出现了就用表中的索引值进行代替)，避免了重复header的传输，又减少了需要传输的大小。</li><li><strong>服务端推送</strong>(server push):就是客户端请求html的时候，服务器顺带把此html需要的css,js也一起发送给客户端，而不像1.0中需要请求一次html，然后再请求一次css，然后再请求一次js。</li></ul><h4 id="http与https区别"><a href="#http与https区别" class="headerlink" title="http与https区别"></a>http与https区别</h4><ul><li>https 协议需要申请证书，一般免费证书较少，因而需要一定费用。</li><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl加密传输协议</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li><li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。<ul><li>HTTP 的 URL 以 http:// 开头 ，而 HTTPS 的 URL 以 https://<br>开头</li><li>HTTP 是不安全的，而 HTTPS 是安全的</li><li>在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层</li><li>HTTP 无需加密，而 HTTPS 对传输的数据进行加密</li><li>HTTP 无需证书，而 HTTPS 需要认证证书</li></ul></li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ul><li>CDN一般包含<strong>分发服务系统，负载均衡系统和管理系统</strong>。</li></ul><p><img src="/2019/07/19/网络/CDN%E6%9E%B6%E6%9E%84.jpg" alt="CDN架构"></p><h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul><li>其基本工作单元就是各个<code>Cache</code>服务器。负责直接响应用户请求，将内容快速分发到用户；同时负责内容更新，保证和源站内容的同步。</li><li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务，流媒体加速服务，应用加速服务等。每个子服务系统都是分布式的服务集群，由功能类似，地域接近的分布部署的<code>Cache</code>集群组成。</li><li>在承担内容同步，更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个<code>Cache</code>设备的健康状况，响应情况，内容缓存状况等，以便管理调度系统能够根据设定的策略决定由那个<code>Cache</code>设备来响应用户的请求。</li></ul><h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul><li>负载均衡系统是整个CDN系统的中枢，负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li><li>使用分级实现，最基本的两级调度体系包括全局负载均衡(GSLB)和本地负载均衡(SLB)。</li><li>GSLB根据用户地址和用户请求的内容，<strong>主要根据就近性原则，确定向用户服务的节点。一般通过DNS解析或者应用层重定向(HTTP 3XX重定向)的方式实现。</strong></li><li>SLB主要负责节点内部的负载均衡。当用户请求从GSLB调度到SLB时，SLB会根据节点内各个Cache设备的工作状况和内容分布情况等对用户请求重定向。<strong>SLB的实现有四层调度（LVS），七层调度（Nginx）和链路负载调度等。</strong></li></ul><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul><li>分为运营管理和网络管理子系统。</li><li>网络管理系统实现对CDN系统的设备管理，拓扑管理，链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用web方式实现。</li><li>运营管理是对CDN系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集，整理，交付工作。<strong>包括用户管理，产品管理，计费管理，统计分析等。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络7层协议&quot;&gt;&lt;a href=&quot;#网络7层协议&quot; class=&quot;headerlink&quot; title=&quot;网络7层协议&quot;&gt;&lt;/a&gt;网络7层协议&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;物理层&lt;/strong&gt;：主要定义物理设备标准，如：网线，光纤接口类型，各种传输
      
    
    </summary>
    
      <category term="HTTP/TCP/IP" scheme="http://yoursite.com/categories/HTTP-TCP-IP/"/>
    
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
      <category term="tcp/ip" scheme="http://yoursite.com/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>Java并发补充</title>
    <link href="http://yoursite.com/2019/07/16/Java%E5%B9%B6%E5%8F%91%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2019/07/16/Java并发补充/</id>
    <published>2019-07-16T08:10:17.000Z</published>
    <updated>2019-07-20T14:08:17.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul><li><p>线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行，他的主要特点为：<strong>线程复用，控制最大并发数，管理线程</strong>。</p></li><li><p><strong>线程复用</strong></p><ul><li>每一个Thread的类都有一个start()方法，当调用start()启动线程时Java虚拟机会调用该类的run()方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。<strong>我们可以继承重写Thread类，在其start()方法中添加不断循环调用传递过来的Runnable对象</strong>。这就是线程池的实现原理。<strong>循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的</strong>。</li></ul></li><li><p><strong>线程池的组成</strong></p><ul><li>一般的线程池主要分为4个组成部分<ul><li>线程池管理器：用于创建并管理线程池。</li><li>工作线程：线程池中的线程。</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行。</li><li>任务队列：用于存放处理的任务，提供一种缓冲机制。</li></ul></li><li>Java中的线程池1是通过Executor实现的。</li></ul><p><img src="/2019/07/16/Java并发补充/1563331336349.png" alt="1563331336349"></p><ul><li><code>ThreadPoolExecutor</code>中的构造方法<ul><li><code>corePoolSize</code>：指定了线程池中的线程数量。</li><li><code>maximumPoolSize</code>:指定了线程池中的最大线程数量。</li><li><code>keepAliveTime</code>：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li><li><code>utnit</code>:keepAliveTime的单位。</li><li><code>workQueue</code>:任务队列，被提交但尚未被执行的任务。</li><li><code>threadFactory</code>:线程工厂，用于创建线程，一般使用默认值。</li><li><code>handler</code>:拒绝策略，当任务太多来不及处理，如何拒绝任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="keyword">this</span>(corePoolSize,maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>拒绝策略</strong></p><ul><li>线程池中的线程已经用完，无法继续为新任务服务，同时，等待队列也已经排满，再也塞不下新的任务，这时我们就需要拒绝策略机制合理的处理这个问题。</li><li>JDK内置的拒绝策略如下：<ul><li><code>AbortPolicy</code>:直接抛出异常，阻止系统正常运行。</li><li><code>CallerRunsPolicy</code>:只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li><li><code>DiscardOldestPolicy</code>:丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li><li><code>DiscardPolicy</code>:该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，这是最好的一种方案。</li><li>上述内置拒绝策略实现了<code>RejectedExecutionHandler</code>接口，若以上策略仍无法满足实际需要，完全可以自己扩展<code>RejectedExecutionHandler</code>接口。</li></ul></li></ul></li><li><p><strong>线程池工作过程</strong></p><ol><li>线程池刚创建时，里面没有一个线程，任务队列是作为参数传递进来的，不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用execute()方法添加一个任务时，线程池会做以下判断：<ol><li>如果正在运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行这个队列。</li><li>如果正在运行的线程数大于或等于<code>corePoolSize</code>,那么将这个任务放入队列。</li><li>如果这时队列满了，而且正在运行的线程数小于<code>maximumPoolSize</code>，那么还要创建非核心线程立即运行这个任务。</li><li>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>,那么线程池会抛出异常<code>RejectExecutionException</code>。</li></ol></li><li>当一个线程完成任务时，他会从队列中取出下一个任务来执行。</li><li>当一个线程无事可做时，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li></ol></li></ul><h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><ul><li><p>在阻塞队列中，线程阻塞分为两种情况。</p><ul><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。</li></ul><p><img src="/2019/07/16/Java并发补充/1563336228088.png" alt="1563336228088"></p><ul><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。</li></ul><p><img src="/2019/07/16/Java并发补充/1563336249697.png" alt="1563336249697"></p></li></ul><h4 id="阻塞队列主要方法"><a href="#阻塞队列主要方法" class="headerlink" title="阻塞队列主要方法"></a>阻塞队列主要方法</h4><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><ul><li>抛出异常：抛出一个异常。</li><li>特殊值：返回一个特殊值(null或false，视情况而定)。</li><li>阻塞：在成功操作之前，一直阻塞线程。</li><li>超时：放弃前只在最大的时间内阻塞。</li></ul><ul><li><p><strong>插入操作</strong></p><ul><li><code>public abstract boolean add(E paramE)</code>:将指定元素插入到此队列中(如果立即可行且不会违反容量限制)，成功时返回true,如果当前没有可用的空间，则抛出<code>IllegalStateException</code>.如果该元素是NULL，则会抛出<code>NullPointerException</code>异常。</li><li><code>public abstract boolean offer(E paramE)</code>:将指定元素插入此队列中(如果立即可行且不会违反容量限制)，成功时返回<code>true</code>，如果当前没有可用的空间，则返回<code>false</code>。</li><li><code>public abstract void put(E paramE) throws InterruptedException</code>:将指定元素插入到此队列中，将等待可用的空间(如果有必要)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> checkNotNull(paramE);</span><br><span class="line"> ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;</span><br><span class="line"> localReentrantLock.lockInterruptibly();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length)</span><br><span class="line">     <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">     enqueue(paramE);</span><br><span class="line">         localReentrantLock.unlock();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> localReentrantLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>offer(E o,long timeout,TimeUnit unit)</code>:可以设定等待时间，如果在指定的时间内，还不能往队列中加入<code>BlockingQueue</code>,则返回失败。</li></ul></li><li><p><strong>获取数据操作</strong></p><ul><li><code>poll(time)</code>取出<code>BlockingQueue</code>里面排在首位的对象，若不能立即取出，则可以等待time参数规定的时间，取不到时返回<code>null</code>。</li><li><code>poll(long timeout,TimeUnit unit)</code>:从<code>BlockingQueue</code>取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，返回失败。</li><li><code>take()</code>:取出<code>BlockingQueue</code>里排在首位的对象，若<code>BlockingQueue</code>为空，阻断进入等待状态直到<code>BlockintQueue</code>有新的数据被加入。</li><li><code>drainTo()</code>:一次性从<code>BlockingQueue</code>获取所有可用的数据对象(还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率，不需要多次分批加锁或释放锁。</li></ul></li></ul><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul><li><code>ArrayBlockingQueue</code>:由数组结构组成的有界阻塞队列(公平，非公平)。<ul><li>用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序，<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平的访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素，通常情况下为了保证公平性会降低吞吐量，我们可以使用代码创建一个公平的阻塞队列<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true)；</code>。</li></ul></li><li><code>LinkedBlockingQueue</code>:由链表结构组成的有界阻塞队列(两个独立锁提高并发)。<ul><li>基于链表的阻塞队列，同<code>ArrayListBlockQueue</code>类似，此队列按照先进先出(FIFO)的原则对元素进行排序，而<code>LinkedBlockingQueue</code>之所以能高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<code>LinkedBlockingQueue会默认一个类似无限大小地容量(Integer.MAX_VALUE)</code>。</li></ul></li><li><code>PriorityBlockingQueue</code>:支持优先级排序的无界阻塞队列(compareTo排序实现优先)。<ul><li>是一个支持优先队列的无界队列，默认情况下元素采取自然顺序升序排列，可以自定义实现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序，需要注意的是不能保证同优先级元素的顺序。</li></ul></li><li><code>DelayQueue</code>:使用优先级队列实现的无界阻塞队列(缓存失效，定时任务)。<ul><li><strong>是一个支持延迟获取元素的无界阻塞队列</strong>，队列使用<code>PriorityQueue</code>来实现，队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素，我们可以将<code>DelayQueue</code>运用到如下场景<ul><li>缓存系统的设计，可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行。比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li></ul></li></ul></li><li><code>SynchronousQueue</code>:不存储元素的阻塞队列(不存储数据，可用于传递数据)。<ul><li><strong>是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素</strong>。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li></ul></li><li><code>LinkedTransferQueue</code>:由链表结构组成的无界阻塞队列。<ul><li>是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列，相对于其他阻塞队列，LinkedTransferQueue多了<code>tryTransfer()和transfer()</code>方法</li><li><strong>transfer()方法</strong>：如果当前有消费者正在等待接收元素(消费者使用take()方法或者带时间限制的poll()方法时)，<strong>transfer()方法可以把生产者传入的元素立即transfer给消费者.如果没有消费者在等待接收元素，transfer()方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</strong></li><li><strong>tryTransfer()方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者，如果没有消费者等待接收元素，则返回false。和<code>transfer()</code>的区别是<code>tryTransfer()</code>无论消费者是否接收，方法立即返回，而<code>transfer()</code>是必须等到消费者消费了才返回。</li><li>对于带有时间限制的<code>tryTransfer(E e,long timeout,TimeUnit unit)</code>方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li></ul></li><li><code>LinkedBlockingDeque</code>:由链表结构组成的双向阻塞队列。<ul><li>是一个由链表组成的<strong>双向阻塞队列</strong>。<strong>所谓的双向队列指的是你可以从队列的两端插入和移除元素</strong>。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst(),addLast(),offerFirst(),offerLast(),peekFirst(),peekLast()</code>等方法，以First结尾的方法，表示插入，获取或移除双端队列的第一个元素，以Last结尾的方法，表示插入，获取和移除双端队列的最后一个元素。另外插入方法add()等同于addLast(),移除方法remove()等同于removeFirst()。但是take()方法却等同于takeFirst()。</li><li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀，另外双向队列可以用在“工作窃取”模式中。</li></ul></li></ul><h2 id="CyclicBarrier-CountDownLatch和Semaphore的用法"><a href="#CyclicBarrier-CountDownLatch和Semaphore的用法" class="headerlink" title="CyclicBarrier,CountDownLatch和Semaphore的用法"></a>CyclicBarrier,CountDownLatch和Semaphore的用法</h2><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h4><ul><li><code>CountDownLatch</code>位于java.util.concurrent包下，使用它可以实现类似计数器的功能。如有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以利用CountDownLatch来实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"等待2个子线程执行完毕"</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)"></a>CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</h4><ul><li><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code>可以被重用，暂且把这个状态叫做barrier,当调用<code>await()</code>之后，线程就处于barrier。CyclicBarrier中最重要的方法就是<code>await()</code>,它有两个重载版本：</p><ol><li><code>public int await()</code>:用来挂起当前线程，直至所有线程都到达<strong>barrier状态</strong>再同时执行后续任务。</li><li><code>pubilc int await(long timeout,TimeUnit unit)</code>:让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><ul><li><p><strong>Semaphore可以控制同时访问的线程个数</strong>，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。</p></li><li><p>Semaphore常用的方法：</p><ol><li><code>public void acquire()</code>:用来获取一个许可，若无许可能够获取，则会一直等待，直到获得许可。</li><li><code>public void acquire(int permits)</code>:获取permits许可。</li><li><code>public void release()</code>:释放许可(在释放许可之前，必须先获得许可)。</li><li><code>public void release(int permits)</code>:释放permits个许可。</li></ol></li><li><p>上述4个方法都会被阻塞，如果想立即得到执行结果，可以使用下述方法。</p><ol><li><code>public boolean tryAcquire()</code>:尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li><li><code>public boolean tryAcquire(long timeout,TimeUnit unit)</code>:尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。</li><li><code>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)</code>:尝试获取permits个许可，若在指定的时间内获取成功，则返回true，否则返回false。</li><li><code>public boolean tryAcquire(int permits)</code>:尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li><li>还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完</span></span><br><span class="line"><span class="comment"> 了，其他工人才能继续使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，<strong>CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</strong></li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul><li><strong><em>newCachedThreadPool</em></strong><ul><li>创建一个可根据需要创建新线程的线程池，但是在以前已经构造的线程可用时将重用它们，对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能，调用<strong>execute</strong>将重用以前构造的线程(如果线程可用)，如果现有线程没有可用的，则创建一个新的线程并添加到线程池中，终止并从缓存中移除那些已有60秒未被使用的线程，因此，长时间保持空闲的线程池不会使用任何资源。</li></ul></li><li><strong>newFixedThreadPool</strong><ul><li>创建一个可重用固定线程数的线程池，以共享的无界队列来运行这些线程，在任意点，在大多数nThreads线程会处于处理任务的活动状态，如果在所有线程处于活动时提交附加任务，则在有可用线程之前，附加1任务将在队列中等待，如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个线程将代替它执行后续的任务(如果需要),在某个线程被显式地关闭之前，池中的线程将一直存在。</li></ul></li><li><strong>newScheduledThreadPool</strong><ul><li>创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。</li></ul></li><li><strong>newSingleThreadExecutor</strong><ul><li><strong>Executors.newSingleThreadExecutor()</strong>返回一个线程池(只有一个线程),这个线程池可以在线程死后(或发生异常)重新启动一个线程来代替原有的线程继续执行下去。</li></ul></li></ul><h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p><img src="/2019/07/16/Java并发补充/1563288982967.png" alt="1563288982967"></p><ul><li><strong>线程等待(wait)</strong><ul><li>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁，因此，wait()方法一般用在同步方法或同步代码块中。</li></ul></li><li><strong>线程睡眠(sleep)</strong><ul><li>sleep导致当前线程休眠，与wait不同的是sleep不会释放当前占用的锁，sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态。</li></ul></li><li><strong>线程让步(yield)</strong><ul><li>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片，一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li></ul></li><li><strong>线程中断(interrupt)</strong><ul><li>调用interrupt()方法并不会中断一个正在运行的线程，就是说处于Running状态的线程并不会因为被中止而被终止，仅仅改变了内部维护的中断标识位而已。</li><li>若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出<strong>InterruptedException</strong>,从而使线程提前结束TIMED-WATING状态。</li><li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li><li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</li></ul></li><li><strong>Join等待其他线程终止</strong><ul><li>join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待CPU的执行。</li></ul></li><li><strong>线程唤醒(notify)</strong><ul><li>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与该对象上主动同步的其他所有线程进行竞争，类似的方法还有notifyAll(),唤醒在此监视器上等待的所有线程。</li></ul></li><li><strong>其他常用方法</strong><ul><li><code>isAlive()</code>:判断一个线程是否存活。</li><li><code>activeCount()</code>:程序中活跃的线程数。</li><li><code>enumerate()</code>:枚举程序中的线程。</li><li><code>currentThread()</code>:得到当前线程。</li><li><code>isDaemon()</code>:一个线程是否为守护线程。</li><li><code>setDaemon()</code>:设置一个线程为守护线程。</li><li><code>setName()</code>:为线程设置名称。</li><li><code>setPriority()</code>:设置一个线程的优先级。</li><li><code>getPriority()</code>:获得一个线程的优先级。</li></ul></li></ul><h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><ul><li><strong>同步锁</strong><ul><li>当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种问题的出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据，Java中可已使用synchronized关键字来取得一个对象的同步锁。</li></ul></li><li><strong>死锁</strong><ul><li>就是多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。</li></ul></li></ul><h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><ul><li>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</li></ul><h4 id="变量可见性"><a href="#变量可见性" class="headerlink" title="变量可见性"></a>变量可见性</h4><ul><li>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</li></ul><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul><li>volatile禁止了指令重排。</li></ul><h4 id="比Synchronized更轻量级的同步锁"><a href="#比Synchronized更轻量级的同步锁" class="headerlink" title="比Synchronized更轻量级的同步锁"></a>比Synchronized更轻量级的同步锁</h4><ul><li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比Synchronized更轻量级的同步机制，volatile适合于这种场景：“<strong>一个变量被多个线程共享，线程直接给这个变量赋值</strong>”。</li><li>当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读写变量都从内存中读，跳过CPU cache这一步。</li></ul><p><img src="/2019/07/16/Java并发补充/1563354774642.png" alt="1563354774642"></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<ol><li>对变量的些操作不依赖于当前值(如i++)，或者说是单纯的1变量赋值(boolean flag = true)</li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用<code>volatile</code>。</li></ol></li></ul><h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><ul><li>进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性JVM解决了可见性和有序性的问题，而锁解决了原子性的问题，在理想的情况下我们希望做到“同步”和“互斥”，有以下的实现方式.</li></ul><h4 id="将数据抽象为一个类，并将数据的操作作为这个类的方法"><a href="#将数据抽象为一个类，并将数据的操作作为这个类的方法" class="headerlink" title="将数据抽象为一个类，并将数据的操作作为这个类的方法"></a>将数据抽象为一个类，并将数据的操作作为这个类的方法</h4><ul><li>将数据抽象为一个类，并将对这个数据的操作作为这个类的方法，这样可以很容易做到同步，只要在方法上加上<code>synchronized</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data= data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.dec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(add).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable对象作为一个类的内部类"><a href="#Runnable对象作为一个类的内部类" class="headerlink" title="Runnable对象作为一个类的内部类"></a>Runnable对象作为一个类的内部类</h4><ul><li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><ul><li>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</li></ul><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ol><li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</li><li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li><li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null</code>;</li></ol><p><img src="/2019/07/16/Java并发补充/1563357402171.png" alt="1563357402171"></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>最常用于解决数据库连接，Session管理等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">     Session s = (Session) threadSession.get(); </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">             s = getSessionFactory().openSession(); </span><br><span class="line">             threadSession.set(s); </span><br><span class="line">             &#125; </span><br><span class="line">     &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>都是用来协调多线程对共享对象，变量的访问。</li><li>都是可重入锁，同一线程可以多次获得同一个锁。</li><li>都保证了可见性和互斥性。</li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的<br>不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻<br>塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言<br>实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等</li></ol><h2 id="Volatile和Synchronized的区别"><a href="#Volatile和Synchronized的区别" class="headerlink" title="Volatile和Synchronized的区别"></a>Volatile和Synchronized的区别</h2><ol><li>volatile不会进行加锁操作。</li><li>volatile变量作用类似于同步变量读写操作。</li><li>volatile不如Synchronized安全。</li><li>volatile无法同时保证内存可见性和原子性。</li></ol><h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul><li>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li></ul><h4 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h4><ul><li>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</li><li>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</li></ul><h4 id="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><a href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成" class="headerlink" title="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"></a>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</h4><ul><li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li></ul><p><img src="/2019/07/16/Java并发补充/1563358149513.png" alt="1563358149513"></p><h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul><li>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</li></ul><h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><ul><li>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</li></ul><h4 id="JVM的线程调度实现-抢占式调度"><a href="#JVM的线程调度实现-抢占式调度" class="headerlink" title="JVM的线程调度实现(抢占式调度)"></a>JVM的线程调度实现(抢占式调度)</h4><ul><li>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</li></ul><h4 id="线程让出cpu的情况"><a href="#线程让出cpu的情况" class="headerlink" title="线程让出cpu的情况"></a>线程让出cpu的情况</h4><ol><li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li><li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li><li>当前运行线程结束，即运行完 run()方法里面的任务。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><ul><li><strong>先来先服务调度算法(FCDS)</strong><ul><li>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</li></ul></li><li><strong>短作业(进程)优先调度算法</strong><ul><li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</li></ul></li></ul><h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><ul><li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</li><li><strong>非抢占式优先权算法</strong><ul><li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li></ul></li><li><strong>抢占式优先权调度算法</strong><ul><li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li></ul></li><li><strong>高响应比优先调度算法</strong><ul><li>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</li></ul></li></ul><p><img src="/2019/07/16/Java并发补充/1563358860683.png" alt="1563358860683"></p><h4 id="基于时间片的轮询调度算法"><a href="#基于时间片的轮询调度算法" class="headerlink" title="基于时间片的轮询调度算法"></a>基于时间片的轮询调度算法</h4><ul><li><strong>时间片轮转法</strong><ul><li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</li></ul></li><li><strong>多级反馈队列调度算法</strong><ol><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li></ol></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h4 id="概念特性"><a href="#概念特性" class="headerlink" title="概念特性"></a>概念特性</h4><ul><li>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</li><li>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</li></ul><h4 id="原子包java-util-concurrent-atomic-锁自旋"><a href="#原子包java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包java.util.concurrent.atomic(锁自旋)"></a>原子包java.util.concurrent.atomic(锁自旋)</h4><ul><li>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">        <span class="keyword">return</span> current; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul><li>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li><li>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li><li>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</li></ul><h2 id="什么是AQS-抽象的队列同步器"><a href="#什么是AQS-抽象的队列同步器" class="headerlink" title="什么是AQS(抽象的队列同步器)"></a>什么是AQS(抽象的队列同步器)</h2><ul><li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</li></ul><p><img src="/2019/07/16/Java并发补充/1563360810227.png" alt="1563360810227"></p><ul><li>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br><strong>getState()，setState()，compareAndSetState()</strong>。</li><li>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li></ol></li></ul><h4 id="AQS资源共享方式"><a href="#AQS资源共享方式" class="headerlink" title="AQS资源共享方式"></a>AQS资源共享方式</h4><ul><li><strong>Exclusive独占资源-ReentrantLock</strong><ul><li>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</li></ul></li><li><strong>Share 共享资源-Semaphore/CountDownLatch</strong><ul><li>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</li></ul></li></ul><h4 id="同步器的实现ABS核心-state资源状态计数"><a href="#同步器的实现ABS核心-state资源状态计数" class="headerlink" title="同步器的实现ABS核心(state资源状态计数)"></a>同步器的实现ABS核心(state资源状态计数)</h4><ul><li>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</li></ul><h4 id="ReentrantReadWriteLock实现独占和共享两种方式"><a href="#ReentrantReadWriteLock实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock实现独占和共享两种方式"></a>ReentrantReadWriteLock实现独占和共享两种方式</h4><ul><li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="-java -并发" scheme="http://yoursite.com/tags/java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Collection总结</title>
    <link href="http://yoursite.com/2019/07/15/Collection%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/15/Collection总结/</id>
    <published>2019-07-15T09:02:37.000Z</published>
    <updated>2019-07-20T14:07:39.842Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="集合架构图"></p><h2 id="图中大体概述"><a href="#图中大体概述" class="headerlink" title="图中大体概述"></a>图中大体概述</h2><ul><li>Iterator:可以通过迭代器遍历集合中的数据</li><li>Collection:是集合list,set,Queue的最基本的接口</li><li>Map：是映射表的基础接口</li></ul><h4 id="List接口详解"><a href="#List接口详解" class="headerlink" title="List接口详解"></a>List接口详解</h4><ul><li><p>List作为有序的Collection的代表，共有三个实现类，分别为<strong>ArrayList</strong>,<strong>LinkedList</strong>,<strong>Vector</strong>。</p></li><li><p><strong>ArrayList</strong></p><ul><li><p>内部是通过数组实现的，它允许对元素进行快速随机访问，缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中，当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制，移动，代价比较高，因此，它适合于随机查找与遍历，不适合插入和删除。</p><p><img src="/2019/07/15/Collection总结/1563183452932.png" alt="1563183452932"></p></li></ul></li><li><p><strong>LinkList</strong></p><ul><li><p>内部是双链表结构存储数据，适合数据的插入与删除，随机访问和遍历速度比较慢，此外，还提供了List接口中没有定义的方法，专门用于操作表头和表位元素，可以当作堆栈，队列和双向队列使用。</p><p><img src="/2019/07/15/Collection总结/1563183654460.png" alt="1563183654460"></p></li></ul></li><li><p><strong>Vector</strong></p><ul><li>与ArrayList一样，也是通过数组结构实现的，不同于它的是Vector支持线程的同步，避免多线程同时而引起的不一致性，但实现同步需要很高的花费，因此，效率不及ArrayList。</li></ul></li><li><p><strong>List简单总结</strong></p></li></ul><table><thead><tr><th>名称</th><th>底层结构</th><th>优缺点</th><th>线程安全性</th><th>扩容</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组</td><td>查询快 ，插入/删除慢</td><td>不安全</td><td>当前容量*1.5+1</td></tr><tr><td>LinkList</td><td>双链表</td><td>插入/删除快，查找慢</td><td>不安全</td><td>———–</td></tr><tr><td>Vector</td><td>数组</td><td>查询快，插入/删除慢</td><td>安全</td><td>默认一倍扩容</td></tr></tbody></table><h4 id="Set集合详解"><a href="#Set集合详解" class="headerlink" title="Set集合详解"></a>Set集合详解</h4><ul><li><p>Set重视元素的唯一性，用于存储无序(存和取的顺序不一定相同)元素，值不能重复，根据对象的hashCode值进行判断的，如果想要让两个对象视为相等的，就必须覆盖Object的hashCode和equals方法。它的主要实现类：<strong>HashSet</strong>，<strong>TreeSet</strong>，<strong>LinkHashSet</strong>。</p></li><li><p><strong>HashSet</strong></p><ul><li>HashSet存储元素的顺序不是按照存入时的顺序，而是按照哈希值来存取数据的，元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先会判断两个元素的哈希值，如果哈希值一样，再比较equals，如果equals相等就视为同一个元素，否则就不是同一个元素。</li><li>哈希值相同equals为false的元素的存储问题，当出现这种情况是会在相同的哈希值下顺延，也就是哈希一样的存一列，HashSet通过hashCode值来确定元素在内存中的位置，一个hashCode位置上可以存放多个元素。</li></ul></li><li><p><strong>TreeSet</strong></p><ul><li>TreeSet是使用二叉树对新add()的对象按照指定的顺序排序(升序，降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li><li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</li><li>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序。</li><li>比较次对象与指定对象的顺序，如果该对象小于，等于或大于指定对象，则分别返回负整数，零或正整数。</li></ul></li><li><p><strong>LinkHashSet</strong></p><ul><li><p>LinkHashSet继承HashSet和LinkedHashMap来实现的，LinkedHashSet底层使用LinkHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p><table><thead><tr><th>名称</th><th>底层结构</th><th>优缺点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashSet</td><td>HashMap</td><td>存取快，排列无序，不可重复,可为null</td><td>不安全</td></tr><tr><td>TreeSet</td><td>二叉树</td><td>排列有序，不可重复</td><td>安全</td></tr><tr><td>LinkHashSet</td><td>Hash表+双向链表</td><td>排列有序，不可重复</td><td>不安全</td></tr></tbody></table></li></ul></li></ul><h4 id="Map集合详解"><a href="#Map集合详解" class="headerlink" title="Map集合详解"></a>Map集合详解</h4><ul><li><p><strong>HashMap</strong></p><ul><li>HashMap(1.7)是数组和链表的结合体，数组每个元素存的是链表的头结点，往hashmap里面放键值对的时候先得到key的hashcode，然后重新计算hashcode，然后与length-1按位与，计算数组下标1，如果该下标对应的链表为空，则直接把键值对作为链表头结点，如果不为空，则1遍历链表看是否有key值相同，有就把value替换，没有就把该对对象作为链表的第一个节点，原有的节点为它的后续节点。</li></ul><p><img src="/2019/07/15/Collection总结/Inked1.7_LI.jpg" alt="Inked1.7_LI"></p><ul><li><p>HashMap(1.8)是数组+链表+红黑树，当链表长度&gt;=8时转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入，删除，查找等算法。</p><p><img src="/2019/07/15/Collection总结/1563193744210.png" alt="1563193744210"></p></li><li><p>HashMap扩容</p><ul><li>初始容量16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。</li><li>扩容机制：使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有的Entry数的元素拷贝到新的Entry数组中，Java1.7重新计算每个元素在数组中的位置，Java1.8中不是从新计算，而是使用的是2次幂的扩展，所以，元素的位置要么是在原来的位置，要么是在原位置再移动2次幂的位置在扩展HashMap的时候，不需要像1.7的实现那样重新计算hash，只需要看看原来的hash值新增加的那个bit是1还是0就行了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</li></ul></li><li><p>HashMap为什么线程不安全(hash碰撞和扩容导致)</p><ul><li>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。加入A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</li><li>删除键值对的代码如上：当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写回到该数组位置去，其实写回的时候可能其他的线程已经把这个位置给修改过了，就会覆盖其他线程的修改当多个线程同时检测到总数量超过门限制的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有一个线程生成新的数组被赋给table变量，其他线程的均会丢失，而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</li><li>想要实现线程安全，那么就要调用collections类的静态方法<strong>synchronizeMap()</strong>实现</li></ul></li><li><p><strong>HashTable</strong></p><ul><li>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</li></ul></li><li><p><strong>TreeMap</strong></p><ul><li>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</li></ul></li><li><p><strong>LinkedHashMap</strong></p><ul><li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li></ul></li><li><p><strong>ConcurrentHashMap</strong></p><ul><li><p>Segment</p><ul><li>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。</li></ul></li><li><p>线程安全</p><ul><li>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。</li></ul><p><img src="/2019/07/15/Collection总结/1563194323007.png" alt="1563194323007"></p></li><li><p>并行度</p><ul><li>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</li></ul></li><li><p>Java8实现</p><ul><li>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</li></ul><p><img src="/2019/07/15/Collection总结/1563194333363.png" alt="1563194333363"></p></li></ul></li></ul></li></ul><table><thead><tr><th>名称</th><th>底层</th><th>优缺点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashMap</td><td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td><td>key/value都可为null，查询快，递增排序</td><td>不安全</td></tr><tr><td>HashTable</td><td>散列表</td><td>key和Value都不可为null，递减排序</td><td>安全</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>递增排序</td><td>不安全</td></tr><tr><td>ConcurrentHashMap</td><td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td><td>递增排序</td><td>安全</td></tr><tr><td>LinkedHashMap</td><td>链表+哈希</td><td>存取一致</td><td>不安全</td></tr></tbody></table><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li><strong>Iterator和ListIterator的区别</strong><ul><li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul></li><li><strong>快速失败(fail-fast)和安全失败(fail-safe)的区别</strong><ul><li>Iterator的安全失败是基于对底层集合做拷贝，因此，不受原集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下的所有类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全1失败的迭代器永远不会抛出这样的异常。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png&quot; alt=&quot;集合架构图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;图中大体概述&quot;&gt;&lt;a href=&quot;#图中大体概述&quot; 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JVM(五)GC分析</title>
    <link href="http://yoursite.com/2019/07/14/JVM-%E4%BA%94-GC%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/07/14/JVM-五-GC分析/</id>
    <published>2019-07-14T04:03:44.000Z</published>
    <updated>2019-07-20T14:08:58.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-GC分析"><a href="#Java-GC分析" class="headerlink" title="Java GC分析"></a>Java GC分析</h2><h4 id="什么是Java-GC"><a href="#什么是Java-GC" class="headerlink" title="什么是Java GC"></a>什么是Java GC</h4><ul><li>Java GC(Garbage Collection,垃圾收集,垃圾回收)机制,是Java与C++/C的主要区别之一,作为Java开发者,不需要专门编写内存回收和垃圾清理代码,对内存泄露和溢出问题,这是因为在Java虚拟机中,存在自动内存管理和垃圾收集机制,该机制对JVM中的内存进行标记,并确定那些内存需要回收,根据一定的回收策略,自动的回收内存,永不停息的保证JVM中的内存空间,防止出现内存泄漏和溢出问题，Java GC机制已经日益完善，几乎可以自动的为我们做绝大多数事情，但是，如果开发大型的软件开发，就必须要研究Java GC机制。</li><li>简单总结下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。</li></ul><h4 id="如何获取Java-GC日志"><a href="#如何获取Java-GC日志" class="headerlink" title="如何获取Java GC日志"></a>如何获取Java GC日志</h4><ul><li><p><strong>命令获取Java GC日志</strong></p><ul><li>Java自动的工具行命令，jstat可以动态的监控JVM内存的使用，统计垃圾回收的各项信息。</li><li>如：<code>jstat -gc</code>统计垃圾回收堆的行为</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gc.png" alt="gc"></p><ul><li>也可以设置时间打印(图中每100ms打印一次，共打印200次)</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gctime.png" alt="gctime"></p></li><li><p><strong>GC参数</strong></p><ul><li>JVM的GC日志的主要参数包括如下：<ul><li><code>-XX:+PrintGC</code>输出GC日志</li><li><code>-XX:+PrintGCDetails</code>输出GC的详细日志</li><li><code>-XX:+PrintGCTimeStamps</code>输出GC的时间戳(以基准时间的形式)</li><li><code>-XX:+PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如2019-7-14T17:17:17.177+0800)</li><li><code>-XX:PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</li></ul></li><li>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</li></ul></li><li><p><strong>Tomcat配置示例</strong></p><ul><li>在Tomcat的启动参数中添加JVM的相关参数，如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"><span class="string">-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"><span class="string">-Djava.awt.headless=true </span></span><br><span class="line"><span class="string">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"><span class="string">-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"><span class="string">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure><ul><li>参数概况<ul><li><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</li><li><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是<br>Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young<br>genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio<br>设置成比较大的值（比如65536)来做到。</li><li><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</li><li><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li><li><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code><br>设置gc日志的格式。</li><li><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔。</li><li><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代。</li></ul></li></ul><h4 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h4><ul><li>Young GC回收日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">18.093</span>+<span class="number">0800</span>: <span class="number">25.395</span>: [GC [PSYoungGen: <span class="number">274931</span>K-&gt;<span class="number">10738</span>K(<span class="number">274944</span>K)] <span class="number">371093</span>K-&gt;<span class="number">147186</span>K(<span class="number">450048</span>K), <span class="number">0.0668480</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.08</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure><ul><li>Full GC回收日志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">19.160</span>+<span class="number">0800</span>: <span class="number">25.462</span>: [Full GC [PSYoungGen: <span class="number">10738</span>K-&gt;<span class="number">0</span>K(<span class="number">274944</span>K)] [ParOldGen: <span class="number">136447</span>K-&gt;<span class="number">140379</span>K(<span class="number">302592</span>K)] <span class="number">147186</span>K-&gt;<span class="number">140379</span>K(<span class="number">577536</span>K) [PSPermGen: <span class="number">85411</span>K-&gt;<span class="number">85376</span>K(<span class="number">171008</span>K)], <span class="number">0.6763541</span> secs] [Times: user=<span class="number">1.75</span> sys=<span class="number">0.02</span>, real=<span class="number">0.68</span> secs]</span><br></pre></td></tr></table></figure><ul><li><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young<br>gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。</p></li><li><p>通过两张图非常明显看出GC日志构成：</p><ul><li>Young GC日志：</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/%E5%89%8D%E5%8D%8A%E6%AE%B5%E5%88%86%E6%9E%90.jpg" alt="前半段分析"></p><ul><li>Full GC日志：</li></ul></li></ul><p>![full GC_LI](JVM-五-GC分析/full GC_LI.jpg)</p></li></ul><h4 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h4><ul><li><p><strong>GChisto</strong></p><ul><li>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</li><li>配置好本地的jdk环境后，双击GChisto.jar，在弹出的输入框点击add选择gc.log日志。<br><img src="/2019/07/14/JVM-五-GC分析/gc1.jpg" alt="gc1"></li><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li></ul><p><img src="/2019/07/14/JVM-五-GC分析/gc2.jpg" alt="gc2"></p><ul><li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p></li><li><p>GC Timeline：显示整个时间线上的垃圾收集<img src="/2019/07/14/JVM-五-GC分析/gc3.jpg" alt="gc3"></p></li><li><p>这款工具已经不再维护了。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-GC分析&quot;&gt;&lt;a href=&quot;#Java-GC分析&quot; class=&quot;headerlink&quot; title=&quot;Java GC分析&quot;&gt;&lt;/a&gt;Java GC分析&lt;/h2&gt;&lt;h4 id=&quot;什么是Java-GC&quot;&gt;&lt;a href=&quot;#什么是Java-GC&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(四)JVM优化</title>
    <link href="http://yoursite.com/2019/07/13/JVM-%E5%9B%9B-JVM%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/07/13/JVM-四-JVM优化/</id>
    <published>2019-07-13T03:28:30.000Z</published>
    <updated>2019-07-20T14:08:50.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的JVM优化工具介绍"><a href="#常用的JVM优化工具介绍" class="headerlink" title="常用的JVM优化工具介绍"></a>常用的JVM优化工具介绍</h2><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>​    JVM Process Status Tool,显式指定系统内所有的HotSpot虚拟机进程.</p><ul><li><p><strong>命令格式</strong></p><p><code>jps [options] [hostid]</code></p></li><li><p><strong>option参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l:输出主类全名或jar路径</span><br><span class="line">-q:只输出LVMID</span><br><span class="line">-m:输出JVM启动时传递给main()的参数</span><br><span class="line">-v:输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure></li><li><p><strong>演示</strong></p></li></ul><p><img src="/2019/07/13/JVM-四-JVM优化/jps%E6%BC%94%E7%A4%BA.png" alt="jps演示"></p><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>​    jstat(JVM statisics Monitoring)是用于监视虚拟机运行时状态信息的命令,可以显示出虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据</p><ul><li><p><strong>命令格式</strong></p><p><code>jstat [option] LVMID [interval] [count]</code></p></li><li><p><strong>参数</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option]:操作参数</span><br><span class="line"><span class="function"> LVMID:本地虚拟机进程<span class="title">ID</span></span></span><br><span class="line"><span class="function">[<span class="title">interval</span>]:连续输出的时间间隔</span></span><br><span class="line"><span class="function">[<span class="title">count</span>]:连续输出的次数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>option参数讲解</strong></p><ol><li>class:监视类加载,卸载数量,总空间以及耗费的时间</li></ol></li></ul><p><img src="/2019/07/13/JVM-四-JVM优化/jstatclass.png" alt="jstatclass"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Loader:加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes:class</span>字节大小</span></span><br><span class="line"><span class="function"><span class="title">Unloaded</span>:未加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes</span>:未加载<span class="title">class</span>的字节大小</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:加载时间</span></span><br></pre></td></tr></table></figure><pre><code>2. compiler:输出JIT编译过的方法数量耗时等</code></pre><p><img src="/2019/07/13/JVM-四-JVM优化/compiler.png" alt="compiler"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compiled:编译数量</span></span><br><span class="line"><span class="function"><span class="title">Failed</span>:编译失败数量</span></span><br><span class="line"><span class="function"><span class="title">Invalid</span>:无效数量</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:编译耗时</span></span><br><span class="line"><span class="function"><span class="title">FailedType</span>:失败类型</span></span><br><span class="line"><span class="function"><span class="title">FailedMethod</span>:失败方法的全限定名</span></span><br></pre></td></tr></table></figure><ol start="3"><li>gc:垃圾回收堆的行为统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gc.png" alt="gc"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">PC 当前perm的容量 (KB)</span><br><span class="line">PU perm的使用 (KB)</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11660 5000 100</span><br><span class="line"><span class="meta">#</span> 每隔5000ms输出11660的gc情况,一共输出100次</span><br></pre></td></tr></table></figure><ol start="4"><li>gccapacity:与gc相同,不过还会输出Java堆各区域使用到的最大,最小空间</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gccapacity.png" alt="gccapacity"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure><ol start="5"><li>gcutil:同gc,不过输出的是已使用空间占总空间的百分比</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcutil.png" alt="gcutil"></p><ol start="6"><li>gccause:垃圾收集统计概述,附加最近两次垃圾回收事件到的原因</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gccause.png" alt="gccause"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LGCC:最近垃圾回收的原因</span></span><br><span class="line"><span class="function"><span class="title">GCC</span>:当前垃圾回收的原因</span></span><br></pre></td></tr></table></figure><ol start="7"><li>gcnew:统计新生代1的行为</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcnew.png" alt="gcnew"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure><ol start="8"><li>gcnewcapacity:新生代与其相应的内存空间的统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcnewcapacity.png" alt="gcnewcapacity"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NGC:当前年轻代的容量 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0CMX</span>:最大的<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0C</span>:当前<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">ECMX</span>:最大<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">EC</span>:当前<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br></pre></td></tr></table></figure><ol start="9"><li>gcold:统计旧生代的行为</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcold.png" alt="gcold"></p><ol start="10"><li>gcoldcapacity:统计旧生代的大小和空间</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/gcoldcapacity.png" alt="gcoldcapacity"></p><ol start="11"><li>printcompilation:hotspot编译方法统计</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/Snipaste_2019-07-13_16-55-48.png" alt="Snipaste_2019-07-13_16-55-48"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line"><span class="built_in">Type</span>：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul><li><p>命令格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump : 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat : to <span class="built_in">print</span> permanent generation statistics</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure></li><li><p>演示</p></li></ul><ol><li><p>dump常用格式</p><p><code>-dump::live,format=b,file=&lt;filename&gt; pid</code></p><p>dump堆到文件,format指定输出格式,live指是活着的对象,file指文件名</p></li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/dump.png" alt="dump"></p><ol start="2"><li>finalizerinfo:打印等待回收对象的信息</li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/info.png" alt="info"></p><p>​    可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行的finalizer方法的对象</p><ol start="3"><li><p>heap:打印heap的概要信息,GC使用的算法,heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">finalizerinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Number</span> <span class="title">of</span> <span class="title">objects</span> <span class="title">pending</span> <span class="title">for</span> <span class="title">finalization</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">heap</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">using</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">object</span> <span class="title">allocation</span>.</span></span><br><span class="line"><span class="function"><span class="title">Parallel</span> <span class="title">GC</span> <span class="title">with</span> 4 <span class="title">thread</span>(<span class="title">s</span>)//<span class="title">GC</span>方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Configuration</span>://堆内存初始化配置</span></span><br><span class="line"><span class="function">   <span class="title">MinHeapFreeRatio</span>         = 0</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapFreeRatio</span>         = 100</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapSize</span>              = 734003200 (700.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewSize</span>                  = 44564480 (42.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxNewSize</span>               = 244318208 (233.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">OldSize</span>                  = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewRatio</span>                 = 2</span></span><br><span class="line"><span class="function">   <span class="title">SurvivorRatio</span>            = 8</span></span><br><span class="line"><span class="function">   <span class="title">MetaspaceSize</span>            = 21807104 (20.796875<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">CompressedClassSpaceSize</span> = 1073741824 (1024.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxMetaspaceSize</span>         = 17592186044415 <span class="title">MB</span></span></span><br><span class="line"><span class="function">   <span class="title">G1HeapRegionSize</span>         = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Usage</span>://堆内存使用情况</span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Young</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function"><span class="title">Eden</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 34078720 (32.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 19266416 (18.373886108398438<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 14812304 (14.126113891601562<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   56.5350341796875% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">From</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 4417480 (4.212837219238281<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 825400 (0.7871627807617188<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   84.25674438476562% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.0% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Old</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 90128 (0.0859527587890625<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 89563120 (85.41404724121094<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.10052954244334796% <span class="title">used</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5507 <span class="title">interned</span> <span class="title">Strings</span> <span class="title">occupying</span> 497712 <span class="title">bytes</span>.</span></span><br></pre></td></tr></table></figure></li><li><p>histo:打印堆的对象统计,包括对象数,内存大小等等</p></li></ol><p><img src="/2019/07/13/JVM-四-JVM优化/histo.png" alt="histo"></p><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>​    jhat命令是与jmap搭配使用,用来分析jmap生成的dump,jhat内置了一个微型的HTTP/HTML服务器,生成dump的分析结果后,可以在浏览器中查看,在此需要注意,一般不会直接在服务器上进行分析,因为jhat是一个耗时并且耗费硬件资源的过程,一般把服务器生成的dump文件复制到本地或其他机器上进行分析.</p><ul><li><p>命令格式</p><p><code>jhat [dumpfile]</code></p></li><li><p>参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line"></span><br><span class="line">-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line"></span><br><span class="line">-port port-number 设置 jhat HTTP server 的端口号. 默认值 <span class="number">7000</span>.&gt;</span><br><span class="line"></span><br><span class="line">-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line"></span><br><span class="line">-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as <span class="keyword">not</span> being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line"></span><br><span class="line">-debug int 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line"></span><br><span class="line">-version 启动后只显示版本信息就退出&gt;</span><br><span class="line"></span><br><span class="line">-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure></li><li><p>演示</p><p>​    第一步:导出堆</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">dump:live</span>,<span class="title">file</span>=<span class="title">a.map</span> 11660</span></span><br><span class="line"><span class="function"><span class="title">Dumping</span> <span class="title">heap</span> <span class="title">to</span> <span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">a.map</span> ...</span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">dump</span> <span class="title">file</span> <span class="title">created</span></span></span><br></pre></td></tr></table></figure><p>​    第二步:分析堆文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jhat</span> <span class="title">a.map</span></span></span><br><span class="line"><span class="function"><span class="title">Reading</span> <span class="title">from</span> <span class="title">a.map</span>...</span></span><br><span class="line"><span class="function"><span class="title">Dump</span> <span class="title">file</span> <span class="title">created</span> <span class="title">Sat</span> <span class="title">Jul</span> 13 18:51:20 <span class="title">CST</span> 2019</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">read</span>, <span class="title">resolving</span>...</span></span><br><span class="line"><span class="function"><span class="title">Resolving</span> 2299776 <span class="title">objects</span>...</span></span><br><span class="line"><span class="function"><span class="title">Chasing</span> <span class="title">references</span>, <span class="title">expect</span> 459 <span class="title">dots</span>.............................</span></span><br><span class="line"><span class="function"><span class="title">Eliminating</span> <span class="title">duplicate</span> <span class="title">references</span>.........................</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">resolved</span>.</span></span><br><span class="line"><span class="function"><span class="title">Started</span> <span class="title">HTTP</span> <span class="title">server</span> <span class="title">on</span> <span class="title">port</span> 7000</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>.</span></span><br></pre></td></tr></table></figure><p>​    第三步:查看HTML</p><p><img src="/2019/07/13/JVM-四-JVM优化/1563015344059.png" alt="1563015344059"></p></li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>​    jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native<br>stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java<br>stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。    </p><ul><li><p>命令格式</p><p><code>jstack [option] LVMID</code></p></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure></li><li><p>演示</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jstack</span> -<span class="title">l</span> 11660|<span class="title">more</span></span></span><br><span class="line"><span class="function">2019-07-13 18:58:09</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">OpenJDK</span> 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (25.152-<span class="title">b11</span> <span class="title">mixed</span> <span class="title">mode</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 216" #550 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7ba000</span> <span class="title">nid</span>=0<span class="title">x1d5c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005dbef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.getTask</span>(<span class="title">ThreadPoolExecutor.java</span>:1066)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.runWorker</span>(<span class="title">ThreadPoolExecutor.java</span>:1127)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor</span>$<span class="title">Worker.run</span>(<span class="title">ThreadPoolExecutor.java</span>:617)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">Thread.java</span>:745)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">Locked</span> <span class="title">ownable</span> <span class="title">synchronizers</span>:</span></span><br><span class="line"><span class="function">        - <span class="title">None</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 215" #549 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7c0000</span> <span class="title">nid</span>=0<span class="title">x3b44</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005daef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">-- <span class="title">More</span>  --</span></span><br></pre></td></tr></table></figure><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>​    jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p></li><li><p>命令格式</p><p><code>jinfo [option] [args] LVMID</code></p></li><li><p>option参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure></li><li><p>演示</p></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">System</span> <span class="title">Properties</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">java.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">preload.project.path</span> = <span class="title">D</span>:/<span class="title">code</span>/<span class="title">IdeaProjects</span>/<span class="title">JVM</span></span></span><br><span class="line"><span class="function"><span class="title">sun.java.launcher</span> = <span class="title">SUN_STANDARD</span></span></span><br><span class="line"><span class="function"><span class="title">idea.config.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span></span></span><br><span class="line"><span class="function"><span class="title">sun.management.compiler</span> = <span class="title">HotSpot</span> 64-<span class="title">Bit</span> <span class="title">Tiered</span> <span class="title">Compilers</span></span></span><br><span class="line"><span class="function"><span class="title">sun.nio.ch.bugLevel</span> =</span></span><br><span class="line"><span class="function"><span class="title">idea.paths.selector</span> = <span class="title">IntelliJIdea2017</span>.3</span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.client.alive.path</span> = "<span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">AppData</span>\<span class="title">Local</span>\<span class="title">Temp</span>\<span class="title">kotlin</span>-<span class="title">idea</span>-4516842704025065651-<span class="title">is</span>-<span class="title">running</span>"</span></span><br><span class="line"><span class="function"><span class="title">os.name</span> = <span class="title">Windows</span> 10</span></span><br><span class="line"><span class="function"><span class="title">sun.boot.class.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">resources.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">rt.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">sunrsasign.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jsse.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jce.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">charsets.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jfr.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">classes</span></span></span><br><span class="line"><span class="function"><span class="title">sun.desktop</span> = <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">idea.plugins.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span>\<span class="title">plugins</span></span></span><br><span class="line"><span class="function"><span class="title">java.vm.specification.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">java.runtime.version</span> = 1.8.0<span class="title">_102</span>-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">io.netty.serviceThreadPrefix</span> = <span class="title">Netty</span></span></span><br><span class="line"><span class="function"><span class="title">user.name</span> = 严茂</span></span><br><span class="line"><span class="function"><span class="title">kotlin.incremental.compilation</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">idea.home.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">JetBrains</span>\<span class="title">IntelliJ</span> <span class="title">IDEA</span> 2017.3.4</span></span><br><span class="line"><span class="function"><span class="title">user.language</span> = <span class="title">zh</span></span></span><br><span class="line"><span class="function"><span class="title">jdt.compiler.useSingleThread</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">sun.boot.library.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">bin</span></span></span><br><span class="line"><span class="function"><span class="title">java.version</span> = 1.8.0<span class="title">_102</span></span></span><br><span class="line"><span class="function"><span class="title">user.timezone</span> = <span class="title">Asia</span>/<span class="title">Shanghai</span></span></span><br><span class="line"><span class="function"><span class="title">java.net.preferIPv4Stack</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.enabled</span> =</span></span><br><span class="line"><span class="function"><span class="title">sun.arch.data.model</span> = 64</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用的JVM优化工具介绍&quot;&gt;&lt;a href=&quot;#常用的JVM优化工具介绍&quot; class=&quot;headerlink&quot; title=&quot;常用的JVM优化工具介绍&quot;&gt;&lt;/a&gt;常用的JVM优化工具介绍&lt;/h2&gt;&lt;h4 id=&quot;jps&quot;&gt;&lt;a href=&quot;#jps&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(三)GC算法-垃圾收集器</title>
    <link href="http://yoursite.com/2019/07/12/JVM-%E4%B8%89-GC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/07/12/JVM-三-GC算法-垃圾收集器/</id>
    <published>2019-07-12T12:02:02.000Z</published>
    <updated>2019-07-20T14:08:41.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    垃圾收集通常被称之为”<strong>GC</strong>“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生成,随线程的销毁而销毁,栈帧随着方法的进入和退出做入栈和出栈操作,实现了自动的内存清理,因此,内存垃圾回收主要集中在java堆和方法区中,在程序运行期间,这部分的内存的分配和使用1都是动态的.</p><h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活一般有两种方式.</p><ul><li><p><strong>引用计数</strong>:每个对象有一个计数属性,新增一个引用时计数加1,引用释放时计数减1,计数为0时可以回收,此方法简单,无法解决对象相互循环引用的问题.</p></li><li><p><strong>可达性分析</strong>:从GC Roots开始向下搜寻,搜寻所走过的路径称之为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明对象是不可用的,不可达对象.</p></li><li><p>在Java中,GC Roots包括:</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中静态属性实体引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li></ul></li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    <strong>标记-清除</strong>算法分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象,之所以说它是最基础的收集算法,是因为后续的收集算法都是基于这种思路并对其缺点进行改善而得到的.</p><p>​    它主要有两个缺点:<strong>一是效率问题</strong>,标记和清除过程的效率都不高,<strong>二是空间问题</strong>,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致,当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作.</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​    GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>​    “<strong>分代收集</strong>”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    如果说收集算法是内存回收的方法论,垃圾收集器就是内存回收的具体实现</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>​    串行收集器是最稳定,效率最高的收集器,可能会产生较长的停顿,只使用一个线程去回收,新生代,老年代使用串行回收;新生代复制算法,老年代标记-压缩;垃圾收集的过程中会服务暂停.</p><p>参数控制:<code>-XX:+UseSerialGC</code>串行收集器</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="串行收集器"></p><p>​    ParNew收集器ParNew收集器就是Serial收集器的多线程版本,新生代并行,老年代串行;新生代复制算法,老年代标记-压缩.</p><p>参数控制:</p><ul><li><p><code>-XX:+UseParNewGC</code>ParNew收集器</p></li><li><p><code>-XX:ParallelGCThreads</code>限制线程数量</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt="串行收集器2"></p></li></ul><h4 id="Paralle收集器"><a href="#Paralle收集器" class="headerlink" title="Paralle收集器"></a>Paralle收集器</h4><p>​    Parallel   Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p><p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>​    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p><p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>​    从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>​        其中初始标记、重新标记这两个步骤仍然需要“Stop  The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>​    由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p><p>​    <strong>优点</strong>: 并发收集、低停顿<br>​    <strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p><p>参数控制:</p><p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）    </p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/CMS.jpg" alt="CMS"></p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>​    G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：</p><ul><li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></li><li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></li></ul><p>​        上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/G1.jpg" alt="G1"></p><p>​    G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p>收集步骤：</p><p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p><p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p><p>3、Concurrent  Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young  GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE2.png" alt="图2"></p><p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p><p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE3.png" alt="图3"></p><p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%A4%8D%E5%88%B6%E6%B8%85%E9%99%A4.jpg" alt="复制清除"></p><h4 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h4><table><thead><tr><th></th><th>新生代GC策略</th><th>老年代GC策略</th><th align="left">说明</th></tr></thead><tbody><tr><td>组合1</td><td>Serial</td><td>Serial Old</td><td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td></tr><tr><td>组合2</td><td>Serial</td><td>CMS+Serial Old</td><td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td></tr><tr><td>组合3</td><td>ParNew</td><td>CMS</td><td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 <code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td></tr><tr><td>组合4</td><td>ParNew</td><td>Serial Old</td><td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td></tr><tr><td>组合5</td><td>Parallel Scavenge</td><td>Serial Old</td><td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td></tr><tr><td>组合6</td><td>Parallel Scavenge</td><td>Parallel Old</td><td align="left">Parallel Old是Serial Old的并行版本</td></tr><tr><td>组合7</td><td>G1GC</td><td>G1GC</td><td align="left"><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code> #暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code> #暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小； <code>-XX:SurvivorRatio=6</code> #幸存区比例</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​    垃圾收集通常被称之为”&lt;strong&gt;GC&lt;/strong&gt;“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(二)java类的加载机制</title>
    <link href="http://yoursite.com/2019/07/11/JVM-%E4%BA%8C-java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/11/JVM-二-java类的加载机制/</id>
    <published>2019-07-11T10:18:10.000Z</published>
    <updated>2019-07-20T14:08:32.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1. 什么是类加载"></a>1. 什么是类加载</h3><ul><li>类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个<strong>java.lang.Class</strong>对象,用来封装类在方法区内的数据结构,类的加载的最终是位于堆中的<strong>Class对象</strong>,Class对象封装了类在方法区的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口.</li><li>类加载器并不需要等到某个类被初次主动使用时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件异常问题,类加载器必须在程序首次主动使用该类时才报告错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误.</li></ul><p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p><ul><li>加载.class文件的方式<ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip,jar等文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></li></ul><h3 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类的加载过程"></h3><ul><li>一个java类的完整生命周期会经历<strong>加载,连接,初始化,使用和卸载</strong>五个阶段,其中,加载,验证,准备和初始化这四个阶段发生的顺序是确定的,但解析阶段则不一定,在某些情况下可以在初始化阶段之后开始,这是为了支持Java的运行时绑定.此外还需要注意这里的几个阶段是按顺序开始的,而不是按顺序进行或完成,因为这些阶段通常都是互相交叉混合进行的,通常在一个阶段执行的过程中调用或激活另一个阶段.</li><li><strong>加载</strong><ul><li>查找并加载类的二进制数据是类加载过程的第一个阶段,在加载阶段,虚拟机需要完成以下三件事.<ul><li>通过一个类的全限定类名来获取其定义的二进制字节流.</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象,作为对方法区中这些数据的访问入口.</li></ul></li><li>相对于类加载的其他阶段而言,加载阶段是可控性最强的阶段,因此开发者即可以使用系统提供的类加载器来完成加载,也可以自定义自己的类加载器来完成加载.</li><li>加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象,这样便可以通过该对象访问方法区中的这些数据.</li></ul></li><li><strong>连接</strong><ul><li><strong>验证:确保被加载的类的正确性.</strong><ul><li>验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全,验证阶段大致会完成4个阶段的检验动作.<ul><li><strong>文件格式验证</strong>:验证字节流是否符合Class文件格式的规范,如:是否以<code>0xCAFEBABE</code>开头,主次版本号是否在当前虚拟机的处理范围之内,常量池中的常量是否有不被支持的阶段.</li><li><strong>元数据验证</strong>:对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求;如:这个类是否有父类,除了<code>java.lang.Object</code>之外的.</li><li><strong>字节码验证</strong>:通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的.</li><li><strong>符号引用验证</strong>:确保解析动作能正确执行.</li></ul></li><li>验证阶段是非常重要的,但不是必须的,它对程序运行期没有影响,如果所引用的类经过反复验证,那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间.</li></ul></li><li><strong>准备:为类的静态变量分配内存,并将其初始化为默认值</strong><ul><li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配,对于该阶段的注意事项.<ul><li>这时进行内存分配的仅包括类变量(static),而不包括实例变量,实例变量会在对象实例化时随着对象一块分配在Java堆中.</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如:0,0L,null,false等等),而不是被在Java代码中被显式地赋予的值.</li><li>如果类字节地字段属性表中存在<code>ConstantValue</code>属性,即同时被final和static修饰,那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值.</li></ul></li></ul></li><li><strong>解析:把类中的符号引用转换为直接引用</strong><ul><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用进行,符号引用就是一组符号来描述目标,可以是任何字面量.</li><li>直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄.</li></ul></li></ul></li><li><strong>初始化</strong><ul><li>初始化,为类的静态变量赋予正确的初始值,JVM负责对类进行初始化,主要对类变量进行初始化,在Java中对类变量进行初始值设定有两种方式.<ul><li>声明类变量是指定初始化</li><li>使用静态代码块为类变量指定初始值</li></ul></li><li>JVM初始化步骤<ul><li>加入这个类还没有被加载和连接,则程序先加载并连接该类</li><li>假如该类的直接父类还没有被1初始化,则先加载其直接父类</li><li>假如类中有初始化语句,则系统依次执行这些初始化语句</li></ul></li><li>类初始化时机:只有当对类的主动使用的时候才会导致类的初始化,类的主动使用包括以下六种<ul><li>创建类的实例,也就是new的方法</li><li>访问某个类或接口的静态变量,或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化某个类的子类,则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类,直接使用java.exe命令来运行某个主类.</li></ul></li></ul></li><li><strong>结束生命周期</strong><ul><li>在这几种情况下,Java虚拟机将结束生命周期<ul><li>执行了<code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul></li></ul></li></ul><h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>先看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">     System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>可以看到,没有获取到ExtClassLoader的父Loader,原因是Bootstrap Loadder是用C写的,找不到一个确定的返回父Loader的方法,于是就返回null.</p><ul><li>类加载器的层次关系图</li></ul><p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="类加载器"></p><ul><li><strong>启动类加载器</strong>:负责加载存放在<code>JDK/jre/lib</code>下,或被<code>-Xbootclasspath</code>参数指定的路径中的,并且能被虚拟机识别的类库,启动类加载器是无法被Java程序直接引用的.</li><li><strong>扩展类加载器</strong>:该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,他负责加载<code>JDK/jre/lib/ext</code>目录中,或者由<code>java.ext.dirs</code>系统变量指定的路径中的所由类库,开发者可以直接使用扩展类加载器.</li><li><strong>应用程序类加载器</strong>:该类加载器由<code>sun.misc.Launcher#AppClassLoader</code>来实现,它负责加载用户类路径所指定的类,开发者可以直接使用该类加载器,如果程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器.</li></ul><h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><ul><li><strong>全盘负责</strong>:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Classs也将由该类加载器负责载入,除非显式使用另外一个类加载器来载入.</li><li><strong>父类委派</strong>:先让父类加载器试图加载该类,只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类.</li><li><strong>缓存机制</strong>:缓存价值将会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,只有缓存区不存在,系统才会读取该类对应的二进制数据,并将其转换为Class对象,存入缓存区,这就是为什么修改Class后,必须重启JVM,程序的修改才会生效.</li></ul><h3 id="4-类的加载"><a href="#4-类的加载" class="headerlink" title="4. 类的加载"></a>4. 类的加载</h3><ul><li>类的加载有三种方式<ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2", false, loader); </span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块执行了);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><code>Class.forName()</code>:将类的.class文件加载到JVM中之外1,还会对类进行解释,执行类中的static块.</li><li><code>ClassLoader.loadClass()</code>:只干一件事,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newlnstance才会去执行static块</li><li><code>Class.forName(name,initialize,loader)带参函数也可以控制是否加载static块,并且只有调用newInstance()方法采用调用构造函数,创建类的对象</code>.</li></ul><h3 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h3><ul><li>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li><li>双亲委派机制<ul><li>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li><li>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li><li>如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li></ul></li><li>双亲委派模型意义<ul><li>系统类防止内存中出现多份同样的字节码</li><li>保证Java程序安全稳定运行</li></ul></li></ul><h3 id="6-自定义类加载器"><a href="#6-自定义类加载器" class="headerlink" title="6. 自定义类加载器"></a>6. 自定义类加载器</h3><ul><li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输<br>Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classData = loadClassData(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.ym.jvm.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意<ul><li>这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的.</li><li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式.</li><li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是类加载&quot;&gt;&lt;a href=&quot;#1-什么是类加载&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是类加载&quot;&gt;&lt;/a&gt;1. 什么是类加载&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM(一)内存结构</title>
    <link href="http://yoursite.com/2019/07/11/JVM-%E4%B8%80-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/07/11/JVM-一-内存结构/</id>
    <published>2019-07-11T05:33:12.000Z</published>
    <updated>2019-07-20T14:09:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1562826662961.jpg" alt="jvm内存结构"></p><p>​    JVM内存结构主要有三大块:<strong>堆内存</strong>,<strong>方法区</strong>和<strong>栈</strong></p><p>​    <strong>堆内存</strong>是JVM内存中最大的一块区域,由年轻代和老年代组成,而年轻代由可分为三部分,EdenSpace,FromSpace,ToSpace,默认情况下三者比例为8:1:1的比例.</p><p>​    <strong>方法区</strong>存储类信息,常量,静态变量等数据,是线程共享的区域.</p><p>​    <strong>栈</strong>又可以分为java虚拟机栈和本地方法栈主要用于方法的执行</p><h3 id="2-JVM内存区域分配"><a href="#2-JVM内存区域分配" class="headerlink" title="2.JVM内存区域分配"></a>2.JVM内存区域分配</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1562827418260.jpg" alt="jvm内存分配"></p><ul><li>图中控制参数说明<ul><li>-Xmx:设置堆内存的最大值</li><li>-Xms:设置堆内存的最小值</li><li>-XX:MaxNewSize:设置新生代内存的最大值</li><li>-XX:NewSize:设置新生代内存的最小值</li><li>-XX:MaxPermSize:设置永久代内存的最大值</li><li>-XX:PermSize:设置永久代内存的最小值</li><li>-Xss:设置每个线程的堆栈大小</li></ul></li></ul><h3 id="3-JVM与系统之间调用关系"><a href="#3-JVM与系统之间调用关系" class="headerlink" title="3. JVM与系统之间调用关系"></a>3. JVM与系统之间调用关系</h3><p><img src="/2019/07/11/JVM-一-内存结构/JVM%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1562828203417.jpg" alt="JVM与系统调用"></p><ul><li>方法区,堆属于所有线程间所共享的,而栈,程序计数器是属于线程私有的.</li><li><strong>java堆</strong><ul><li>对于大多数应用来说,java堆是java虚拟机所管理的内存中最大的一块,java堆是所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.</li><li>java堆时垃圾收集器管理的主要区域,因此很多时候也被称之为”<strong>GC堆</strong>“.</li><li>java堆可以位于物理上不连续的内存空间中,只要逻辑上时连续的即可</li><li>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出<strong>OutOfMemoryError</strong>异常.</li></ul></li><li><strong>方法区</strong><ul><li>与java堆一样,是各个线程间共享的内存区域,它主要用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</li><li>方法区与java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾回收.(垃圾回收在方法区出现的频率很小)</li><li>当方法区无法满足内存分配需求时,将抛出<strong>OutOfMemoryError</strong>异常.</li><li>方法区的执行都是随着线程的,原始类型的本地变量以及引用都存放在线程栈中,而引用关联的对象,都存在堆中.</li></ul></li><li><strong>程序计数器</strong><ul><li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码的信号指示器,在虚拟机的概念模型中字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</li><li>由于java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器只会执行一条独立的程序计数器,各条线程之间的1计数器互不影响,独立存储,我们称这种内存区域为”线程私有”的内存.</li><li>如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址,如果正在执行的是Natvie方法,这个计数器值则为空.</li></ul></li><li><strong>JVM栈</strong><ul><li>同程序计数器,java虚拟机栈也是线程私有的,<strong>它的生命周期与线程一样,虚拟机描述的是java方法执行的内存模型</strong>,每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表,朝左栈,动态链接,方法出口等信息.<strong>每一个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机中从入栈到出栈的过程.</strong></li><li>局部变量表存放了编译器可知的各种基本类型数据类型,对象引用(reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</li><li>在java虚拟机规范中,对这个区域规定了两种异常状况,如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<strong>StackOverFlowError</strong>异常,如果虚拟机可以动态的扩展,当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常.</li></ul></li><li><strong>本地方法栈</strong><ul><li>本地方法栈与虚拟机栈所发挥的作用时非常相似的,区别不过时虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务,虚拟机规范中对本地方法栈中的方法使用的语言,使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由的实现它.</li><li>与虚拟机栈一样,本地方法栈区域也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常</li></ul></li></ul><h3 id="4-使用JConsole查看java的相关信息"><a href="#4-使用JConsole查看java的相关信息" class="headerlink" title="4. 使用JConsole查看java的相关信息."></a>4. 使用JConsole查看java的相关信息.</h3><ul><li><p>找到%JAVA_HOME%\bin目录<img src="/2019/07/11/JVM-一-内存结构/javahome.png" alt="javahome"></p></li><li><p>执行cmd,输入jconsole命令,将会打开JConsole面板.<img src="/2019/07/11/JVM-一-内存结构/Jconsole.png" alt="Jconsole"></p></li><li><p>选择你要查看的进程点击连接,成功后如下.<img src="/2019/07/11/JVM-一-内存结构/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="控制面板"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;h3 id=&quot;1-JVM内存结构&quot;&gt;&lt;a href=&quot;#1-JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用函数</title>
    <link href="http://yoursite.com/2019/07/11/MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/11/MySQL常用函数/</id>
    <published>2019-07-11T03:25:00.000Z</published>
    <updated>2019-07-20T14:09:23.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL常用函数"><a href="#MySQL常用函数" class="headerlink" title="MySQL常用函数"></a>MySQL常用函数</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h3><pre><code>与大多数计算机语言一样,SQL支持利用函数来处理数据,函数一般是在数据上执行的,它给数据的转换和处理提供了方便.</code></pre><h3 id="2-函数的作用"><a href="#2-函数的作用" class="headerlink" title="2. 函数的作用"></a>2. 函数的作用</h3><p>​    用于处理文本串(如删除或填充值,转换值为大写或小写)的文本函数.</p><p>​       用于在数值上进行算术操作(如返回绝对值,进行代数运算)的数值函数.</p><p>​       用于处理日期和时间值并从这些值中提取特定成分(如,返回两个日期之差,检查日期有效性等)的日期和时间函数.</p><p>​       返回DBMS正使用的特殊信息(如,返回用户登录信息,检查版本细节)的系统函数.</p><h3 id="3-函数分类"><a href="#3-函数分类" class="headerlink" title="3. 函数分类"></a>3. 函数分类</h3><p>​     函数按照其用途功能可分为四大类,分别为:文本处理函数,日期和时间处理函数,数值处理函数和聚集函数.接下来详细讲解各函数.</p><p><a href="https://github.com/YanMao186/sql" target="_blank" rel="noopener">数据库建表语句</a></p><h4 id="文本函数"><a href="#文本函数" class="headerlink" title="文本函数"></a>文本函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr><tr><td>RTrim()</td><td>返回串右边的空格</td></tr></tbody></table><p>简单演示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将名称转为大写</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name,<span class="keyword">UPPER</span>(prod_name) 大写姓名 <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="comment">-- 返回名字最左边的三个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name,<span class="keyword">LEFT</span>(prod_name,<span class="number">3</span>)  <span class="keyword">FROM</span>  products;</span><br><span class="line"><span class="comment">-- 查询名称中含有'anvil'的产品,返回0表示不存在</span></span><br><span class="line"><span class="keyword">SELECT</span> prod_name,<span class="keyword">LOCATE</span>(<span class="string">'anvil'</span>,prod_name) <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/11/MySQL常用函数/6400.webp" alt="6400"><img src="/2019/07/11/MySQL常用函数/6402.webp" alt="6402"><img src="/2019/07/11/MySQL常用函数/640.webp" alt="640"></p><h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>addDate()</td><td>增加一个日期(天,周等)</td></tr><tr><td>AddTime()</td><td>增加一个时间(时.分等)</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_Add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或者时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayofWeek()</td><td>对于一个日期,返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr></tbody></table><p>==注:时间格式必须为yyyy-mm-dd==</p><p>简单演示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询时间为05年9月1日的产品信息</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="built_in">DATE</span>(order_date) = <span class="string">'2005-09-01'</span>;</span><br><span class="line"><span class="comment">-- 查询两个日期之差</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="string">'2005-10-08'</span>,<span class="string">'2005-09-01'</span>) 日期差为;</span><br><span class="line"><span class="comment">-- 返回日期对应的星期,由于老外的计算方式与中国人不同,在星期上需要减1</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">DAYOFWEEK</span>(<span class="string">'2019-7-10'</span>) 今天星期;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/11/MySQL常用函数/6404.webp" alt="6404"><img src="/2019/07/11/MySQL常用函数/6405.webp" alt="6405"><img src="/2019/07/11/MySQL常用函数/6403.webp" alt="6403"></p><h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦值</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦值</td></tr><tr><td>Tan()</td><td>返回一个角度的正切值</td></tr><tr><td>Exp()</td><td>返回一个角度的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr></tbody></table><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回平均值</td></tr><tr><td>Count()</td><td>返回行数</td></tr><tr><td>Max()</td><td>返回最大值</td></tr><tr><td>Min()</td><td>返回最小值</td></tr><tr><td>Sum()</td><td>返回某列之和</td></tr></tbody></table><p>简单演示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算商品平均价格</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(prod_price) 商品均价 <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="comment">-- 返回指定列值的和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(quantity) <span class="keyword">AS</span> 和 <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/11/MySQL常用函数/6407.webp" alt="6407"><img src="/2019/07/11/MySQL常用函数/6406.webp" alt="6406"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL常用函数&quot;&gt;&lt;a href=&quot;#MySQL常用函数&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用函数&quot;&gt;&lt;/a&gt;MySQL常用函数&lt;/h2&gt;&lt;h3 id=&quot;1-函数&quot;&gt;&lt;a href=&quot;#1-函数&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate总结</title>
    <link href="http://yoursite.com/2019/07/10/Hibernate%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/10/Hibernate总结/</id>
    <published>2019-07-09T17:04:24.000Z</published>
    <updated>2019-07-09T17:23:36.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hibernate笔记"><a href="#Hibernate笔记" class="headerlink" title="Hibernate笔记"></a>Hibernate笔记</h2><h3 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h3><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="1-什么是Hibernate"><a href="#1-什么是Hibernate" class="headerlink" title="1. 什么是Hibernate"></a>1. 什么是Hibernate</h4><ul><li><p><code>Hibernate是一个开源的ORM(Object Relational Mapping对象关系映射)框架,对JDBC进行了轻量级的对象封装,使我们开发人员可以使用面向对象的编程思想来操作数据库.</code></p><p><img src="/2019/07/10/Hibernate总结/ORM%E5%8E%9F%E7%90%86.png" alt="ORM原理"></p></li></ul><h4 id="2-优势"><a href="#2-优势" class="headerlink" title="2. 优势"></a>2. 优势</h4><ul><li>对JDBC访问数据库的代码进行了轻量级封装,大大简化了数据访问层繁琐的重复性代码,减少内存消耗,加快运行效率.</li><li>Hibernate是一款基于JDBC的主流持久化框架,是一个优秀的ORM实现,很大程度的简化了DAO(Data Access Object,数据访问对象)层编码工作.</li><li>性能好,映射的灵活性很出色,它支持关系型数据库,从1对1到多对多的各种复杂关系.</li><li>可拓展性强,由于源代码的开源以及API的开放,当本身功能不够用时,可以自行编码进行拓展.</li></ul><h4 id="3-入门"><a href="#3-入门" class="headerlink" title="3.入门"></a>3.入门</h4><h5 id="1-首先看一下项目的整体目录结构"><a href="#1-首先看一下项目的整体目录结构" class="headerlink" title="1.首先看一下项目的整体目录结构"></a>1.首先看一下项目的整体目录结构</h5><p><img src="/2019/07/10/Hibernate总结/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p><h5 id="2-项目需要的jar包"><a href="#2-项目需要的jar包" class="headerlink" title="2.项目需要的jar包"></a>2.项目需要的jar包</h5><p><img src="/2019/07/10/Hibernate总结/lib%E7%9B%AE%E5%BD%95.png" alt="lib目录"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.hibernate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: hibernatedemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-05-16 13:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//声明当前类为实体类</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="comment">//指定当前类与数据库表的映射关系</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"cst_customer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="comment">//用于指定主键</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="comment">//用于指定主键的生成策略,GenerationType.IDENTITY为mysql默认的</span></span><br><span class="line">    <span class="comment">//当使用xml建立实体类与数据库表的关系时,不需要以上所有的注解</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long cust_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cust_name;</span><br><span class="line">    <span class="keyword">private</span> String cust_source;</span><br><span class="line">    <span class="keyword">private</span> String cust_industry;</span><br><span class="line">    <span class="keyword">private</span> String cust_linkman;</span><br><span class="line">    <span class="keyword">private</span> String cust_phone;</span><br><span class="line">    <span class="keyword">private</span> String cust_mobile;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getCust_id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_id</span><span class="params">(Long cust_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_id = cust_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_name</span><span class="params">(String cust_name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_name = cust_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_source</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_source</span><span class="params">(String cust_source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_source = cust_source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_industry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_industry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_industry</span><span class="params">(String cust_industry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_industry = cust_industry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_linkman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_linkman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_linkman</span><span class="params">(String cust_linkman)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_linkman = cust_linkman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_phone</span><span class="params">(String cust_phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_phone = cust_phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCust_mobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cust_mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCust_mobile</span><span class="params">(String cust_mobile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cust_mobile = cust_mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer&#123;"</span> +</span><br><span class="line">                <span class="string">"cust_id="</span> + cust_id +</span><br><span class="line">                <span class="string">", cust_name='"</span> + cust_name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cust_source='"</span> + cust_source + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cust_industry='"</span> + cust_industry + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cust_linkman='"</span> + cust_linkman + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cust_phone='"</span> + cust_phone + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", cust_mobile='"</span> + cust_mobile + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-创建实体类与数据库的映射关系-Customer-hbm-xml"><a href="#4-创建实体类与数据库的映射关系-Customer-hbm-xml" class="headerlink" title="4.创建实体类与数据库的映射关系(Customer.hbm.xml)"></a>4.创建实体类与数据库的映射关系(Customer.hbm.xml)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.ym.hibernate"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        class元素: 配置实体与表的对应关系的</span></span><br><span class="line"><span class="comment">            name: 完整类名</span></span><br><span class="line"><span class="comment">            table:数据库表名</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id元素:配置主键映射的属性</span></span><br><span class="line"><span class="comment">                name: 填写主键对应属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span>  &gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- generator:主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property元素:除id之外的普通属性映射</span></span><br><span class="line"><span class="comment">                name: 填写属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写列名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> &gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  &lt;column name="cust_name" sql-type="varchar" &gt;&lt;/column&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_linkman"</span> <span class="attr">column</span>=<span class="string">"cust_linkman"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="5-创建hibernate的核心配置文件-位于src根目录-hibernate-cfg-xml"><a href="#5-创建hibernate的核心配置文件-位于src根目录-hibernate-cfg-xml" class="headerlink" title="5.创建hibernate的核心配置文件,位于src根目录(hibernate.cfg.xml)"></a>5.创建hibernate的核心配置文件,位于src根目录(hibernate.cfg.xml)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="connection.url"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="connection.driver_class"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="connection.username"/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="connection.password"/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- DB schema will be updated if needed --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库驱动  必须配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库url 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接用户名 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接密码 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库方言  必须配置</span></span><br><span class="line"><span class="comment">            不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.</span></span><br><span class="line"><span class="comment">            sql99标准: DDL 定义语言  库表的增删改查</span></span><br><span class="line"><span class="comment">                      DCL 控制语言  事务 权限</span></span><br><span class="line"><span class="comment">                      DML 操纵语言  增删改查</span></span><br><span class="line"><span class="comment">            注意: MYSQL在选择方言时,请选择最短的方言.</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不知道为啥必须写两个dialect数据库表才会创建成功--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- #hibernate.show_sql true</span></span><br><span class="line"><span class="comment">             #hibernate.format_sql true</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将hibernate生成的sql语句打印到控制台 可选配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) 可选配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ## auto schema export  自动导出表结构. 自动建表    可选配置</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto create自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto validate校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当使用xml建立与实体类的映射时使用此配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mapping resource="./com/ym/hibernate/Customer.hbm.xml" /&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.ym.hibernate.Customer"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当在实体类上使用注解时使用此配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6-测试类"><a href="#6-测试类" class="headerlink" title="6.测试类"></a>6.测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ym.hibernate.Customer;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: hibernatedemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-05-16 13:11</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure(<span class="string">"hibernate.cfg.xml"</span>);</span><br><span class="line">        <span class="comment">//hibernate.cfg.xml默认位于src根路径下</span></span><br><span class="line">        <span class="comment">//2.创建一个SessionFactory</span></span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        <span class="comment">//3.创建Session对象</span></span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        <span class="comment">//4.开启事务</span></span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">//5.执行相关操作</span></span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setCust_name(<span class="string">"alibaba"</span>);</span><br><span class="line">        customer.setCust_phone(<span class="string">"12345678900"</span>);</span><br><span class="line">        session.save(customer);</span><br><span class="line">        <span class="comment">//6.提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        sessionFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-常用API"><a href="#4-常用API" class="headerlink" title="4.常用API"></a>4.常用API</h4><h5 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1. Configuration"></a>1. Configuration</h5><ul><li>用于配置加载类,用于加载主配置文件,orm元数据加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"><span class="comment">//2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件</span></span><br><span class="line">conf.configure();</span><br><span class="line"><span class="comment">//3 读取指定orm元数据(扩展),如果主配置中已经引入映射配置.不需要手动加载</span></span><br><span class="line"><span class="comment">//conf.addResource(resourceName);</span></span><br><span class="line"><span class="comment">//conf.addClass(persistentClass);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-SessionFactory"><a href="#2-SessionFactory" class="headerlink" title="2.SessionFactory"></a>2.SessionFactory</h5><ul><li><p>用于创建操作数据库核心对象session对象的工厂(创建session对象)</p></li><li><p>sessionfactory负责保存和使用所有配置信息,消耗内存资源非常大</p></li><li><p>sessionfactory属于线程安全的对象设计</p></li><li><p>保证在web项目中,只创建一个sessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"><span class="comment">//2 读取指定主配置文件 =&gt; 空参加载方法,加载src下的hibernate.cfg.xml文件</span></span><br><span class="line">conf.configure();</span><br><span class="line"><span class="comment">//3 读取指定orm元数据(扩展),如果主配置中已经引入映射配置.不需要手动加载</span></span><br><span class="line"><span class="comment">//conf.addResource(resourceName);</span></span><br><span class="line"><span class="comment">//conf.addClass(persistentClass);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//5 获得session</span></span><br><span class="line"><span class="comment">//打开一个新的session对象</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-session"><a href="#3-session" class="headerlink" title="3.session"></a>3.session</h5><ul><li>表达hibernate框架与数据库之间的连接(会话),类似于JDBC中的connection对象,还可以完成数据库中数据的增删改查操作,session是hibernate操作数据库的核心对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//事务操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//2 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//3 获得session</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line"><span class="comment">//4 session获得操作事务的Transaction对象</span></span><br><span class="line"><span class="comment">//获得操作事务的tx对象</span></span><br><span class="line"><span class="comment">//Transaction tx = session.getTransaction();</span></span><br><span class="line"><span class="comment">//开启事务并获得操作事务的tx对象(建议使用)</span></span><br><span class="line">Transaction tx2 = session.beginTransaction();</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">tx2.commit();<span class="comment">//提交事务</span></span><br><span class="line">tx2.rollback();<span class="comment">//回滚事务</span></span><br><span class="line">session.close();<span class="comment">//释放资源</span></span><br><span class="line">sf.close();<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//session的新增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//2 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//3 获得session</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line"><span class="comment">//4 session获得操作事务的Transaction对象</span></span><br><span class="line"><span class="comment">//获得操作事务的tx对象</span></span><br><span class="line"><span class="comment">//Transaction tx = session.getTransaction();</span></span><br><span class="line"><span class="comment">//开启事务并获得操作事务的tx对象(建议使用)</span></span><br><span class="line">Transaction tx2 = session.beginTransaction();</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">c.setCust_name(<span class="string">"xxxx"</span>);</span><br><span class="line"></span><br><span class="line">session.save(c);</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">tx2.commit();<span class="comment">//提交事务</span></span><br><span class="line">session.close();<span class="comment">//释放资源</span></span><br><span class="line">sf.close();<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//session的查询</span></span><br><span class="line"><span class="comment">//查询id为1的customer对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//2 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//3 获得session</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line"><span class="comment">//4 session获得操作事务的Transaction对象</span></span><br><span class="line"><span class="comment">//获得操作事务的tx对象</span></span><br><span class="line"><span class="comment">//Transaction tx = session.getTransaction();</span></span><br><span class="line"><span class="comment">//开启事务并获得操作事务的tx对象(建议使用)</span></span><br><span class="line">Transaction tx2 = session.beginTransaction();</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">Customer customer = session.get(Customer.class, <span class="number">1l</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(customer);</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">tx2.commit();<span class="comment">//提交事务</span></span><br><span class="line">session.close();<span class="comment">//释放资源</span></span><br><span class="line">sf.close();<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//session的修改</span></span><br><span class="line"><span class="comment">//修改id为1的customer对象的name属性为黑马程序员</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//2 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//3 获得session</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line"><span class="comment">//4 session获得操作事务的Transaction对象</span></span><br><span class="line"><span class="comment">//获得操作事务的tx对象</span></span><br><span class="line"><span class="comment">//Transaction tx = session.getTransaction();</span></span><br><span class="line"><span class="comment">//开启事务并获得操作事务的tx对象(建议使用)</span></span><br><span class="line">Transaction tx2 = session.beginTransaction();</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//1 获得要修改的对象</span></span><br><span class="line">Customer c = session.get(Customer.class, <span class="number">1l</span>);</span><br><span class="line"><span class="comment">//2 修改</span></span><br><span class="line">c.setCust_name(<span class="string">"xxxxxxx"</span>);</span><br><span class="line"><span class="comment">//3 执行update</span></span><br><span class="line">session.update(c);</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">tx2.commit();<span class="comment">//提交事务</span></span><br><span class="line">session.close();<span class="comment">//释放资源</span></span><br><span class="line">sf.close();<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//session的删除</span></span><br><span class="line"><span class="comment">//删除id为1的customer对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 创建,调用空参构造</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//2 根据配置信息,创建 SessionFactory对象</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory();</span><br><span class="line"><span class="comment">//3 获得session</span></span><br><span class="line">Session session = sf.openSession();</span><br><span class="line"><span class="comment">//4 session获得操作事务的Transaction对象</span></span><br><span class="line"><span class="comment">//获得操作事务的tx对象</span></span><br><span class="line">Transaction tx = session.getTransaction();</span><br><span class="line">tx.begin();</span><br><span class="line"><span class="comment">//开启事务并获得操作事务的tx对象(建议使用)</span></span><br><span class="line">Transaction tx2 = session.beginTransaction();</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">//1 获得要修改的对象</span></span><br><span class="line">Customer c = session.get(Customer.class, <span class="number">1l</span>);</span><br><span class="line"><span class="comment">//2 调用delete删除对象</span></span><br><span class="line">session.delete(c);</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line">tx2.commit();<span class="comment">//提交事务</span></span><br><span class="line">session.close();<span class="comment">//释放资源</span></span><br><span class="line">sf.close();<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-Transaction"><a href="#4-Transaction" class="headerlink" title="4.Transaction"></a>4.Transaction</h5><ul><li><p>Transaction是一个可选的API,可以不选择这个接口.</p></li><li><p>主要用于管理事务,是Hibernate的数据库事务接口,并对底层的事务接口进行了封装,Transaction接口的事务对象是通过session对象开启的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction = session.beginTransaction();</span><br></pre></td></tr></table></figure></li><li><p>transaction接口,对于事务管理的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transaction.commit();<span class="comment">//提交相关联的session实例</span></span><br><span class="line">transaction.rollback();<span class="comment">//撤销事务操作</span></span><br></pre></td></tr></table></figure></li><li><p><strong>==Session==</strong>执行完数据库操作后,要使用<strong>==Transaction==</strong>接口的<strong>==commit()==</strong>方法进行事务提交,才能真正的将数据操作同步到数据库中,发生异常时,需要使用==<strong>rollback()</strong>==方法进行事务回滚,以避免数据发生错误,因此,在持久化操作后,必须调用<strong>==Transaction==</strong>接口的<strong>==commit()==</strong>方法和<strong>==rollback()==</strong>方法,如果没有开启事务,那么每个<strong>==Session==</strong>的操作,都相当于一个独立的操作.</p></li></ul><h2 id="Hibernate-day02"><a href="#Hibernate-day02" class="headerlink" title="Hibernate day02"></a>Hibernate day02</h2><h3 id="一-Hibernate实体类注意事项"><a href="#一-Hibernate实体类注意事项" class="headerlink" title="一.Hibernate实体类注意事项"></a>一.Hibernate实体类注意事项</h3><ol><li><strong>实体类必须提供无参构造</strong>(因为Hibernate的底层需要使用反射生成类的实例)</li><li><strong>持久化类的属性需要私有,对私有的属性提供公共的get和set方法</strong>(因为Hibernate底层会将查询到的数据进行封装)</li><li><strong>持久化类的属性要尽量使用包装类型</strong>(因为包装类型和基本数据类型的默认值不同,包装类的类型语义描述更清晰而基本类型不容易描述)</li><li><strong>持久化类要有一个唯一标识OID与表的主键对应</strong>(因为在hibernate中需要通过这个唯一标识OID区分在内存中是否是同一个持久化类,在java中通过地址区分是否是同一个对象的,在关系型数据库的表中是通过主键区分是否是同一条记录,那么Hibernate就是通过这个OID来进行区分的,Hibernate是不允许在内存中出现两个OID相同的持久化对象的)</li><li><strong>持久化类尽量不要使用final进行修饰</strong>(因为Hibernate中有延迟加载的机制,这个机制中会产生代理对象,Hibernate产生代理对象使用的是字节码的增强技术完成的,其实就是产生了当前类的一个子类对象实现的,如果使用了final修饰持久化类,那么就不能产生子类,从而就不会产生代理对象,那么hibernate的延迟加载策略就会失效)</li></ol><h3 id="二-主键生成策略"><a href="#二-主键生成策略" class="headerlink" title="二.主键生成策略"></a>二.主键生成策略</h3><ol><li><p><strong>主键的类型</strong></p><ul><li><code>自然主键:把具有业务含义的字段作为主键,称之为自然主键,如在用户表中将name字段作为主键,其前提条件必须是:&quot;每一个用户姓名不允许为null,不允许重名,并且不允许修改用户姓名&quot;</code></li><li><code>代理主键:把不具备业务含义的字段作为主键,称之为代理主键,该字段一般取名为ID,通常为整数类型,因为整数类型比字符串类型要节省更多的数据空间,开发中常用</code></li></ul></li><li><p><strong>主键生成策略</strong></p><p> <img src="/2019/07/10/Hibernate总结/1558060355939.png" alt="1558060355939"></p><table><thead><tr><th align="center">主键类型</th><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">代理主键</td><td align="center">increment</td><td align="center">用于long,short,或int类型,由Hibernate自动以递增的方式生成唯一标识符,每次增量为1,只有当没有其它进程向同一张表中插入数据时才可以使用,不能用于集群环境下</td></tr><tr><td align="center">代理主键</td><td align="center">identity</td><td align="center">采用底层数据库本身提供的主键生成标识符,条件是数据库支持自动增长数据类型,在DB2,MySQL,MS,SQL,Server,Sybase和HypersonicSQL数据库中可以使用该生成器,该生成器要求在数据库中把主键定义成为自增长类型,适用于代理主键</td></tr><tr><td align="center">代理主键</td><td align="center">sequence</td><td align="center">Hibernate根据底层数据库序列生成标识符,条件是数据库支持序列,适用于代理主键</td></tr><tr><td align="center">代理主键</td><td align="center">native</td><td align="center">根据底层数据库对自动生成标识符的能力来选择identity,sequence,hilo三种生成器中的一种,适合跨数据库平台开发,适用于代理主键</td></tr><tr><td align="center">代理主键</td><td align="center">uuid</td><td align="center">产生随机字符串作为主键,主键类型必须为String类型,适用于代理主键</td></tr><tr><td align="center">自然主键</td><td align="center">assigned</td><td align="center">由java程序负责生成标识符,如果不指定id元素的generator属性,则默认使用该主键生成策略,适用于自然主键</td></tr></tbody></table></li></ol><h3 id="三-对象状态"><a href="#三-对象状态" class="headerlink" title="三.对象状态"></a>三.对象状态</h3><ol><li><p><strong>对象分为三种状态</strong></p><ul><li><code>瞬时状态:没有id,没有与session关联</code></li><li><code>持久化状态:有id,与session有关联</code></li><li><code>游离|托管状态:有id,没有与session关联</code></li></ul></li><li><p><strong>三种状态代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer(); <span class="comment">//没有id,没有与session关联,瞬时状态</span></span><br><span class="line">        customer.setCust_name(<span class="string">"Lenovo"</span>); <span class="comment">//瞬时状态</span></span><br><span class="line">        session.save(customer);    <span class="comment">//持久化状态,有id,有关联</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();   <span class="comment">//游离|托管,有id,没有与session关联</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>customer对象由new关键字创建,此时还未与session进行关联,它的状态称为瞬时状态,在执行了session.save(customer)后,customer对象纳入session的管理范围,此时的customer对象变成了持久态对象,此时的session的事务还没有被提交;程序执行完commit()操作并关闭了session后,customer对象与session的关联被关闭,此时customer对象就变成了托管态.</code></p></li><li><p><strong>持久化对象三种状态转换图解</strong></p></li></ol><p><img src="/2019/07/10/Hibernate总结/1558062569476.png" alt="1558062569476"></p><ol start="4"><li><p><strong>瞬时状态转换到其他状态</strong></p><ul><li><p><code>瞬时状态转换为持久态:执行session的save()或saveOrUpdate()方法</code></p></li><li><p><code>瞬时状态转换为托管态:为瞬时态对象设置持久化标识OID</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Customer customer = <span class="keyword">new</span> Customer(); <span class="comment">//瞬时态</span></span><br><span class="line">customer.setCust_id(<span class="number">1</span>);<span class="comment">//托管态</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>持久态对象转换到其他对象</strong></p><ul><li><code>持久态转换为瞬时状态:执行session的delete()方法,需要注意的是被删除的持久化对象,不建议再次使用</code></li><li><code>持久态转换为托管态:执行session的evict(),close()或clear()方法,evict()用于清除一级缓存中某一个对象;close()用于关闭session,清除一级缓存;clear()用于清除一级缓存的所有对象.</code></li></ul></li><li><p><strong>托管态的对象转换到其他对象</strong></p><ul><li><code>托管态转换为持久态:执行Session的update(),saveOrUpdate()或lock()方法</code></li><li><code>托管态转换为瞬时态:将托管态对象的持久化标识OID设置为null.</code></li></ul></li><li><p><strong>持久态对象可以自动更新数据库</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//获得持久态对象</span></span><br><span class="line">        Customer customer = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">        customer.setCust_name(<span class="string">"sum"</span>);</span><br><span class="line">     <span class="comment">//不需要调用update方法就可以进行更新,依赖于Hibernate的一级缓存</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();   <span class="comment">//游离|托管,有id,没有关联</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="四-Hibernate的缓存"><a href="#四-Hibernate的缓存" class="headerlink" title="四.Hibernate的缓存"></a>四.Hibernate的缓存</h3><ul><li><code>Hibernate的缓存分为一级缓存和二级缓存,这两级缓存都位于持久层,存储的都是数据库数据的备份,其中第一级缓存为Hibernate的内置缓存,不能被卸载.</code></li></ul><h5 id="Hibernate的一级缓存"><a href="#Hibernate的一级缓存" class="headerlink" title="Hibernate的一级缓存"></a>Hibernate的一级缓存</h5><ul><li><p>一级缓存就是指Session缓存,Session缓存的是一块内存空间,用来存放相互管理的java对象,在hibernate查询对象的时候,首先会使用对象属性的OID值在Hibernate的一级缓存中查找,如果匹配到OID的对象,就直接将该对象从一级缓存中取出使用,不会再查询数据库,如果没有找到相同的OID值得对象,则会去数据库查找相应的数据,当数据库中查询到所需数据时,该数据信息也会放置到一级缓存中,<strong>Hibernate的一级缓存的作用就是减少对数据库的访问次数</strong></p></li><li><p>在session接口的实现中包含一系列的java集合,这些java集合构成了session缓存,只要session实例没有结束生命2周期,存放在他缓存中的对象也就不会结束生命周期,<strong>一级缓存也被称之为是session基本的缓存</strong></p></li><li><p><strong>一级缓存的特点</strong></p><ul><li>当应用程序调用session接口的save(),update(),saveOrUpdate()时,如果session缓存中没有相应的对象,Hibernate就会自动把从数据库中查询到的相应信息加入到一级缓存中.</li><li>当调用session接口的load(),get()方法,以及Query接口的list(),iterator()方法时,会判断缓存中是否存在该对象,有则返回,不会查询数据库,如果缓存中没有要查询对象,再去数据库中查询对应对象,并添加到一级缓存中</li><li>当调用session的close()方法时,session缓存会被清空</li></ul></li></ul><ul><li><p><strong>测试一级缓存</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">       SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">       Session session = sessionFactory.openSession();</span><br><span class="line">       Transaction transaction = session.beginTransaction();</span><br><span class="line">       Customer customer1 = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">       System.out.println(customer);</span><br><span class="line">       Customer customer2 = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">       System.out.println(customer1);</span><br><span class="line">       System.out.println(customer1 == customer2);</span><br><span class="line">       transaction.commit();</span><br><span class="line">       session.close();</span><br></pre></td></tr></table></figure><ul><li>控制台输出</li></ul><p><img src="/2019/07/10/Hibernate总结/1558077587353.png" alt="1558077587353"></p><ul><li>可以看到在第一次执行session的get()方法获取customer1对象时,由于一级缓存中没有数据,所以Hibernate会向数据库发送一条sql语句,查询id=2的对象,当再次调用session的get()方法获取customer2对象时,将不会再发送sql语句,这是因为customer2对象是从一级缓存中获取的.</li></ul></li></ul><h3 id="五-一级缓存的内部结构-快照区"><a href="#五-一级缓存的内部结构-快照区" class="headerlink" title="五.一级缓存的内部结构(快照区)"></a>五.一级缓存的内部结构(快照区)</h3><ul><li>Hibernate向一级缓存存放入数据时,同时复制一份数据放到Hibernate快照区,当使用commit()方法提交事务时,同时会清理Session的一级缓存,<strong>这时会使用OID判断一级缓存中的对象和快照中的对象是否一致,如果两个对象中的属性发生变化,则执行update语句,将缓存的内容同步到数据库,并更新快照,如果一致,则不执行update语句</strong>,Hibernate快照的作用就是确保一级缓存中的数据和数据库中的数据一致.</li></ul><p><img src="/2019/07/10/Hibernate总结/1558078245102.png" alt="1558078245102"></p><h3 id="六-Hibernate事务控制"><a href="#六-Hibernate事务控制" class="headerlink" title="六.Hibernate事务控制"></a>六.Hibernate事务控制</h3><ul><li><strong>事务的隔离级别</strong></li></ul><table><thead><tr><th>名称</th><th>级别</th><th>含义</th></tr></thead><tbody><tr><td>Read_Uncommited(读未提交)</td><td>1级</td><td>允许你读取还未提交的改变了的数据,可能导致脏,幻,不可重复读</td></tr><tr><td>Read_Committed(读已提交,oracle默认)</td><td>2级</td><td>允许在并发事务已经提交后读取,可防止脏读,但幻读和不可重复读仍可发生</td></tr><tr><td>Repeatable_read(可重复读,MySQL默认)</td><td>4级</td><td>对相同字段的多次读取是一致的,除非数据被事务本身改变,可防止脏,不可重复读,但幻读仍可以发生</td></tr><tr><td>Serializable(序列化/串行化)</td><td>8级</td><td>完全服从ACID的隔离级别,确保不发生脏,幻,不可重复读.这在所有的隔离级别中是最慢的,他是典型的通过完全锁定在事务中涉及的数据表来完成的</td></tr></tbody></table><ul><li><p><strong>Hibernate基于配置文件的事务管理</strong></p><ol><li>在hibernate.cfg.xml中配置</li></ol><ul><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.isolation"</span>&gt;</span>1/2/4/8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>在dao层操作数据库需要用到session对象.在service控制事务也是使用session对象完成. 我们要确保dao层和service层使用的使用同一个session对象,如何解决.</p><ul><li><p>hibernate已经帮我们解决了,我们只需要调用<strong>==sessionFaction.getCurrentSession()==</strong>方法既可获得与当前线程绑定的session对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSession</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        <span class="comment">//返回同一个与线程绑定的session</span></span><br><span class="line">        Session session1 = sessionFactory.getCurrentSession();</span><br><span class="line">        Session session2 = sessionFactory.getCurrentSession();</span><br><span class="line">        System.out.println(session1 == session2);</span><br><span class="line">        <span class="comment">//返回不同的session</span></span><br><span class="line">        Session session3 = sessionFactory.openSession();</span><br><span class="line">        Session session4 = sessionFactory.openSession();</span><br><span class="line">        System.out.println(session3 == session4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==注:调用getCurrentSession方法必须配合主配置中的一段配置(hibernate.cfg.xml)==</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">&lt;!--配置session绑定本地线程--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--thread:session对象的生命周期与本地线程绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jta:session对象的生命周期与JTA事务绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--managed:Hibernate委托程序来管理Session对象的生命周期--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="七-Hibernate中的批量查询"><a href="#七-Hibernate中的批量查询" class="headerlink" title="七.Hibernate中的批量查询"></a>七.Hibernate中的批量查询</h3><ol><li><p><strong>HQL查询-hibernate Query Language(多表查询,不复杂时使用)</strong></p><ul><li><p>Hibernate独家查询语言,属于面向对象的查询语言</p><ul><li><p>基本查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">       Session session = sessionFactory.openSession();</span><br><span class="line">       <span class="comment">//查询所有的Customer对象</span></span><br><span class="line">       Query customer = session.createQuery(<span class="string">"from Customer "</span>);</span><br><span class="line">       List list = customer.list();</span><br><span class="line">       System.out.println(list);</span><br></pre></td></tr></table></figure></li><li><p>条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ?后面的参数要与setParameter的参数保持一致,不一定要从0开始,不写会报异常</span></span><br><span class="line"><span class="comment">         * org.hibernate.QueryException: Legacy-style query parameters (`?`)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//定义HQL语句创建查询对象</span></span><br><span class="line">        Query query = session.createQuery(<span class="string">" from Customer where cust_id = ?0 "</span>);</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">        query.setParameter(<span class="number">0</span>, <span class="number">1L</span>);</span><br><span class="line">        <span class="comment">//根据查询对象获取查询结果</span></span><br><span class="line">        Customer customer = (Customer) query.uniqueResult();</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">page</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">//定义HQL语句</span></span><br><span class="line">        String hql = <span class="string">"from Customer"</span>;</span><br><span class="line">        Query query = session.createQuery(hql);</span><br><span class="line">        <span class="comment">//设置分页信息limit ? ,?</span></span><br><span class="line">        <span class="comment">//起始页</span></span><br><span class="line">        query.setFirstResult(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//每页显示数</span></span><br><span class="line">        query.setMaxResults(<span class="number">2</span>);</span><br><span class="line">        List&lt;Customer&gt; list = query.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Query中除了list()方法查询全部数据外,还有其他一些常用的方法</p><ul><li>setting()方法:Query接口中提供了一系列setting方法用于设置查询语句中的参数,针对不同的数据类型,需要用到不同的setting方法.</li><li>iterator()方法:该方法用于查询语句,返回的结果是一个Iterator对象,在读取时只能按照顺序方式读取,它仅把使用到的数据转换成java实体对象.</li><li>uniqueResult()方法:该方法用于返回唯一的结果,在确保只有一条记录的查询时可以使用该方法.</li><li>executeUpdate()方法:该方法是Hibernate3的新特性,它支持HQL语句的更新和删除操作.</li><li>setFirstResult()方法:该方法可以设置获取第一个记录的位置,也就是它表示从第几条记录开始查询,默认从0开始计算.</li><li>setMaxResult()方法:该方法用于设置结果集的最大记录数,通常与setFirstResult()方法结合使用,用于限制结果集的范围,以实现分页功能.</li></ul></li></ul></li></ul></li><li><p><strong>Criteria查询(单表条件查询)</strong></p><ul><li>criteria是一个完全面向对象,可扩展的条件查询API,通过它完全不需要考虑数据库底层如何实现,以及sql语句如何编写,他是Hibernate框架的核心查询对象,Criteria查询,又称为QBC(Query by Criteria)查询,他是Hibernate的另一种对象检索方式.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CriteriaDemo cd = <span class="keyword">new</span> CriteriaDemo();</span><br><span class="line">        cd.findAll();</span><br><span class="line">        cd.findByName();</span><br><span class="line">        cd.findByPage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据姓名查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.add(Restrictions.eq(<span class="string">"cust_name"</span>,<span class="string">"alibaba"</span>));</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.setFirstResult(<span class="number">0</span>);</span><br><span class="line">        criteria.setMaxResults(<span class="number">2</span>);</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>原生SQL查询(复杂业务查询)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SqlDemo sd = <span class="keyword">new</span> SqlDemo();</span><br><span class="line">    sd.findAll();</span><br><span class="line">    sd.findById();</span><br><span class="line">        sd.findpage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        String sql = <span class="string">"select * from cst_customer"</span>;</span><br><span class="line">        NativeQuery sqlQuery = session.createSQLQuery(sql);</span><br><span class="line">        sqlQuery.addEntity(Customer.class);</span><br><span class="line">        List&lt;Customer&gt; list = sqlQuery.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        String sql = <span class="string">"select * from cst_customer where cust_id = ?0"</span>;</span><br><span class="line">        NativeQuery sqlQuery = session.createSQLQuery(sql);</span><br><span class="line">        sqlQuery.setParameter(<span class="number">0</span>,<span class="number">1L</span>);</span><br><span class="line">        sqlQuery.addEntity(Customer.class);</span><br><span class="line">        List&lt;Customer&gt; list = sqlQuery.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findpage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        String sql = <span class="string">"select * from cst_customer limit ?0,?1 "</span>;</span><br><span class="line">        NativeQuery sqlQuery = session.createSQLQuery(sql);</span><br><span class="line">      sqlQuery.setParameter(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">      sqlQuery.setParameter(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        sqlQuery.addEntity(Customer.class);</span><br><span class="line">        List&lt;Customer&gt; list = sqlQuery.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Hibernate-day03"><a href="#Hibernate-day03" class="headerlink" title="Hibernate day03"></a>Hibernate day03</h2><h3 id="一-Hibernate一对多关系映射"><a href="#一-Hibernate一对多关系映射" class="headerlink" title="一.Hibernate一对多关系映射"></a>一.Hibernate一对多关系映射</h3><ul><li><p><strong>创建实体类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"><span class="comment">//用于指定主键</span></span><br><span class="line"><span class="comment">//@Id</span></span><br><span class="line"><span class="comment">//    @OneToMany(targetEntity = LinkMan.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于指定主键的生成策略,GenerationType.IDENTITY为mysql默认的</span></span><br><span class="line"><span class="comment">//@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long cust_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cust_name;</span><br><span class="line">    <span class="keyword">private</span> String cust_source;</span><br><span class="line">    <span class="keyword">private</span> String cust_industry;</span><br><span class="line">    <span class="keyword">private</span> String cust_linkman;</span><br><span class="line">    <span class="keyword">private</span> String cust_level;</span><br><span class="line">    <span class="keyword">private</span> String cust_phone;</span><br><span class="line">    <span class="keyword">private</span> String cust_mobile;</span><br><span class="line">    <span class="comment">//一个客户有多个联系人,客户中应该放有联系人的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long lkm_id;</span><br><span class="line">    <span class="keyword">private</span> Character lkm_gender;</span><br><span class="line">    <span class="keyword">private</span> String lkm_name;</span><br><span class="line">    <span class="keyword">private</span> String lkm_phone;</span><br><span class="line">    <span class="keyword">private</span> String lkm_email;</span><br><span class="line">    <span class="keyword">private</span> String lkm_qq;</span><br><span class="line">    <span class="keyword">private</span> String lkm_mobile;</span><br><span class="line">    <span class="keyword">private</span> String lkm_memo;</span><br><span class="line">    <span class="keyword">private</span> String lkm_position;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建xml映射</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.ym.hibernate"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        class元素: 配置实体与表的对应关系的</span></span><br><span class="line"><span class="comment">            name: 完整类名</span></span><br><span class="line"><span class="comment">            table:数据库表名</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id元素:配置主键映射的属性</span></span><br><span class="line"><span class="comment">                name: 填写主键对应属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span>  &gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- generator:主键生成策略 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--identity:主键自增,由数据库来维护主键值,录入时不需要指定主键--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--increment(线程不安全):主键自增,由hibernate来维护,每次插入前会先查询表中id最大值,+1作为新主键--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--sequence: Oracle中的主键生成策略--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--hilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用.--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--native:hilo+sequence+identity 自动三选一策略.--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--uuid: 产生随机字符串作为主键. 主键类型必须为string 类型.--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property元素:除id之外的普通属性映射</span></span><br><span class="line"><span class="comment">                name: 填写属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写列名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> &gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  &lt;column name="cust_name" sql-type="varchar" &gt;&lt;/column&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_linkman"</span> <span class="attr">column</span>=<span class="string">"cust_linkman"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set标签:</span></span><br><span class="line"><span class="comment">                    name:多的一方的集合的属性名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--key</span></span><br><span class="line"><span class="comment">                column:多的一方的外键名称--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--one-to-many</span></span><br><span class="line"><span class="comment">                    class多的一方的类全路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.ym.hibernate.LinkMan"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置表与实体对象的关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.ym.hibernate"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        class元素: 配置实体与表的对应关系的</span></span><br><span class="line"><span class="comment">            name: 完整类名</span></span><br><span class="line"><span class="comment">            table:数据库表名</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"LinkMan"</span> <span class="attr">table</span>=<span class="string">"cst_linkman"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id元素:配置主键映射的属性</span></span><br><span class="line"><span class="comment">                name: 填写主键对应属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"lkm_id"</span>  &gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- generator:主键生成策略 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--identity:主键自增,由数据库来维护主键值,录入时不需要指定主键--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--increment(线程不安全):主键自增,由hibernate来维护,每次插入前会先查询表中id最大值,+1作为新主键--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--sequence: Oracle中的主键生成策略--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--hilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用.--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--native:hilo+sequence+identity 自动三选一策略.--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--uuid: 产生随机字符串作为主键. 主键类型必须为string 类型.--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- property元素:除id之外的普通属性映射</span></span><br><span class="line"><span class="comment">                name: 填写属性名</span></span><br><span class="line"><span class="comment">                column(可选): 填写列名</span></span><br><span class="line"><span class="comment">                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.</span></span><br><span class="line"><span class="comment">                        每个类型有三种填法: java类型|hibernate类型|数据库类型</span></span><br><span class="line"><span class="comment">                not-null(可选):配置该属性(列)是否不能为空. 默认值:false</span></span><br><span class="line"><span class="comment">                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_gender"</span> <span class="attr">column</span>=<span class="string">"lkm_gender"</span> &gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  &lt;column name="cust_name" sql-type="varchar" &gt;&lt;/column&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_name"</span> <span class="attr">column</span>=<span class="string">"lkm_name"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_phone"</span> <span class="attr">column</span>=<span class="string">"lkm_phone"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_email"</span> <span class="attr">column</span>=<span class="string">"lkm_email"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_qq"</span> <span class="attr">column</span>=<span class="string">"lkm_qq"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_mobile"</span> <span class="attr">column</span>=<span class="string">"lkm_mobile"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_memo"</span> <span class="attr">column</span>=<span class="string">"lkm_memo"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lkm_position"</span> <span class="attr">column</span>=<span class="string">"lkm_position"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--many-to-one</span></span><br><span class="line"><span class="comment">            name:一的一方对象的名称</span></span><br><span class="line"><span class="comment">            class:一的一方的类的全路径</span></span><br><span class="line"><span class="comment">            column:表的外键名称--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.ym.hibernate.Customer"</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>将xml映射添加到配置文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="connection.url"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="connection.driver_class"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="connection.username"/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name="connection.password"/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- DB schema will be updated if needed --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库驱动  必须配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库url 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接用户名 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接密码 必须配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库方言  必须配置</span></span><br><span class="line"><span class="comment">            不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.</span></span><br><span class="line"><span class="comment">            sql99标准: DDL 定义语言  库表的增删改查</span></span><br><span class="line"><span class="comment">                      DCL 控制语言  事务 权限</span></span><br><span class="line"><span class="comment">                      DML 操纵语言  增删改查</span></span><br><span class="line"><span class="comment">            注意: MYSQL在选择方言时,请选择最短的方言.</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不知道为啥必须写两个dialect数据库表才会创建成功--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- #hibernate.show_sql true</span></span><br><span class="line"><span class="comment">             #hibernate.format_sql true</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将hibernate生成的sql语句打印到控制台 可选配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) 可选配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ## auto schema export  自动导出表结构. 自动建表    可选配置</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto create自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).</span></span><br><span class="line"><span class="comment">        #hibernate.hbm2ddl.auto validate校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.isolation"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置session绑定本地线程--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--thread:session对象的生命周期与本地线程绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jta:session对象的生命周期与JTA事务绑定--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--managed:Hibernate委托程序来管理Session对象的生命周期--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当使用xml建立与实体类的映射时使用此配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"./com/ym/hibernate/Customer.hbm.xml"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"./com/ym/hibernate/LinkMan.hbm.xml"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;mapping class="com.ym.hibernate.Customer"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当在实体类上使用注解时使用此配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnToMany</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setCust_name(<span class="string">"严"</span>);</span><br><span class="line">        LinkMan linkMan1 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">        linkMan1.setLkm_name(<span class="string">"李"</span>);</span><br><span class="line">        LinkMan linkMan2 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">        linkMan2.setLkm_name(<span class="string">"王"</span>);</span><br><span class="line">        customer.getLinkMans().add(linkMan1);</span><br><span class="line">        customer.getLinkMans().add(linkMan2);</span><br><span class="line">        linkMan1.setCustomer(customer);</span><br><span class="line">        linkMan2.setCustomer(customer);</span><br><span class="line">        session.save(customer);</span><br><span class="line">        session.save(linkMan1);</span><br><span class="line">        session.save(linkMan2);</span><br><span class="line">        transaction.commit();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上面的代码中我们建立的关系是双向的,即客户关联了联系人,联系人也关联了客户,这就是双向关联,那么既然已经进行了双向的关联关系设置,那么我们还保存了双方,那如果我们只保存一方是否可以呢,这就需要使用级联操作</p></li><li><p><strong>级联操作是指当主控方执行保存,更新或者删除操作时,其关联对象(被控方)也执行相同的操作在映射文件中通过对cascade属性设置来控制是否对关联对象采用级联操作,级联操作对各种关系都是有效的</strong></p></li><li><p><strong>级联保存或更新</strong></p><ul><li><p>级联是有方向性的,所谓的方向性是指,在保存一的一方级联多的一方合在保存多的一方级联一的一方.</p></li><li><p>主控方:保存哪一方哪一方就是就是主控方,在主控方的xml中进行配置</p><p><img src="/2019/07/10/Hibernate总结/1558104622754.png" alt="1558104622754"></p></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">       Session session = sessionFactory.openSession();</span><br><span class="line">       Transaction transaction = session.beginTransaction();</span><br><span class="line">       Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">       customer.setCust_name(<span class="string">"严"</span>);</span><br><span class="line">       LinkMan linkMan1 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">       linkMan1.setLkm_name(<span class="string">"李"</span>);</span><br><span class="line">       LinkMan linkMan2 = <span class="keyword">new</span> LinkMan();</span><br><span class="line">       linkMan2.setLkm_name(<span class="string">"王"</span>);</span><br><span class="line">       customer.getLinkMans().add(linkMan1);</span><br><span class="line">       customer.getLinkMans().add(linkMan2);</span><br><span class="line">       linkMan1.setCustomer(customer);</span><br><span class="line">       linkMan2.setCustomer(customer);</span><br><span class="line">       session.save(customer);</span><br><span class="line">       transaction.commit();</span><br></pre></td></tr></table></figure></li><li><p><strong>级联删除</strong></p><ul><li>设置cascade=”delete”</li><li>如果想有级联保存或更新,同时还想有级联删除配置如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cascade="delete,save-update"</span><br></pre></td></tr></table></figure></li><li><p><strong>双向关联产生多余sql语句</strong></p><ul><li>解决方案,让一的一方放弃外键的维护权</li><li>在一的一方的xml中配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--set标签:</span></span><br><span class="line"><span class="comment">                   name:多的一方的集合的属性名称--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--inverse为true表示放弃外键的维护权--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"linkMans"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> <span class="attr">inverse</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--key</span></span><br><span class="line"><span class="comment">               column:多的一方的外键名称--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"lkm_cust_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--one-to-many</span></span><br><span class="line"><span class="comment">                   class多的一方的类全路径--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.ym.hibernate.LinkMan"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>cascade和inverse</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//cascade和inverse</span></span><br><span class="line"><span class="comment">//cascade强调的是操作一个对象的时候,是否操作其关联对象</span></span><br><span class="line"><span class="comment">//inverse强调的是外键的维护权</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Session session = HibernateUtile.getCurrentSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setCust_name(<span class="string">"王总"</span>);</span><br><span class="line">    LinkMan linkman = <span class="keyword">new</span> LinkMan();</span><br><span class="line">    linkman.setLkm_name(<span class="string">"李秘书"</span>);</span><br><span class="line">    <span class="comment">//在Customer.hbm.xml中的set上配置cascade="save-update" inverse="true"</span></span><br><span class="line">    customer.getLinkMans().add(linkMan);</span><br><span class="line">    session.save(customer);</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/10/Hibernate总结/1558106423425.png" alt="1558106423425"></p></li></ul><h3 id="二-多对多关系映射"><a href="#二-多对多关系映射" class="headerlink" title="二.多对多关系映射"></a>二.多对多关系映射</h3><ul><li>创建实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CREATE TABLE `sys_user` (</span></span><br><span class="line"><span class="comment">  `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id',</span></span><br><span class="line"><span class="comment">  `user_code` varchar(32) NOT NULL COMMENT '用户账号',</span></span><br><span class="line"><span class="comment">  `user_name` varchar(64) NOT NULL COMMENT '用户名称',</span></span><br><span class="line"><span class="comment">  `user_password` varchar(32) NOT NULL COMMENT '用户密码',</span></span><br><span class="line"><span class="comment">  `user_state` char(1) NOT NULL COMMENT '1:正常,0:暂停',</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`user_id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Long user_id;</span><br><span class="line"><span class="keyword">private</span> String user_code;</span><br><span class="line"><span class="keyword">private</span> String user_name;</span><br><span class="line"><span class="keyword">private</span> String user_password;</span><br><span class="line"><span class="keyword">private</span> Character user_state;</span><br><span class="line"><span class="comment">//表达多对多</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Role&gt; roles = <span class="keyword">new</span> HashSet&lt;Role&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">  CREATE TABLE `sys_role` (</span></span><br><span class="line"><span class="comment">  `role_id` bigint(32) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  `role_name` varchar(32) NOT NULL COMMENT '角色名称',</span></span><br><span class="line"><span class="comment">  `role_memo` varchar(128) DEFAULT NULL COMMENT '备注',</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`role_id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long role_id;</span><br><span class="line"><span class="keyword">private</span> String role_name;</span><br><span class="line"><span class="keyword">private</span> String role_memo;</span><br><span class="line"><span class="comment">//表达多对多</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;User&gt; users = <span class="keyword">new</span> HashSet&lt;User&gt;();</span><br></pre></td></tr></table></figure><ul><li><p>创建xml映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"cn.itcast.domain"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"sys_user"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"user_id"</span>  &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user_code"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user_name"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user_password"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user_state"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多对多关系表达 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">name: 集合属性名</span></span><br><span class="line"><span class="comment">table: 配置中间表名</span></span><br><span class="line"><span class="comment">key</span></span><br><span class="line"><span class="comment"> |-column:外键,别人引用"我"的外键列名</span></span><br><span class="line"><span class="comment"> class: 我与哪个类是多对多关系</span></span><br><span class="line"><span class="comment"> column:外键.我引用比人的外键列名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- cascade级联操作:</span></span><br><span class="line"><span class="comment"> save-update: 级联保存更新</span></span><br><span class="line"><span class="comment"> delete:级联删除</span></span><br><span class="line"><span class="comment"> all:级联保存更新+级联删除</span></span><br><span class="line"><span class="comment"> 结论: cascade简化代码书写.该属性使不使用无所谓. 建议要用只用save-update.</span></span><br><span class="line"><span class="comment">  如果使用delete操作太过危险.尤其在多对多中.不建议使用.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"roles"</span> <span class="attr">table</span>=<span class="string">"sys_user_role"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"user_id"</span> &gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"Role"</span> <span class="attr">column</span>=<span class="string">"role_id"</span> &gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC </span></span><br><span class="line"><span class="meta">    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"cn.itcast.domain"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Role"</span> <span class="attr">table</span>=<span class="string">"sys_role"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"role_id"</span>  &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"role_name"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"role_memo"</span>  &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用inverse属性</span></span><br><span class="line"><span class="comment">true: 放弃维护外键关系</span></span><br><span class="line"><span class="comment">false(默认值):维护关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结论: 将来在开发中,如果遇到多对多关系.一定要选择一方放弃维护关系.</span></span><br><span class="line"><span class="comment"> 一般谁来放弃要看业务方向. 例如录入员工时,需要为员工指定所属角色.</span></span><br><span class="line"><span class="comment"> 那么业务方向就是由员工维护角色. 角色不需要维护与员工关系.角色放弃维护</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"users"</span> <span class="attr">table</span>=<span class="string">"sys_user_role"</span> <span class="attr">inverse</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"role_id"</span> &gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">"User"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> &gt;</span><span class="tag">&lt;/<span class="name">many-to-many</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">#hibernate.dialect org.hibernate.dialect.MySQLDialect</span></span><br><span class="line"><span class="comment">#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect</span></span><br><span class="line"><span class="comment">#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect</span></span><br><span class="line"><span class="comment">#hibernate.connection.driver_class com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#hibernate.connection.url jdbc:mysql:///test</span></span><br><span class="line"><span class="comment">#hibernate.connection.username gavin</span></span><br><span class="line"><span class="comment">#hibernate.connection.password</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库url --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///hibernate_32<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库连接用户名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 数据库连接密码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>1234<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库方言</span></span><br><span class="line"><span class="comment">不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.</span></span><br><span class="line"><span class="comment">sql99标准: DDL 定义语言  库表的增删改查</span></span><br><span class="line"><span class="comment">  DCL 控制语言  事务 权限</span></span><br><span class="line"><span class="comment">  DML 操纵语言  增删改查</span></span><br><span class="line"><span class="comment">注意: MYSQL在选择方言时,请选择最短的方言.</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- #hibernate.show_sql true </span></span><br><span class="line"><span class="comment"> #hibernate.format_sql true</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将hibernate生成的sql语句打印到控制台 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将hibernate生成的sql语句格式化(语法缩进) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">## auto schema export  自动导出表结构. 自动建表</span></span><br><span class="line"><span class="comment">#hibernate.hbm2ddl.auto create自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)</span></span><br><span class="line"><span class="comment">#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).</span></span><br><span class="line"><span class="comment">#hibernate.hbm2ddl.auto validate校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入orm元数据</span></span><br><span class="line"><span class="comment">路径书写: 填写src下的路径</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 指定hibernate操作数据库时的隔离级别 </span></span><br><span class="line"><span class="comment">#hibernate.connection.isolation 1|2|4|8</span></span><br><span class="line"><span class="comment">00011读未提交</span></span><br><span class="line"><span class="comment">00102读已提交</span></span><br><span class="line"><span class="comment">01004可重复读</span></span><br><span class="line"><span class="comment">10008串行化</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.isolation"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 指定session与当前线程绑定 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/itcast/domain/Customer.hbm.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/itcast/domain/LinkMan.hbm.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/itcast/domain/Role.hbm.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"cn/itcast/domain/User.hbm.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//保存员工以及角色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 获得session</span></span><br><span class="line">Session session = HibernateUtils.openSession();</span><br><span class="line"><span class="comment">//2 开启事务</span></span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//3操作</span></span><br><span class="line"><span class="comment">//1&gt; 创建两个 User</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User();</span><br><span class="line">u1.setUser_name(<span class="string">"郝强勇"</span>);</span><br><span class="line"></span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">u2.setUser_name(<span class="string">"金家德"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2&gt; 创建两个 Role</span></span><br><span class="line">Role r1 = <span class="keyword">new</span> Role();</span><br><span class="line">r1.setRole_name(<span class="string">"保洁"</span>);</span><br><span class="line"></span><br><span class="line">Role r2 = <span class="keyword">new</span> Role();</span><br><span class="line">r2.setRole_name(<span class="string">"保安"</span>);</span><br><span class="line"><span class="comment">//3&gt; 用户表达关系</span></span><br><span class="line">u1.getRoles().add(r1);</span><br><span class="line">u1.getRoles().add(r2);</span><br><span class="line"></span><br><span class="line">u2.getRoles().add(r1);</span><br><span class="line">u2.getRoles().add(r2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4&gt; 角色表达关系</span></span><br><span class="line">r1.getUsers().add(u1);</span><br><span class="line">r1.getUsers().add(u2);</span><br><span class="line"></span><br><span class="line">r2.getUsers().add(u1);</span><br><span class="line">r2.getUsers().add(u2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5&gt; 调用Save方法一次保存</span></span><br><span class="line">session.save(u1);</span><br><span class="line">session.save(u2);</span><br><span class="line">session.save(r1);</span><br><span class="line">session.save(r2);</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//4提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//5关闭资源</span></span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//为郝强勇新增一个角色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 获得session</span></span><br><span class="line">Session session = HibernateUtils.openSession();</span><br><span class="line"><span class="comment">//2 开启事务</span></span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//3操作</span></span><br><span class="line"><span class="comment">//1&gt; 获得郝强勇用户</span></span><br><span class="line">User user = session.get(User.class, <span class="number">1l</span>);</span><br><span class="line"><span class="comment">//2&gt; 创建公关角色</span></span><br><span class="line">Role r = <span class="keyword">new</span> Role();</span><br><span class="line">r.setRole_name(<span class="string">"男公关"</span>);</span><br><span class="line"><span class="comment">//3&gt; 将角色添加到用户中</span></span><br><span class="line">user.getRoles().add(r);</span><br><span class="line"><span class="comment">//4&gt; 将角色转换为持久化</span></span><br><span class="line"><span class="comment">//session.save(r);</span></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//4提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//5关闭资源</span></span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//为郝强勇解除一个角色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1 获得session</span></span><br><span class="line">Session session = HibernateUtils.openSession();</span><br><span class="line"><span class="comment">//2 开启事务</span></span><br><span class="line">Transaction tx = session.beginTransaction();</span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//3操作</span></span><br><span class="line"><span class="comment">//1&gt; 获得郝强勇用户</span></span><br><span class="line">User user = session.get(User.class, <span class="number">1l</span>);</span><br><span class="line"><span class="comment">//2&gt; 获得要操作的角色对象(保洁,保安)</span></span><br><span class="line">Role r1 = session.get(Role.class, <span class="number">1l</span>);</span><br><span class="line">Role r2 = session.get(Role.class, <span class="number">2l</span>);</span><br><span class="line"><span class="comment">//3&gt; 将角色从用户的角色集合中移除</span></span><br><span class="line">user.getRoles().remove(r1);</span><br><span class="line">user.getRoles().remove(r2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">//4提交事务</span></span><br><span class="line">tx.commit();</span><br><span class="line"><span class="comment">//5关闭资源</span></span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在多对多的保存操作中,如果进行双向维护关系,就必须有一方放弃外键维护权,一般由被动方放弃,用户主动选择角色,角色是被选择的,所以一般角色要放弃外键维护权,但如果只进行单向维护关系,那么就不需要放弃外键维护权了.</p></li><li><p>级联更新保存,删除与一对多同理.</p></li></ul><h2 id="Hibernate-day04"><a href="#Hibernate-day04" class="headerlink" title="Hibernate-day04"></a>Hibernate-day04</h2><h3 id="一-Hibernate的检索方式"><a href="#一-Hibernate的检索方式" class="headerlink" title="一.Hibernate的检索方式"></a>一.Hibernate的检索方式</h3><ol><li><p><strong>Hibernate检索方式</strong></p><ul><li>对象图导航检索</li><li>OID检索</li><li>HQL检索</li><li>QBC检索</li><li>SQL检索</li></ul></li><li><p><strong>详解</strong></p><ul><li><p>对象图导航检索</p><p><code>对象图导航检索方式是根据已加载的对象,导航到他的关联对象,它利用类与类之间的关系来检索对象(如要查找一个联系人对应的客户,就可以由联系人对象自动导航到联系人所属的客户对象,前提必须在对象关系映射上配置了多对一的关系)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象图导航检索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Object</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    LinkMan linkMan = session.get(LinkMan.class, <span class="number">4L</span>);</span><br><span class="line">    Customer customer = linkMan.getCustomer();</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OID检索方式</p><p><code>OID检索方式主要是指用Session的get(),load()方法加载某条记录对应的对象</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OID检索</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Oid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line">    Customer customer = session.get(Customer.class, <span class="number">2L</span>);</span><br><span class="line">    LinkMan linkMan = session.load(LinkMan.class, <span class="number">4L</span>);</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">    System.out.println(linkMan);</span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HQL检索</p><p><code>HQL是面向对象的查询语言,它和sql查询语言有些相似,但它使用的是类,对象和属性的概念,而没有表和字段的概念,HQL是Hibernate推荐的查询语言,也是最广泛的一种检索方式,具有以下功能</code></p><ul><li><p>在查询语句中设定各种查询条件</p></li><li><p>支持投影查询,即仅检索出对象的部分属性</p></li><li><p>支持分页查询</p></li><li><p>支持分组查询,允许使用group by 和 having关键字</p></li><li><p>提供内置聚集函数,如sum(),min()和max()等</p></li><li><p>能够调用用户定义的SQL函数</p></li><li><p>支持子查询,即嵌套查询</p></li><li><p>支持动态绑定参数</p><p>Hibernate提供的Query接口是专门的HQL查询接口,他能执行各种复杂的HQL查询语句</p><p>由于Hibernate是面向对象的所以当我们在查询的时候需要写的是实体类的类名,而不是数据库表名(区分大小写)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HQL基本检索</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">       Session session = sessionFactory.openSession();</span><br><span class="line">       Transaction transaction = session.beginTransaction();</span><br><span class="line">       <span class="comment">//查询全部</span></span><br><span class="line">       String hql = <span class="string">"from Customer"</span>;</span><br><span class="line">       Query query = session.createQuery(hql);</span><br><span class="line">       List&lt;Customer&gt; list = query.list();</span><br><span class="line">       <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">           System.out.println(customer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//排序查询</span></span><br><span class="line">       String hqlOrderBy = <span class="string">"from Customer order by cust_id desc"</span>;</span><br><span class="line">       Query query1 = session.createQuery(hqlOrderBy);</span><br><span class="line">       List&lt;Customer&gt; list1 = query1.list();</span><br><span class="line">       <span class="keyword">for</span> (Customer customer : list1) &#123;</span><br><span class="line">           System.out.println(customer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//条件查询</span></span><br><span class="line">       String hqlWhereName = <span class="string">"from Customer where cust_name = ?0"</span>;</span><br><span class="line">       Query query2 = session.createQuery(hqlWhereName);</span><br><span class="line">       Query alibaba = query2.setParameter(<span class="number">0</span>, <span class="string">"alibaba"</span>);</span><br><span class="line">       List&lt;Customer&gt; list2 = alibaba.list();</span><br><span class="line">       <span class="keyword">for</span> (Customer customer : list2) &#123;</span><br><span class="line">       System.out.println(customer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//分页检索</span></span><br><span class="line">       String limitHql = <span class="string">"from Customer order by cust_id desc "</span>;</span><br><span class="line">       Query query3 = session.createQuery(limitHql);</span><br><span class="line">       <span class="comment">//起始页</span></span><br><span class="line">      query3.setFirstResult(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//显示数量</span></span><br><span class="line">      query3.setMaxResults(<span class="number">2</span>);</span><br><span class="line">       List&lt;Customer&gt; list3 = query3.list();</span><br><span class="line">       <span class="keyword">for</span> (Customer customer : list3) &#123;</span><br><span class="line">           System.out.println(customer);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//统计查询</span></span><br><span class="line">       String CountHql = <span class="string">"select count(*) from Customer"</span>;</span><br><span class="line">       Query query4 = session.createQuery(CountHql);</span><br><span class="line">       Long num = (Long) query4.uniqueResult();</span><br><span class="line">       System.out.println(<span class="string">"共查询到"</span>+num);</span><br><span class="line">     </span><br><span class="line">       <span class="comment">//投影检索</span></span><br><span class="line">       <span class="comment">//投影查询一列</span></span><br><span class="line">       List&lt;String&gt; list4 = session.createQuery(<span class="string">"select cust_name from Customer"</span>).list();</span><br><span class="line">       <span class="keyword">for</span> (String s : list4) &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">       transaction.commit();</span><br><span class="line">       session.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>QBC检索</p><p><code>QBC是Hibernte提供的另一种检索对象的方式,它主要由Criteria接口,Criterion接口和Expression接口类组成,Criteria接口是Hibernate API中的一个查询接口,他需要由session进行创建,Crterion是Criteria的查询条件,在Criteria中提供了add(Criterion criterion)方法来添加查询条件.</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qbc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">       Session session = sessionFactory.openSession();</span><br><span class="line">       Transaction transaction = session.beginTransaction();</span><br><span class="line">       Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">       Criteria custId = criteria.add(Restrictions.eq(<span class="string">"cust_id"</span>, <span class="number">1L</span>));</span><br><span class="line">       List list = custId.list();</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       transaction.commit();</span><br><span class="line">       session.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>Restrictions类提供的方法</li></ul></li></ol><p><img src="/2019/07/10/Hibernate总结/1558162391908.png" alt="1558162391908"></p><ol start="3"><li><p><strong>离线条件检索(DetachedCriteria)</strong></p><p>我们知道Criteria对象必须由session对象来创建,那么也就是说必须先有session才可以生成Criteria对象,而DetachedCriteria对象可以在其他层对条件进行封装</p><p>==优点==:在做一些特别复杂的条件查询的时候,往往会在web层向业务层传递很多的参数,业务层又会将这些参数传递给DAO层,最后在DAO中拼接SQL完成查询.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DetachedCriteria</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得一个离线条件查询的对象</span></span><br><span class="line">        DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);</span><br><span class="line">        detachedCriteria.add(Restrictions.eq(<span class="string">"cust_name"</span>,<span class="string">"alibaba"</span>));</span><br><span class="line">        SessionFactory sessionFactory = <span class="keyword">new</span> Configuration().configure().buildSessionFactory();</span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">//离线条件查询对象与session绑定</span></span><br><span class="line">        List&lt;Customer&gt; list = detachedCriteria.getExecutableCriteria(session).list();</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : list) &#123;</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二-Hibernate多表查询"><a href="#二-Hibernate多表查询" class="headerlink" title="二.Hibernate多表查询"></a>二.Hibernate多表查询</h3><ul><li><h4 id="HQL连接查询"><a href="#HQL连接查询" class="headerlink" title="HQL连接查询"></a>HQL连接查询</h4><ul><li><p>HQL的多表连接查询的分类</p><ul><li>内连接<ul><li>显示内连接</li><li>隐式内连接</li><li>==迫切内连接==</li></ul></li><li>外连接<ul><li>左外连接</li><li>右外连接</li><li>==迫切左外连接==</li></ul></li></ul></li><li><p>SQL与HQL语句简单比较</p><ul><li><p>sql连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> cst_customer <span class="keyword">join</span> cst_linkman <span class="keyword">on</span> cst_customer.cust_id = cst_linkman.lkm_cust_id;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>HQL连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Customer join Customer.linkMans</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="三-Hibernate抓取策略"><a href="#三-Hibernate抓取策略" class="headerlink" title="三.Hibernate抓取策略"></a>三.Hibernate抓取策略</h3><ul><li><p><strong>抓取策略</strong></p><ul><li><p>抓取策略是当应用程序需要在(Hibernate实体对象图的)关联关系间进行导航的时候,Hibernate如何获取关联对象的策略.</p></li><li><p>Hibernate的抓取策略是Hibernate提升性能的一种手段,可以在获取关联对象的时候,对发送的语句进行优化,往往抓取策略需要和延迟加载一起使用来提升性能.</p></li><li><p>抓取策略配置</p><p><img src="/2019/07/10/Hibernate总结/1558167014786.png" alt="1558167014786"></p></li></ul></li></ul><ul><li><p><strong>延迟加载分类</strong></p><ul><li><p>延迟加载(lazy load)也称为懒加载,Hibernate关联关系对象默认的加载方式,延迟加载是为了避免一些无谓的性能开销而提出来的,所谓的延迟加载就是当在真正需要数据的时候,才真正执行数据加载操作.</p></li><li><p>通常将延迟加载分为两类.</p><ul><li><p>类级别延迟</p><ul><li>指的是查询某个对象的时候,是否采用有延迟,通常在<class>标签上配置lazy属性默认为true,表示延迟加载</class></li></ul></li><li><p>关联级别延迟</p><ul><li>指查询一个对象的关联对象的时候是否采用延迟加载,通常在<set>或<many-to-one>上配置lazy属性</many-to-one></set></li></ul></li></ul></li></ul></li></ul><p><img src="/2019/07/10/Hibernate总结/1558166823799.png" alt="1558166823799"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hibernate笔记&quot;&gt;&lt;a href=&quot;#Hibernate笔记&quot; class=&quot;headerlink&quot; title=&quot;Hibernate笔记&quot;&gt;&lt;/a&gt;Hibernate笔记&lt;/h2&gt;&lt;h3 id=&quot;day01&quot;&gt;&lt;a href=&quot;#day01&quot; class
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="ORM" scheme="http://yoursite.com/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>struts</title>
    <link href="http://yoursite.com/2019/07/09/struts/"/>
    <id>http://yoursite.com/2019/07/09/struts/</id>
    <published>2019-07-09T15:57:24.000Z</published>
    <updated>2019-07-09T16:13:52.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h2><h3 id="1-Struts2框架概述"><a href="#1-Struts2框架概述" class="headerlink" title="1. Struts2框架概述"></a>1. Struts2框架概述</h3><ul><li><p>Struts2是一个基于MVC模式的轻量级web框架，本质上相当于servlet，在MVC设计模式中，Struts2作为控制器来控制与模型视图的数据交互。</p></li><li><p>前端控制器</p><ul><li>在传统方式开发中，有一次请求就会对应一个Servlet，这样会导致出现很多Servlet。而Struts2将所有的请求都先经过一个前端控制器，在前端控制器中实现框架的部分功能，剩下具体操作要提交到具体的Action中，那么所有的请求都会经过前端控制器（本质上就是一个过滤器）</li></ul><p><img src="/2019/07/09/struts/1558174458049.png" alt="1558174458049"></p></li></ul><h3 id="2-Struts2入门"><a href="#2-Struts2入门" class="headerlink" title="2. Struts2入门"></a>2. Struts2入门</h3><ul><li><p>项目目录结构</p><p><img src="/2019/07/09/struts/1558229004769.png" alt="1558229004769"></p></li><li><p>项目需要的jar包</p><p><img src="/2019/07/09/struts/1558229089988.png" alt="1558229089988"></p></li><li><p>目录内容详解</p><ol><li><p>在index.jsp中编写Action的访问路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Mr Yan</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">5</span>/<span class="number">18</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">30</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Struts2入门&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"> &lt;a href="$&#123;pageContext.request.contextPath&#125;/strutsDemo1.action"&gt;success入门&lt;/a&gt;</span><br><span class="line"> &lt;a href="$&#123;pageContext.request.contextPath&#125;/strutsDemo2.action"&gt;error入门&lt;/a&gt;</span><br><span class="line"> &lt;a href="$&#123;pageContext.request.contextPath&#125;/strutsDemo3.action"&gt;success入门&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在包下新建StrutsDemo1的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrutsDemo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个默认的执行方法：execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StrutsDemo1中的execute执行了"</span>);</span><br><span class="line">        <span class="comment">//返回页面的名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StrutsDemo1中的execute执行了"</span>);</span><br><span class="line">        <span class="comment">//返回页面的名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在src根目录下创建名为struts.xml文件，用于配置struts2信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"strutsDemo1"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.StrutsDemo1"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"strutsDemo2"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.StrutsDemo1"</span> <span class="attr">method</span>=<span class="string">"execute1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>page/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"strutsDemo3"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.ActionDemo2"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置struts2的前端控制器(核心控制器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web目录下创建页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%--</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Created</span> <span class="attr">by</span> <span class="attr">IntelliJ</span> <span class="attr">IDEA.</span></span></span><br><span class="line"><span class="tag">  <span class="attr">User:</span> <span class="attr">Mr</span> <span class="attr">Yan</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Date:</span> <span class="attr">2019</span>/<span class="attr">5</span>/<span class="attr">18</span></span></span><br><span class="line"><span class="tag">  <span class="attr">Time:</span> <span class="attr">17:30</span></span></span><br><span class="line"><span class="tag">  <span class="attr">To</span> <span class="attr">change</span> <span class="attr">this</span> <span class="attr">template</span> <span class="attr">use</span> <span class="attr">File</span> | <span class="attr">Settings</span> | <span class="attr">File</span> <span class="attr">Templates.</span></span></span><br><span class="line"><span class="tag"><span class="attr">--</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  入门成功</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Tomcat启动服务</p><p><img src="/2019/07/09/struts/1558229740983.png" alt="1558229740983"></p><p><img src="/2019/07/09/struts/1558229764278.png" alt="1558229764278"></p></li></ol></li></ul><h3 id="3-Struts2工作流程"><a href="#3-Struts2工作流程" class="headerlink" title="3. Struts2工作流程"></a>3. Struts2工作流程</h3><pre><code>1. 客户端初始化一个指向**Servlet**容器的请求。2. 这个请求经过一系列的过滤器(**Filter**)(这些过滤器中有一个叫做**ActionContextCleanUp**的可选过滤器)。3. 接着**FilterDispatcher**被调用，**FilterDispatcher**询问**ActionMapper**来决定这个请求是否需要调用某个**Action**。4. 如果**ActionMapper**决定需要调用某个**Action**,**FilterDispatcher**把请求的处理交给**ActionProxy**。5. **ActionProxy**通过**Configuration Manager**询问框架的配置文件。6. **ActionProxy**创建一个**ActionInvocation**的实例。7. **ActionInvocation**实例使用命名模式来调用，在调用**Action**的过程前后，涉及到相关拦截器的调用。8. 一旦**Action**执行完毕，**ActionInvocation**负责根据**struts**。**xml**中的配置找到对应的返回结果，返回结果通常是一个需要被表示的**JSP**或者**FreeMarker**的模板，在表示的过程中可以使用**Struts2**框架中继承的标签，在这个过程中需要涉及到**ActionMapper**。9. 响应的返回是通过我们在**web.xml**中配置的过滤器。10. 如果**ActionContextCleanUp**是当前使用的，则**FilterDispatecher**将不会清理**sreadlocal ActionContext**,如果**ActionContextCleanUp**不使用，则将会去清理**sreadlocals**。</code></pre><p><img src="/2019/07/09/struts/1558233075767.png" alt="1558233075767"></p><h3 id="4-Struts-xml相关配置讲解"><a href="#4-Struts-xml相关配置讲解" class="headerlink" title="4.Struts.xml相关配置讲解"></a>4.Struts.xml相关配置讲解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   package标签</span></span><br><span class="line"><span class="comment">           name属性：必须，指定该包的名称，此名称是该包被其他包应用的key,只要在项目中不重名即可</span></span><br><span class="line"><span class="comment">           extends属性：必须，指定该包继承自其他包，通常都设置为struts-default</span></span><br><span class="line"><span class="comment">           namespace属性：必须，与action标签的name属性共同决定了访问路径，有三种配置方式</span></span><br><span class="line"><span class="comment">               默认名称空间：namespace=""</span></span><br><span class="line"><span class="comment">               根名称空间：namespace="/"</span></span><br><span class="line"><span class="comment">               带名称的名称空间：namespace="/demo1"</span></span><br><span class="line"><span class="comment">           abstract属性：可选，指定该包是否是一个抽象包，抽象包中不能包含Action定义</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       action标签：</span></span><br><span class="line"><span class="comment">           name属性：与namespace共同决定了访问路径</span></span><br><span class="line"><span class="comment">           class属性：Action类的全路径</span></span><br><span class="line"><span class="comment">           method属性：执行Action中的那个方法的方法名，默认值execute</span></span><br><span class="line"><span class="comment">           converter属性：用于设置类型转换器</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"strutsDemo1.save"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.StrutsDemo1"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-Struts2常量配置"><a href="#5-Struts2常量配置" class="headerlink" title="5.Struts2常量配置"></a>5.Struts2常量配置</h3><ul><li><p>在struts2中，提供了非常多的常量位于struts2-core-xxx.jar下org.apacha.struts2的default.properties内经常使用的有<code>struts.i18n.encoding=UTF-8</code>,<code>struts.action.exension=action</code>等</p></li><li><p>我们对他进行使用有三种方式。</p><ul><li><p>在Struts.xml中进行修改(通常修改此文件)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,,"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在struts.properties中进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struts.action.extension=action</span><br></pre></td></tr></table></figure></li><li><p>在web.xml中进行修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>struts.action.extension<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>do<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-struts分模块开发配置"><a href="#6-struts分模块开发配置" class="headerlink" title="6.struts分模块开发配置"></a>6.struts分模块开发配置</h3><ul><li><p>分模块开发的时候如果需要xml配置文件之间的相互引用使用include标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"com/ym/struts2/action/Struts-demo.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-Action的访问"><a href="#7-Action的访问" class="headerlink" title="7.Action的访问"></a>7.Action的访问</h3><ul><li><p>Action访问的三种方式</p><ul><li><p>Action类是POJO的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrutsDemo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供一个默认的执行方法：execute</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StrutsDemo1中的execute执行了"</span>);</span><br><span class="line">        <span class="comment">//返回页面的名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Action类实现一个Action的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Struts2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-05-20 09:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionDemo3</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值类型</span></span><br><span class="line"><span class="comment">     * SUCCESS:成功</span></span><br><span class="line"><span class="comment">     * ERROR:失败</span></span><br><span class="line"><span class="comment">     * LOGIN:登录出错页面跳转</span></span><br><span class="line"><span class="comment">     * INPUT:表单校验的时候出错</span></span><br><span class="line"><span class="comment">     * NONE:不跳转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ActionDemo3执行了"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Action类继承ActionSupper类</p><ul><li>推荐使用此方式，ActionSupport中提供了数据校验，国际化等一系列操作的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionDemo2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li><p>通过method访问</p><p><img src="/2019/07/09/struts/1558318236838.png" alt="1558318236838"></p></li><li><p>通过通配符的方式进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--*号的取值是啥，&#123;1&#125;代表的就是啥--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action_*"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.ActionDemo3"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态方法访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启动态方法访问--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.action.ActionDemo3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写访问路径</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/action!findAll.action"&gt;findAll&lt;/a&gt;</span><br><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/action!save.action"&gt;save&lt;/a&gt;</span><br><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/action!update.action"&gt;update&lt;/a&gt;</span><br><span class="line">&lt;a href="$&#123;pageContext.request.contextPath&#125;/action!delete.action"&gt;delete&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-Struts2的Servlet的API的访问"><a href="#8-Struts2的Servlet的API的访问" class="headerlink" title="8.Struts2的Servlet的API的访问"></a>8.Struts2的Servlet的API的访问</h3><ol><li><p>完全解耦合的方式</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/RequsetAction.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">      姓名:&lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">      密码:&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"RequsetAction"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.RequestDemo1"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo1</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//接收参数，利用Struts2中的对象ActionContext对象</span></span><br><span class="line">        ActionContext context = ActionContext.getContext();</span><br><span class="line">        <span class="comment">//调用ActionContext中的方法</span></span><br><span class="line">        <span class="comment">//类似于Map&lt;String,String[]&gt; request.getParameterMap();</span></span><br><span class="line">        Map&lt;String, Object&gt; map = context.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            String[] values = (String[]) map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">""</span>+ Arrays.toString(values));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//相当于request。setAttribute()</span></span><br><span class="line">        context.put(<span class="string">"reqName"</span>,<span class="string">"revValue"</span>);</span><br><span class="line">        <span class="comment">//相当于session.setAttribute()</span></span><br><span class="line">        context.getSession().put(<span class="string">"sessName"</span>,<span class="string">"sessValues"</span>);</span><br><span class="line">        <span class="comment">//相当于application.setAttribute</span></span><br><span class="line">        context.getApplication().put(<span class="string">"AppName"</span>,<span class="string">"AppValue"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==注：这种方式只能获得代表request,session,application的数据的Map集合，不能操作这些对象的本身的方法。==</p></li></ul></li><li><p>使用Servlet的API的原生方式</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/RequestApi.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">     姓名:&lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">     密码:&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用servlet API的方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"RequestApi"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.RequestDemo2"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//接受数据，直接获得request对象，通过ServletActionContext</span></span><br><span class="line">        HttpServletRequest request = ServletActionContext.getRequest();</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">""</span>+ Arrays.toString(values));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向域对象中保存数据,向request中保存数据</span></span><br><span class="line">        request.setAttribute(<span class="string">"reqName"</span>,<span class="string">"reqValues"</span>);</span><br><span class="line">        <span class="comment">//向session中保存数据</span></span><br><span class="line">        request.getSession().setAttribute(<span class="string">"sessName"</span>,<span class="string">"sessValue"</span>);</span><br><span class="line">        <span class="comment">//向application中保存数据</span></span><br><span class="line">        ServletActionContext.getServletContext().setAttribute(<span class="string">"appName"</span>,<span class="string">"appValue"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h6 id="注：使用此方式可以操作域对象的数据，同时也可以获得对象的方法。"><a href="#注：使用此方式可以操作域对象的数据，同时也可以获得对象的方法。" class="headerlink" title="==注：使用此方式可以操作域对象的数据，同时也可以获得对象的方法。=="></a>==注：使用此方式可以操作域对象的数据，同时也可以获得对象的方法。==</h6></li></ul></li><li><p>接口注入的方式</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;h3&gt;接口API&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/interfaceAPI.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    姓名:&lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码:&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用接口 API的方式--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"interfaceAPI"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.RequestDemo3"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDemo3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ServletRequestAware</span>,<span class="title">ServletContextAware</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="keyword">private</span> ServletContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//接收参数，通过接口注入的方式获得request对象</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">""</span>+ Arrays.toString(values));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向域对象中中保存数据，向request域中保存数据</span></span><br><span class="line">        request.setAttribute(<span class="string">"reqName"</span>,<span class="string">"reqValues"</span>);</span><br><span class="line">        <span class="comment">//向session中保存数据</span></span><br><span class="line">        request.getSession().setAttribute(<span class="string">"sessName"</span>,<span class="string">"sessValues"</span>);</span><br><span class="line">        <span class="comment">//向application中保存数据</span></span><br><span class="line">        context.setAttribute(<span class="string">"appName"</span>,<span class="string">"appValues"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletContext</span><span class="params">(ServletContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>==注：Servlet是单例的，多个程序访问同一个Servlet只会创建一个Servlet的实例，Action是多例的，一次请求，创建一个Action的实例(不会出现线程安全问题)。==</p></li></ul></li></ol><h3 id="9-Struts2的结果页面的配置"><a href="#9-Struts2的结果页面的配置" class="headerlink" title="9.Struts2的结果页面的配置"></a>9.Struts2的结果页面的配置</h3><ul><li><p>全局结果页面配置</p><ul><li>指在包中配置一次，其他的在这个包中的所有action只要返回了这个值，都可以跳转到这个页面，针对这个包中的所有的action的配置都有效。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">namespace</span>=<span class="string">"/"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--全局结果页面配置--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">global-results</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">global-results</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-result标签的配置"><a href="#10-result标签的配置" class="headerlink" title="10.result标签的配置"></a>10.result标签的配置</h3><ul><li>result标签用于配置页面的跳转，有两个属性<ul><li>name属性：逻辑视图的名称，默认值：success</li><li>type属性：页面跳转的类型<ul><li>dispatcher:默认值，请求转发(Action转发JSP)</li><li>redirect:重定向(Action重定向JSP)</li><li>chain:转发(Action转发Action)</li><li>redirectAction:重定向(Action重定向Action)</li><li>stream:Struts2中提供文件下载的功能</li></ul></li></ul></li></ul><h3 id="11-struts2的数据的封装"><a href="#11-struts2的数据的封装" class="headerlink" title="11.struts2的数据的封装"></a>11.struts2的数据的封装</h3><ol><li><p>属性驱动，提供属性的set方法的方式(不常用)</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;属性驱动：提供属性set方法的方式&lt;/h3&gt;</span><br><span class="line"> &lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/userAction1.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">     用户名:&lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     密码:&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span>&gt;&lt;br/&gt;</span><br><span class="line">     年龄:&lt;input name=<span class="string">"age"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     生日:&lt;input name=<span class="string">"birthday"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     工资:&lt;input name=<span class="string">"salary"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--set属性封装--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction1"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.UserAction"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供对应的属性</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(Double salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(birthday);</span><br><span class="line">        System.out.println(salary);</span><br><span class="line">        <span class="comment">//封装数据</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        user.setAge(age);</span><br><span class="line">        user.setBirthday(birthday);</span><br><span class="line">        user.setSalary(salary);</span><br><span class="line">        ActionContext context = ActionContext.getContext();</span><br><span class="line"><span class="comment">//        Map&lt;String, Object&gt; map = context.getParameters();</span></span><br><span class="line">       context.put(<span class="string">"user"</span>,user);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性驱动，页面中提供表达式方式</p><ul><li><p>编写jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;属性驱动：在页面中提供表达式方式&lt;/h3&gt;</span><br><span class="line"> &lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/userAction2.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">     用户名:&lt;input name=<span class="string">"user.username"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     密码:&lt;input name=<span class="string">"user.password"</span> type=<span class="string">"password"</span>&gt;&lt;br/&gt;</span><br><span class="line">     年龄:&lt;input name=<span class="string">"user.age"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     生日:&lt;input name=<span class="string">"user.birthday"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     工资:&lt;input name=<span class="string">"user.salary"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在页面中提供表达式的方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction2"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.UserAction2"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    提供User对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     提供set,get方法，一定要提供get方法，</span></span><br><span class="line"><span class="comment">     因为拦截器完成数据封装，需要创建user对象，</span></span><br><span class="line"><span class="comment">     通过get方法可以获得同一个对象，</span></span><br><span class="line"><span class="comment">     将数据封装到同一个对象中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模型驱动：采用模型驱动的方式(最常用)</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;模型驱动：采用模型驱动的方式&lt;/h3&gt;</span><br><span class="line"> &lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/userAction3.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">     用户名:&lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     密码:&lt;input name=<span class="string">"password"</span> type=<span class="string">"password"</span>&gt;&lt;br/&gt;</span><br><span class="line">     年龄:&lt;input name=<span class="string">"age"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     生日:&lt;input name=<span class="string">"birthday"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     工资:&lt;input name=<span class="string">"salary"</span> type=<span class="string">"text"</span>&gt;&lt;br/&gt;</span><br><span class="line">     &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--采用模型驱动的方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"userAction3"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.UserAction3"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span></span>&#123;</span><br><span class="line">    <span class="comment">//模型驱动使用的对象，前提必须手动提供对象的实例</span></span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//模型驱动需要使用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Struts2复杂数据类型的封装</p><ul><li><p>封装数据到List集合中</p><ul><li><p>编写jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;封装到List集合中，批量插入商品&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/productAction1.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    商品名称：&lt;input name=<span class="string">"products[0].name"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    商品价格：&lt;input name=<span class="string">"products[0].price"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    商品名称：&lt;input name=<span class="string">"products[1].name"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    商品价格：&lt;input name=<span class="string">"products[1].price"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    商品名称：&lt;input name=<span class="string">"products[2].name"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    商品价格：&lt;input name=<span class="string">"products[2].price"</span> type=<span class="string">"text"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"productAction1"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day02.ProductAction1"</span> <span class="attr">method</span>=<span class="string">"execute"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Action</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction1</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Products&gt; products;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Products&gt; <span class="title">getProducts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducts</span><span class="params">(List&lt;Products&gt; products)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.products = products;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Products product : products) &#123;</span><br><span class="line">            System.out.println(product);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        ActionContext context = ActionContext.getContext();</span></span><br><span class="line"><span class="comment">//        context.put("p",products);</span></span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="12-OGNL"><a href="#12-OGNL" class="headerlink" title="12.OGNL"></a>12.OGNL</h3><p><code>OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。</code></p><ul><li><p>Struts2使用OGNL的优势</p><ul><li>支持对象方法调用。如ObjName.methodName()</li><li>支持类静态方法调用和值访问，表达式的格式为@[全类名(包括包路径)]@[方法名 | 值名]。如@java.lang.String@format(‘foo %s’,’bar’)。</li><li>支持赋值操作和表达式串联。</li><li>访问OGNL上下文(OGNL context) 和ActionContext。</li><li>操作集合对象。</li></ul></li><li><p>OGNL三要素</p><ul><li>表达式<ul><li>OGNL的核心，OGNL会根据表达式去对象中取值，所有的OGNL操作都是针对表达式解析后进行的，表明了此次OGNL操作要“做什么”。表达式就是一个带有语法含义的字符串，这个字符串规定了操作的类型和操作的内容。OGNL支持大量的表达式语法，不仅支持这种“链式”对象访问路径，还支持在表达式中进行简单的计算。</li></ul></li><li>根对象<ul><li>Root对象可以理解为OGNL的操作语言，表达式规定了“做什么”，而Root对象则规定了“对谁操作”。OGNL称为对象图导航语言，所谓对象图，即以任意对象为根，通过OGNL可以访问与这个对象关联的其他对象。</li></ul></li><li>Context对象<ul><li>实际上OGNL的取值还需要一个上下文环境，设置了Root环境，OGNL可以对Root对象进行取值或写值等操作，Root对象所在环境就是OGNL的上下文环境(Context)。上下文环境规定了OGNL的操作“在哪里进行”。上下文环境Context是一个Map类型的对象，在表达式中访问Context中的对象，需要使用“#”号加上对象名称，即“#对象名称”的形式。</li></ul></li></ul></li><li><p>OGNL简单演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       demo demo = <span class="keyword">new</span> demo();</span><br><span class="line"><span class="comment">//       demo.demo1();</span></span><br><span class="line"><span class="comment">//       demo.demo2();</span></span><br><span class="line">       demo.demo3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//OGNL调用对象的方法</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        Object obj = Ognl.getValue(<span class="string">"'HelloWorld'.length()"</span>, context, context.getRoot());</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OGNL调用对象静态的方法</span></span><br><span class="line"><span class="comment">         * 格式：</span></span><br><span class="line"><span class="comment">         *      @类的全路径名@方法名(参数列表)</span></span><br><span class="line"><span class="comment">         *      @类的全路径名@属性名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        Object obj = Ognl.getValue(<span class="string">"@java.lang.Math@random()"</span>, context, context.getRoot());</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> <span class="keyword">throws</span> OgnlException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OGNL获取数据</span></span><br><span class="line"><span class="comment">         * 获取root中的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        OgnlContext context = <span class="keyword">new</span> OgnlContext();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//        user.setUsername("张三");</span></span><br><span class="line">        context.setRoot(<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"11111111"</span>,<span class="number">12</span>,<span class="keyword">new</span> Date(),<span class="number">12.3</span>));</span><br><span class="line">        Object username =  Ognl.getValue(<span class="string">"username"</span>, context,context.getRoot());</span><br><span class="line">        Object password =  Ognl.getValue(<span class="string">"password"</span>, context,context.getRoot());</span><br><span class="line">        Object age =  Ognl.getValue(<span class="string">"age"</span>, context,context.getRoot());</span><br><span class="line">        Object birthday =  Ognl.getValue(<span class="string">"birthday"</span>, context,context.getRoot());</span><br><span class="line">        Object salary =  Ognl.getValue(<span class="string">"salary"</span>, context,context.getRoot());</span><br><span class="line">        System.out.println(username+<span class="string">""</span>+password+<span class="string">""</span>+age+<span class="string">""</span>+birthday+<span class="string">""</span>+salary);</span><br><span class="line"><span class="comment">//        System.out.println(password);</span></span><br><span class="line"><span class="comment">//        System.out.println(age);</span></span><br><span class="line"><span class="comment">//        System.out.println(birthday);</span></span><br><span class="line"><span class="comment">//        System.out.println(salary);</span></span><br><span class="line"><span class="comment">//        System.out.println(username);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>struts2使用OGNL</p><ul><li><p>创建demo1ognl.jsp页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%--引入struts2标签--%&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ognl&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;OGNL在struts2环境中的入门&lt;/h1&gt;</span><br><span class="line">&lt;h3&gt;调用对象的方法&lt;/h3&gt;</span><br><span class="line">&lt;%--使用OGNL的标签--%&gt;</span><br><span class="line">&lt;h3&gt;调用对象的方法&lt;/h3&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"'struts2'.length()"</span>/&gt;</span><br><span class="line">&lt;h3&gt;调用对象的静态方法&lt;/h3&gt;</span><br><span class="line">&lt;%--静态方法在struts中默认是关闭的需要在struts.xml中开启--%&gt;</span><br><span class="line">&lt;s:property value=<span class="string">"@java.lang.Math@random()"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在struts.xml中关闭struts对静态资源的过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启struts静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.ognl.allowStaticMethodAccess"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>访问成功</p><p><img src="/2019/07/09/struts/1558409702790.png" alt="1558409702790"></p></li></ul></li></ul><h3 id="13-值栈"><a href="#13-值栈" class="headerlink" title="13.值栈"></a>13.值栈</h3><ul><li><p>什么是值栈</p><ul><li>ValueStack是Struts的一个接口，字面意义为值栈，OgnlValueStack是ValueStack的实现类，客户端发起一个请求，Struts2架构会创建一个action实例同时创建一个OgnlValueStack值栈实例，OgnlValueStack贯穿整个Action的生命周期，struts2中使用OGNL将请求Action的参数封装为对象存储到值栈中，并通过OGNL表达式读取值栈中的对象属性值。</li><li>valueStack类似于一个数据中转站(Struts2的框架当中的数据就都保存到了ValueStack中)<ul><li>ValueStack接口：实现类ognlValueStack对象。</li><li>ValueStack贯穿整个Action的生命周期。（Action一旦创建了，框架就会创建一个ValueStack对象）</li></ul></li></ul></li></ul><ul><li><p>值栈的内部结构</p><ul><li><p>在OgnlValueStack中包括两部分，值栈和map(即ognl上下文)</p><p><img src="/2019/07/09/struts/1558423520232.png" alt="1558423520232"></p></li></ul><ul><li><p>Context:即OgnlContext上下文，它是一个map结构，上下文中存储了一些引用，parameters，request，session，application等，上下文的Root为CompoundRoot。</p></li><li><p>OgnlContext中的一些引用</p><ul><li>parameters：该Map中包含当前请求的请求参数。</li><li>request：该Map中包含当前request对象中的所有属性。</li><li>session：该Map中包含当前session对象中的所有属性。</li><li>application：该Map中包含当前application对象中的所有属性</li><li>attr：该Map按如下顺序来检索某个属性：request,session,application</li></ul></li><li><p>CompoundRoot:存储了action实例，它作为OgnlContext的Root对象。</p><ul><li>CompoundRoot继承了ArrayList实现压栈和出栈功能，拥有栈的特点，先进先出，后进后出，最后压进栈的数据在栈顶，称之为对象栈。</li></ul></li><li><p>Struts2对原OGNL作出的改变就是Root使用CompoundRoot(自定义帐)，使用OgnlValueStack的findValue方法可以在CompoundRoot中从栈顶向栈底查找对象的属性值。</p></li><li><p>CompoundRoot作为OgnlContext的Root对象，并且在CompoundRoot中action实例位于栈顶，当读取action的属性值时会先从栈对象中找对应的属性，如果找不到则继续找栈中的其他对象，如果找到则停止查找。</p></li></ul></li><li><p>值栈与ActionContext的关系</p><ul><li>ActionContext：Action的上下文，通过看源码发现，当请求过来的时候，执行过滤器中的diFilter方法，在这个方法中创建ActionContext，在创建ActionContext过程中，创建ValueStack对象，将ValueStack对象传递给ActionContext对象，所以可以通过ActionContext获取值栈对象。</li><li>ActionContext对象之所以能够访问Servlet的API（访问的是域对象的数据）。因为在其内部有值栈的引用。</li></ul></li><li><p>获得值栈</p><ul><li>通过ActionContext对象获取值栈。</li><li>在struts2的内部，将值栈存入request中一份。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackdemo1</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过ActionContext对象获取值栈</span></span><br><span class="line">        ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br><span class="line">        <span class="comment">//通过request域获取值栈</span></span><br><span class="line">         ValueStack attribute = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);</span><br><span class="line">        <span class="comment">//true一个Action实例，只会创建一个ValueStack实例</span></span><br><span class="line">        System.out.println(valueStack == attribute);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>操作值栈-向值栈中存入数据</p><ol><li><p>在Action中提供属性的get方法的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackdemo2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"11111111"</span>,<span class="number">20</span>,<span class="keyword">new</span>  Date(),<span class="number">12.1</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ValueStack中本身的方法的方式(常用）。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackdemo3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向值栈中保存数据，获得值栈对象</span></span><br><span class="line">        ValueStack valueStack = ActionContext.getContext().getValueStack();</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"11111111"</span>,<span class="number">20</span>,<span class="keyword">new</span>  Date(),<span class="number">12.1</span>);</span><br><span class="line">        <span class="comment">//向值栈中放入对象</span></span><br><span class="line">        valueStack.push(user);</span><br><span class="line">        <span class="comment">//调用父类的方法默认返回success.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>success.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.ym.struts2.domain.User"</span> %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Mr Yan</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">5</span>/<span class="number">18</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">30</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;s:debug&gt;&lt;/s:debug&gt;</span><br><span class="line">       &lt;%--使用ValueStack本身的方法--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"username"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"password"</span>/&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取值栈数据</p><ul><li><p>获取值栈中的数据就是在页面中使用OGNL表达式    </p><ul><li>获取root的数据</li><li>获取context的数据(需要使用#)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackdemo4</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向值栈中保存一个对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"李四"</span>,<span class="string">"11111111"</span>,<span class="number">12</span>,<span class="keyword">new</span> Date(),<span class="number">12.3</span>);</span><br><span class="line">        ActionContext.getContext().getValueStack().push(user);</span><br><span class="line">        <span class="comment">//向值栈中保存一个集合</span></span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"11111111"</span>,<span class="number">13</span>,<span class="keyword">new</span> Date(),<span class="number">100.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">"王五"</span>,<span class="string">"11111111"</span>,<span class="number">13</span>,<span class="keyword">new</span> Date(),<span class="number">100.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="string">"赵六"</span>,<span class="string">"11111111"</span>,<span class="number">13</span>,<span class="keyword">new</span> Date(),<span class="number">100.0</span>));</span><br><span class="line">        ActionContext.getContext().getValueStack().set(<span class="string">"list"</span>,list);</span><br><span class="line">        <span class="comment">//向context中存入数据</span></span><br><span class="line">        <span class="comment">//request</span></span><br><span class="line">        ServletActionContext.getRequest().setAttribute(<span class="string">"周七"</span>,<span class="string">"22222222"</span>);</span><br><span class="line">        <span class="comment">//session</span></span><br><span class="line">        ServletActionContext.getRequest().getSession().setAttribute(<span class="string">"name"</span>,<span class="string">"哈哈"</span>);</span><br><span class="line">        <span class="comment">//application</span></span><br><span class="line">        ServletActionContext.getServletContext().setAttribute(<span class="string">"name"</span>,<span class="string">"yyy"</span>);</span><br><span class="line">        <span class="comment">//调用父类的方法默认返回success.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>success.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"com.ym.struts2.domain.User"</span> %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Mr Yan</span><br><span class="line">  Date: <span class="number">2019</span>/<span class="number">5</span>/<span class="number">18</span></span><br><span class="line">  Time: <span class="number">17</span>:<span class="number">30</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;s:debug&gt;&lt;/s:debug&gt;</span><br><span class="line">  &lt;%--使用ValueStack本身的方法--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"username"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"password"</span>/&gt;</span><br><span class="line">  &lt;%--从值栈中获取集合--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[0].username"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[0].password"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[1].username"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[1].password"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[2].username"</span>/&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"list[2].password"</span>/&gt;</span><br><span class="line">  &lt;%--获取context中的数据格式为</span><br><span class="line">    #request.username</span><br><span class="line">    #request.password</span><br><span class="line">  --%&gt;</span><br><span class="line">  &lt;%--获取request中的数据--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"#request.周七"</span>/&gt;</span><br><span class="line">  &lt;%--获取session中的数据--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"#session.name"</span>/&gt;</span><br><span class="line">  &lt;%--获取application中的数据--%&gt;</span><br><span class="line">  &lt;s:property value=<span class="string">"#application.name"</span>/&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="14-OGNL中特殊字符"><a href="#14-OGNL中特殊字符" class="headerlink" title="14.OGNL中特殊字符"></a>14.OGNL中特殊字符</h3><ul><li><p>#号</p><ul><li>获取context中的数据</li><li>使用#构建map集合</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;构建map集合&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;s:iterator <span class="keyword">var</span>=<span class="string">"i"</span> value=<span class="string">"&#123;'aa','bb','ccc'&#125;"</span>&gt;</span><br><span class="line">        &lt;s:property value=<span class="string">"i"</span>/&gt; -- &lt;s:property value=<span class="string">"#i"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br><span class="line">&lt;s:iterator value=<span class="string">"#&#123;'aaa':'11','bb':'22','cc':33&#125;"</span>&gt;</span><br><span class="line">    &lt;s:property value=<span class="string">"key"</span>/&gt;--&lt;s:property value=<span class="string">"value"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/s:iterator&gt;</span><br><span class="line">&lt;%--单选--%&gt;</span><br><span class="line">&lt;s:radio list=<span class="string">"#&#123;'1':'男','2':'女'&#125;"</span> name=<span class="string">"sex"</span> label=<span class="string">"性别"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>%号</p><ul><li><p>强制解析OGNL表达式</p></li><li><p>强制不解析OGNL表达式</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;%号的用法&lt;/h3&gt;</span><br><span class="line">&lt;%</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>,<span class="string">"ym"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%--强制解析--%&gt;</span><br><span class="line">姓名&lt;s:textfield name=<span class="string">"name"</span> value=<span class="string">"%&#123;#request.name&#125;"</span>/&gt;</span><br><span class="line">&lt;%--强制不解析--%&gt;</span><br><span class="line">姓名&lt;s:textfield name=<span class="string">"name"</span> value=<span class="string">"%&#123;'#request.name'&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/09/struts/1558451680695.png" alt="1558451680695"></p></li></ul></li><li><p>$号</p><ul><li>主要用于在配置文件中使用OGNL表达式</li></ul></li></ul><h3 id="15-Struts2拦截器"><a href="#15-Struts2拦截器" class="headerlink" title="15.Struts2拦截器"></a>15.Struts2拦截器</h3><ul><li>作用：起到拦截Action的作用。</li><li>Interceptor：拦截器，拦截是客户端对Action的访问，更细粒度化的拦截（拦截Action中的具体方法）</li><li>Struts2框架核心的功能都是以来与拦截器实现的。</li></ul><h3 id="16-拦截器demo"><a href="#16-拦截器demo" class="headerlink" title="16.拦截器demo"></a>16.拦截器demo</h3><ul><li><p>创建一个类实现Interceptor接口或继承AbstractInterceptor类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrutsInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截方法执行了"</span>);</span><br><span class="line">        String invoke = actionInvocation.invoke();</span><br><span class="line">        System.out.println(<span class="string">"拦截器执行完毕"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置struts.xml</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器进行拦截--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">interceptors</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"interceptor"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.day04.StrutsInterceptor"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">interceptors</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"valueStartdemo4"</span> <span class="attr">class</span>=<span class="string">"com.ym.struts2.ognl.ValueStackdemo4"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/page/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--在此方法上引入拦截器(一旦引入拦截器，默认的拦截器就不执行了，需要手动的引入)--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"interceptor"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>执行完毕</li></ul><p><img src="/2019/07/09/struts/1558496234242.png" alt="1558496234242"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts&quot;&gt;&lt;a href=&quot;#Struts&quot; class=&quot;headerlink&quot; title=&quot;Struts&quot;&gt;&lt;/a&gt;Struts&lt;/h2&gt;&lt;h3 id=&quot;1-Struts2框架概述&quot;&gt;&lt;a href=&quot;#1-Struts2框架概述&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="MVC" scheme="http://yoursite.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>多线程3线程池</title>
    <link href="http://yoursite.com/2019/03/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B3%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/03/22/多线程3线程池/</id>
    <published>2019-03-22T10:03:01.000Z</published>
    <updated>2019-07-17T07:58:15.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ul><li>多个线程在处理同一个资源,但是处理的动作(线程的任务)却不相同.</li></ul><h3 id="为什么要处理线程间通信"><a href="#为什么要处理线程间通信" class="headerlink" title="为什么要处理线程间通信"></a>为什么要处理线程间通信</h3><ul><li>多个线程并发执行时,在默认情况下cpu是随机切换线程的,当我们需要多个线程来共同完成一件任务,并且我们希望他们有规律的执行,那么多线程之间需要一些协调通信,以此来帮我们达到多线程共同操作一份数据.</li></ul><h3 id="如何保证线程之间通信有效利用资源"><a href="#如何保证线程之间通信有效利用资源" class="headerlink" title="如何保证线程之间通信有效利用资源"></a>如何保证线程之间通信有效利用资源</h3><ul><li>多个线程在处理同一个资源,并且任务不同时,需要线程通信来帮忙解决线程之间对同一个变量的使用或操作,就是多个线程在操作同一份数据时,避免对同一变量的争夺,也就是我们需要通过一定的手段使各个线程能够有效的利用资源,而这种手段即是——-<strong>等待唤醒机制</strong></li></ul><h3 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><ul><li>多个线程间的一种协作机制,谈到线程我们经常想到的是线程间的<strong>竞争</strong>,比如去争夺锁,但这并不是故事的全部,线程间也会有协作机制,就是在一个线程进行了规定的操作后,就进入等待机制<strong>wait()</strong>,等待其他现成代码执行完他们的指定代码后,再将其唤醒<strong>notify()</strong>;在多个线程进行等待时,如果需要,可以使用<strong>notifyAll()</strong>来唤醒所有等待线程.</li></ul><p><code>wait/notify就是线程间的一种协作机制</code></p><h4 id="等待唤醒的方法"><a href="#等待唤醒的方法" class="headerlink" title="等待唤醒的方法"></a>等待唤醒的方法</h4><ol><li><strong>wait</strong>:线程不再活动,不再参与调度,进入<strong>wait set</strong>中,因此不会浪费cpu资源,也不会去竞争锁,这时的线程状态即是<strong>WAITING</strong>.它还要等着别的线程执行一个特别的动作,即<strong>通知(notify)</strong>在这个对象上等待的线程从<strong>wait set</strong>中释放出来,重新进入到<strong>调度队列(ready queue)</strong>中</li><li><strong>notify</strong>:则选取所通知的<strong>wait set</strong>中的一个线程释放;如:餐馆有空位之后,等待最久的顾客最先入座.</li><li><strong>notifyAll</strong>:则释放所通知对象的<strong>wait set</strong>上的全部线程.</li></ol><h4 id="wait和notify方法注意事项"><a href="#wait和notify方法注意事项" class="headerlink" title="wait和notify方法注意事项"></a>wait和notify方法注意事项</h4><ol><li><strong>wait()</strong>方法与<strong>notify()</strong>方法必须要由同一个锁对象调用,因为:对应的锁对象可以通过<strong>notify</strong>唤醒使用同一个锁对象调用的<strong>wait()</strong>方法后的线程.</li><li><strong>wait()</strong>方法与<strong>notify()</strong>方法是<strong>Object</strong>的方法,因为:锁对象是任意类型对象,而任意对象的所属类都是继承了<strong>Object</strong>类的.</li><li><strong>wait()</strong>方法与<strong>notify()</strong>方法必须要在同步代码块或者是同步函数中使用,因为:必须要通过锁对象调用这2个方法.</li></ol><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><ul><li>以生产包子与消费包子为例</li><li>包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子 （即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。 接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包 子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取 决于锁的获取情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">    String pier;</span><br><span class="line">    String xianer;</span><br><span class="line">    <span class="comment">//包子资源是否存在.</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name, BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bz.flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃"</span>+bz.pier+bz.xianer+<span class="string">"包子"</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name, BaoZi bz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bz.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"包包子"</span>);</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    bz.pier = <span class="string">"牛肉"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"粉条"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bz.pier = <span class="string">"猪肉"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"大葱"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"包子包好了"</span> + bz.pier + bz.xianer);</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">"吃货"</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">"包子铺"</span>,bz);</span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出</li></ul><p><img src="/2019/03/22/多线程3线程池/%E5%8C%85%E5%8C%85%E5%AD%90.png" alt></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="传统创建线程缺点"><a href="#传统创建线程缺点" class="headerlink" title="传统创建线程缺点"></a>传统创建线程缺点</h3><ul><li>如果并发的线程数量很多,并且每一个线程都是执行一个时间很短的任务就结束,这样频繁的创建线程就会降低系统的效率,因为频繁的创建线程和销毁线程都需要时间.</li></ul><h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><ul><li>线程池就是一个容纳多个线程的容器,其中的线程可以反复使用,省去了频繁创建线程对象的操作,无需反复创建线程而消耗过多资源.</li></ul><p><img src="/2019/03/22/多线程3线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>降低资源消耗,减少了创建和销毁线程的次数,每个线程都可以被反复利用,可执行多个任务.</li><li>提高响应速度,当任务到达时,任务可以不需要等到线程创建就能立即执行.</li><li>提高线程的可管理性,可以根据系统的承受能力,调整线程池中工作线程的数目,防止因为消耗过多的内存,而把服务器搞挂(每个线程大约1MB内存)</li></ol><h4 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h4><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task); <span class="comment">//获取线程池中的某一个线程对象,并运行.</span></span><br></pre></td></tr></table></figure><p><img src="/2019/03/22/多线程3线程池/%E7%BA%BF%E7%A8%8B%E6%B1%A0api.png" alt></p></li></ul><p><img src="/2019/03/22/多线程3线程池/submitAPI.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我需要一个教练"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"教练来了"</span>);</span><br><span class="line">        System.out.println(<span class="string">"教我游泳,交完后,教练回到泳池"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        service.submit(mr);</span><br><span class="line">        service.submit(mr);</span><br><span class="line">        service.shutdown();    <span class="comment">//关闭线程池</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;等待唤醒机制&quot;&gt;&lt;a href=&quot;#等待唤醒机制&quot; class=&quot;headerlink&quot; title=&quot;等待唤醒机制&quot;&gt;&lt;/a&gt;等待唤醒机制&lt;/h2&gt;&lt;h3 id=&quot;线程间通信&quot;&gt;&lt;a href=&quot;#线程间通信&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程(2)并发</title>
    <link href="http://yoursite.com/2019/03/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B2%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2019/03/19/多线程2并发/</id>
    <published>2019-03-19T12:48:16.000Z</published>
    <updated>2019-07-17T07:58:24.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><strong>定义:</strong>如果有多个线程在同时运行,而这些线程可能会同时运行同一段代码,如果程序运行结果和单线程运行结果一致,而且其他变量的值也和预期一样,就称之为线程安全.</li><li>我们接下来通过一个抢票的例子来说明一下问题.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"售出票1张,还剩"</span> + ticket-- + <span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket bt1 = <span class="keyword">new</span> BuyTicket();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口1"</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口2"</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口3"</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>通过控制台输出我们可以看到票数出现了问题</code>,我们将其称之为线程不安全.</li></ul><p><img src="/2019/03/19/多线程2并发/%E4%B8%8D%E5%AE%89%E5%85%A8%E7%BA%BF%E7%A8%8B.png" alt="1553179327672"></p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li>当我们使用多线程访问同一个资源的时候,且多个线程都对资源有写的操作,就会出现问题(比如,在十字路口没有红绿灯,没有人指挥就容易出现意外)</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>java中提供了同步机制(<strong>Synchronized</strong>)来解决这个问题,共有三种同步方案.<br>  ​    ​    1. 同步代码块<br>  ​    ​    2. 同步方法<br>  ​    ​    3. 锁机制</li></ul><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul><li><p><strong>Synchronized</strong>关键字可以用于方法中的某个区域中,表示只对这个区块的资源实行互斥访问.</p></li><li><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要进行同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步锁<ul><li>对象的同步锁只是一个概念,可以想象为在对象上标记一个锁.</li><li>锁对象可以是任意类型</li><li>多线程对象,要使用同一把锁.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyTicket1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"售出票1张,还剩"</span>+ --ticket+<span class="string">"张"</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket1 bt1 = <span class="keyword">new</span> BuyTicket1();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口1"</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口2"</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(bt1,<span class="string">"窗口3"</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过查看控制台发现这个问题我们已经解决了.</li></ul><p><img src="/2019/03/19/多线程2并发/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png" alt="1553181542863"></p></li></ul><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul><li><p>使用<strong>Synchronized</strong>修饰的方法,叫做同步方法,保证每次只有一个线程在执行.</p></li><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    同步代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>同步锁 is who<ul><li>对于非static方法,同步锁就是this</li><li>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyTicket2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出1张票,还剩"</span>+ --ticket+<span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket2 bt2 = <span class="keyword">new</span> BuyTicket2();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(bt2,<span class="string">"线程1"</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(bt2,<span class="string">"线程2"</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(bt2,<span class="string">"线程3"</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><ul><li><p><strong>Lock</strong>机制提供了比<strong>Synchronized</strong>代码块和<strong>Synchronized</strong>方法更加广泛的锁,同步代码块/同步方法具有的功能<strong>Lock</strong>都有.</p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;<span class="comment">//加同步锁</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;  <span class="comment">//释放同步锁</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyTicket3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出1张票,还剩"</span>+ --ticket+<span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket3 bt3 = <span class="keyword">new</span> BuyTicket3();</span><br><span class="line">        Thread th1 = <span class="keyword">new</span> Thread(bt3,<span class="string">"线程1"</span>);</span><br><span class="line">        Thread th2 = <span class="keyword">new</span> Thread(bt3,<span class="string">"线程2"</span>);</span><br><span class="line">        Thread th3 = <span class="keyword">new</span> Thread(bt3,<span class="string">"线程3"</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><ul><li><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h3><ul><li>乐观锁是一种乐观思想，即认为读多写少，遇到并发的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，<strong>但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>(与上一次的版本号比较，如果一样则更新)，如果失败则要重复读-比较-写的操作。</li></ul></li><li><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a><strong>悲观锁</strong></h3><ul><li>悲观锁是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想要读写这个数据就会block直到拿到锁。java中的悲观锁就是<strong>Synchronized</strong>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。</li></ul></li><li><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h3><ul><li><p><strong>自旋锁原理非常简单，如果持有锁的线程能在很短的事件内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核线程的切换的消耗。</strong></p></li><li><p>线程自选是需要消耗cpu的(让cpu在做无用功)，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</p></li><li><p>如果持有锁的线程执行的时间超过自旋等待的最大时间仍没有释放锁，就会导致其他争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p></li><li><h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><ul><li>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋锁的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换。</li><li>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量的线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其他需要cpu的线程又不能获取到cpu，造成cpu的浪费，所以这种情况下要关闭自旋锁。</li></ul></li><li><h4 id="自旋锁的时间阈值-1-6引入了适应性自旋锁"><a href="#自旋锁的时间阈值-1-6引入了适应性自旋锁" class="headerlink" title="自旋锁的时间阈值(1.6引入了适应性自旋锁)"></a>自旋锁的时间阈值(1.6引入了适应性自旋锁)</h4><ul><li>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理，但是如果去选择自旋的执行时间呢？如果自旋的时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体的系统性能，因此自旋的周期选的额外重要。</li><li>JVM对于自旋周期的选择，jdk1.5这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的，基本认为一个线程上下文切换的时间是最佳的一个时间，同时JVM还针对当前CPU的负荷情况做了较多的优化，如果平均负载小于CPUs则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现Owner发生了变化则延迟自旋时间(自旋计数)或进入阻塞，如果CPU处于节点模式则停止自旋，自选时间的最坏情况是CPU的存储延迟(CPU A存储了一个数据，到CPU B得知这个数据直接的时间差)，自选时会适当放弃线程优先级之间的差异。</li></ul></li><li><h4 id="自旋锁的开启"><a href="#自旋锁的开启" class="headerlink" title="自旋锁的开启"></a>自旋锁的开启</h4><ul><li>JDK1.6中<code>-XX:+UseSpinning</code>开启。</li><li><code>-XX:PreBlockSpin=10</code>为自旋次数。</li><li>JDK1.7后，去掉此参数，由jvm控制。</li></ul></li></ul></li><li><h3 id="Synchronized同步锁"><a href="#Synchronized同步锁" class="headerlink" title="Synchronized同步锁"></a><strong>Synchronized同步锁</strong></h3><ul><li><p><strong>Synchronized</strong>可以把任意一个非NULL的对象作为锁，<strong>它属于独占式的悲观锁，同时属于可重入锁</strong>。</p></li><li><h4 id="Synchronized作用范围"><a href="#Synchronized作用范围" class="headerlink" title="Synchronized作用范围"></a>Synchronized作用范围</h4><ul><li>作用于方法时，锁住的是对象的实例(this)。</li><li>作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久代PermGen(jdk1.8是metaspace)，永久代是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁住所有调用该方法的线程。</li><li>作用于对象实例时，锁住的是所有以该对象为锁的代码块，它有多个队列，当多个线程一起访问某个对象监视器时，对象监视器会将这些线程存储在不同的容器中。</li></ul></li><li><h4 id="Synchronized核心组件"><a href="#Synchronized核心组件" class="headerlink" title="Synchronized核心组件"></a>Synchronized核心组件</h4><ul><li>Wait Set:哪些调用wait方法被阻塞的线程被放置在这里。</li><li>Contention List:竞争队列，所有请求锁的线程首先被放在这个竞争队列中。</li><li>Entry List:Contention List中那些有资格成为候选资源的线程被移动到Entry List中。</li><li>OnDeck:任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck。</li><li>Owner:当前已经获取到所有资源的线程被称为Owner。</li><li>!Owner:当前释放锁的线程。</li></ul></li></ul></li><li><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul><li><p><strong>ReentantLock</strong>实现接口<strong>Lock</strong>，它是一种可重入锁，除了能完成synchronized所能完成的所有工作外，<strong>还提供了诸如可响应中断锁，可轮询锁请求，定时锁等避免多线程死锁的方法</strong>。</p></li><li><h4 id="Lock接口中的主要方法"><a href="#Lock接口中的主要方法" class="headerlink" title="Lock接口中的主要方法"></a>Lock接口中的主要方法</h4><ul><li><code>void lock()</code>：执行方法时，<strong>如果锁处于空闲状态，当前线程将获取到锁</strong>，相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁。</li><li><code>boolean tryLock()</code>：<strong>如果锁可用，则获取锁，并立即返回true，否则返回false</strong>，该方法和lock()的区别在于，tryLock()只是“试图”获取锁，如果锁不可用，不会导致当前线程被禁用，当前线程仍然继续往下执行代码，而lock()方法则是一定要获取到锁，如果锁不可用，就一直等待，在未获得锁之前，当前线程并不继续向下执行。</li><li><code>void unlock()</code>:执行此方法时，当前线程将释放持有的锁，锁只能由持有者释放，如果线程并不持有锁，却执行该方法，可能会导致异常的发生。</li><li><code>Condition newCondition()</code>:条件对象，获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的<strong>await()</strong>方法，而调用后，当前线程将缩放锁。</li><li><code>void lockInterruptibly()</code>:如果当前线程未被中断，获取锁。</li></ul></li><li><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><ul><li>JVM按随机，就近原则分配锁的机制称为不公平锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁，非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</li></ul></li><li><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><ul><li>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</li></ul></li><li><h4 id="ReentrantLock和Synchronized"><a href="#ReentrantLock和Synchronized" class="headerlink" title="ReentrantLock和Synchronized"></a>ReentrantLock和Synchronized</h4><ul><li><strong>ReentrantLock</strong>通过方法<strong>lock()与unlock()</strong>来进行加锁与解锁操作，<strong>与synchronized会被JVM自动解析机制不同，ReentrantLock加锁后需要手动进行解锁</strong>，为了避免出现异常而无法正常解锁的情况，<strong>使用ReentrantLock必须在finally控制块中进行解锁操作</strong>。</li><li>ReentrantLock相比synchronized的优势是可中断，公平锁，多个锁。这种情况下需要使用ReentrantLock。</li></ul></li><li><h4 id="Condition和Object锁方法区别"><a href="#Condition和Object锁方法区别" class="headerlink" title="Condition和Object锁方法区别"></a>Condition和Object锁方法区别</h4><ul><li>Condition类的awiat()方法和Object类的wait()方法等效。</li><li>Condition类的signal()方法和Object类的notify()方法等效。</li><li>Condition类的signalAll()方法和Object类的notifyAll()方法等效。</li><li>ReentrantLock类恶意唤醒指定条件的线程，而Object的唤醒是随机的。</li></ul></li><li><h4 id="tryLock和lockInterruptibly的区别"><a href="#tryLock和lockInterruptibly的区别" class="headerlink" title="tryLock和lockInterruptibly的区别"></a>tryLock和lockInterruptibly的区别</h4><ul><li>tryLock能获得锁就返回true，不能就立即返回false,tryLock(long timeout,TimeUnit unit),可以增加时间限制，如果超过该时间段还没获得锁，返回false。</li><li>lock能获得锁就返回true，不能的话一直等待获得锁。</li><li>lock和lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lick不会抛出异常，而lockInterruptibly会抛出异常。</li></ul></li></ul></li><li><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul><li><p>Semaphore是一种基于计数的信号量，它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞，Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池。</p></li><li><h4 id="实现互斥锁-计数器为1"><a href="#实现互斥锁-计数器为1" class="headerlink" title="实现互斥锁(计数器为1)"></a>实现互斥锁(计数器为1)</h4><ul><li>可以创建计数为1的Semaphore,将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 只能5个线程同时访问</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 模拟20个客户端访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">20</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> NO = index;</span><br><span class="line">            Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取许可</span></span><br><span class="line">                        semp.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"Accessing: "</span> + NO);</span><br><span class="line">                        <span class="comment">//模拟实际业务逻辑</span></span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        <span class="comment">// 访问完后，释放</span></span><br><span class="line">                        semp.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(run);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Semaphore和ReentrantLock"><a href="#Semaphore和ReentrantLock" class="headerlink" title="Semaphore和ReentrantLock"></a>Semaphore和ReentrantLock</h4><ul><li>Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</li><li>Semaphore也<strong>实现了可轮询的锁请求与定时锁的功能</strong>，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致，Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</li><li>Semaphore的锁释放也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。</li></ul></li><li><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><ul><li>AtomicInteger 一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。此外，还可以通过 AtomicReference<t>将一个对象的所有操作转化成原子操作。</t></li><li>在多线程中，诸如++i或i++等运算不具有原子性，是不安全的线程操作之一，通常我们使用synchronized将该操作变成一个原子操作，但是JVM为此类操作特意提供了一些同步类，使得程序运行效率变得更高。</li></ul></li><li><h3 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h3><ul><li>可重入锁，也叫递归锁，<strong>指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响</strong>。在Java中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁。</li></ul></li><li><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><ul><li><h4 id="公平锁-Fair"><a href="#公平锁-Fair" class="headerlink" title="公平锁(Fair)"></a>公平锁(Fair)</h4><ul><li>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</li></ul></li><li><h4 id="非公平锁-Nonfair"><a href="#非公平锁-Nonfair" class="headerlink" title="非公平锁(Nonfair)"></a>非公平锁(Nonfair)</h4><ul><li>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。</li><li><strong>非公平锁性能比公平锁高5~10倍</strong>，因为公平锁需要在多核的情况下维护一个队列。</li><li>Java中的<code>synchronized</code>是非公平锁，<code>ReentrantLock默认的lock()</code>方法采用的是非公平锁。</li></ul></li></ul></li><li><h3 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock(读写锁)"></a>ReadWriteLock(读写锁)</h3><ul><li><p><strong>为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制</strong>，如果在没有写锁的情况下，读是无阻塞的，在一定程度下提高了程序的执行效率，读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由JVM控制的，我们只要上好相应的锁即可。</p></li><li><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><ul><li>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁。</li></ul></li><li><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><ul><li>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁，总之，<strong>读的时候上读锁，写的时候上写锁</strong>。</li></ul></li></ul></li><li><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><ul><li><p>java并发包提供的加锁模式为独占锁和共享锁。</p></li><li><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><ul><li>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占的方式实现的互斥锁，独占锁是一种悲观保守的加锁策略，避免了读/读冲突，如果某个只读线程获取锁，则其他读线程只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</li></ul></li><li><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><ul><li>共享锁允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，放宽了加锁策略，允许多个执行读操作的线程同时访问共享数据。</li><li>AQS的内部类Node定义了两个常量SHARED和EXCLUSIVE，分别标识AQS队列中等待线程的锁获取模式。</li><li>java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。</li></ul></li></ul></li><li><h3 id="重量级锁-Mutex-Lock"><a href="#重量级锁-Mutex-Lock" class="headerlink" title="重量级锁(Mutex Lock)"></a>重量级锁(Mutex Lock)</h3><ul><li>Synchronized是通过对象内部的一个叫监视器锁(monitor)来实现的，但是监视器锁本质又是依赖于底层操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换这就需要从用户态转到核心态，这个成本很高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock锁实现的锁我们称之为“<strong>重量级锁</strong>”。JDK对与Synchronized的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6以后，为了减少获取锁和释放锁带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</li></ul></li><li><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ul><li>锁的状态共有四种：无锁，偏向锁，轻量级锁和重量级锁。</li><li>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁(锁的升级只能从低到高，不会出现锁的降级)</li><li>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，但是，首先需要强调的是，轻量级锁并不是用来代替重量级锁的，它主要是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗，<strong>轻量级锁所使用的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</strong>。</li></ul></li><li><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><ul><li><strong>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入(CAS)的开销，看起来让这个线程得到了偏护</strong>。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗)。轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</li></ul></li><li><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><ul><li>分段锁并非一种实际的锁，而是一种思想<code>ConcurrentHashMap</code>是学习分段锁的最好例子。</li></ul></li><li><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul><li><h4 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h4><ul><li>只用在有线程安全要求的程序上加锁</li></ul></li><li><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul><li>将大对象，拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。</li></ul></li><li><h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h4><ul><li>最常见的锁分离就是读写锁ReadWriteLock,根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。</li></ul></li><li><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><ul><li>为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁，但是，<strong>如果对同一个锁不停的进行请求，同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化</strong>。</li></ul></li><li><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><ul><li>锁消除是在编译器级别的事情，在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为开发者编码不规范引起。</li></ul></li></ul></li></ul></li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="计时等待-Timed-Waiting"><a href="#计时等待-Timed-Waiting" class="headerlink" title="计时等待(Timed Waiting)"></a>计时等待(Timed Waiting)</h3><ul><li>一个正在限时等待另一个线程执行一个(唤醒)动作的线程处于这一状态,简单说就是当我们调用了sleep()方法后,当前线程就进入到”休眠状态’,其实就是所谓的<strong>Timed Waiting</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"===="</span>+i+<span class="string">"===="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程睡眠1秒! \n"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Timed Waiting线程状态图</li></ul><p><img src="/2019/03/19/多线程2并发/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt></p><h3 id="锁阻塞-Blocked"><a href="#锁阻塞-Blocked" class="headerlink" title="锁阻塞(Blocked)"></a>锁阻塞(Blocked)</h3><ul><li>一个正在阻塞等待一个监视器锁(锁对象)的线程处于这一状态.</li><li>线程A与线程B代码中使用同一把锁,如果线程A获取到锁,线程A进入到<strong>Runnable</strong>状态,那么线程B就进入到<strong>Blocked</strong>锁阻塞状态.</li></ul><p><img src="/2019/03/19/多线程2并发/%E9%94%81%E9%98%BB%E5%A1%9E.png" alt></p><h3 id="无限等待-Waiting"><a href="#无限等待-Waiting" class="headerlink" title="无限等待(Waiting)"></a>无限等待(Waiting)</h3><ul><li>一个正在无限期等待另一个线程执行一个特别的(唤醒)动作的线程处于这一状态.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait(<span class="number">5000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"获取到锁对象,调用wait方法,进入waiting状态,释放锁对象"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"等待线程"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"-----等待3秒钟"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"---获取到锁对象,调用notify()方法,释放锁对象"</span>);</span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"唤醒线程"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从上面我们发现,一个调用了某个对象的<strong>Object.wait()</strong>方法得线程会等待另一个线程调用此对象的<strong>Object.notify()</strong>方法或<strong>Object.notifyAll()</strong>方法.</p></li><li><p>其实<strong>waiting</strong>状态并不是一个线程的操作,它体现的是多个线程间的通信,可以理解为多个线程之间的协作关系,多个线程会争取锁,同时相互之间又存在协作关系.</p></li><li><p>当多个线程协作时,比如A,B线程,如果A线程在<strong>Runnable</strong>状态中调用了<strong>wait()</strong>方法,那么A线程就进入了<strong>Waiting</strong>(无限等待)状态,同时失去了同步锁,假如这个时候B线程获取到了同步锁,那么A线程唤醒后就进入了<strong>Runnable</strong>状态,如果没有获取锁对象,那么就进入<strong>Blocked</strong>状态.</p></li><li><p><strong>Wait()</strong></p><ul><li>让占用了这个同步对象的线程,临时释放当前的占用,并且等待,所以调用<strong>wait()</strong>是有条件的,一定实在<strong>Synchronized</strong>块中,否则就会出错.</li></ul></li><li><p><strong>notify()</strong></p><ul><li>通知一个等待在这个同步对象上的线程,你可以苏醒过来,有机会重新占用当前对象了.</li></ul></li><li><p><strong>NotifyAll()</strong></p><ul><li>通知所有的等待在这个同步对象的线程,你们可以苏醒过来了,有机会重新占用当前对象了.</li></ul><p><code>注:以上三方法均为Object上的方法</code></p><p><img src="/2019/03/19/多线程2并发/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85.png" alt></p></li></ul><p><a href="https://github.com/YanMao186/Thread" target="_blank" rel="noopener">源码github链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义:&lt;/strong&gt;如果有多个线程在同时运行,而这些线程可能会同时运行同一段代码,如果程序运
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程(1)基础</title>
    <link href="http://yoursite.com/2019/03/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/03/19/多线程/</id>
    <published>2019-03-19T09:11:11.000Z</published>
    <updated>2019-07-17T07:58:20.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><h2 id="相关概念讲解"><a href="#相关概念讲解" class="headerlink" title="相关概念讲解"></a>相关概念讲解</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>是指一个内存中运行的应用程序，每个进程都有独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li><p>进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为进程便相当于一个单CPU操作系统，而线程便是这个系统中运行的多个任务。</p></li><li><p><code>windows系统中任务管理器，下图</code></p></li></ul><p><img src="/2019/03/19/多线程/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="1552987356275"></p><ul><li><code>简单说如果进程是火车的话，那么线程就是火车的每一节车厢</code></li><li><code>多线程优点</code><ul><li>不会阻塞用户，因为线程是独立的，可以同时执行多个操作。</li><li>可以一起执行许多操作，节省时间。</li><li>线程是独立的，因此如果在单个线程中发生异常，他不会影响其他线程。</li></ul></li></ul><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><ul><li>指两个或两个以上事件在同一时刻发生。</li><li><code>简单说就是你在吃饭的时候，电话响了，你一边打电话，一边吃饭</code></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>指两个或多个事件在同一时间段内发生。</li><li><code>简单说就是你在吃饭的时候，电话响了，然后你去接电话，电话打完又接着吃饭</code></li></ul><p><img src="/2019/03/19/多线程/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.png" alt="1552987892866"></p><h3 id="多任务处理"><a href="#多任务处理" class="headerlink" title="多任务处理"></a>多任务处理</h3><ul><li>多任务处理是同时执行多个任务的过程，使用多任务来利用CPU，多任务处理可以通过两种方式实现：<ol><li>基于进程的多任务处理（多进程）</li><li>基于线程的多任务处理（多线程）</li></ol></li><li><strong>基于进程的多任务处理</strong><ul><li>每个进程在内存中都有一个地址，也就是说，每个进程分配一个单独的内存区域。</li><li>进程是重量级的。</li><li>进程之间通信的成本很高。</li><li>从一个进程切换到另一个进程需要一些时间来保存和加载寄存器，内存映射，更新列表等。</li></ul></li><li><strong>基于线程的多任务处理</strong><ul><li>线程共享相同的地址空间。</li><li>线程是轻量级的。</li><li>线程之间通信成本很低。</li><li>一次只能执行一个线程。</li></ul></li></ul><h2 id="线程的生命周期（线程状态）"><a href="#线程的生命周期（线程状态）" class="headerlink" title="线程的生命周期（线程状态）"></a>线程的生命周期（线程状态）</h2><ul><li>线程的生命周期，线程的生命周期由JVM控制。<ol><li><strong>初始(New)：</strong>新创建一个线程对象，但还没有调用<strong>start()</strong>方法。</li><li><strong>运行(Runnable)：</strong>java线程中将<strong>就绪(ready)</strong>和<strong>运行中(running)</strong>两种状态统称为“运行”。线程对象创建后，其他线程（如main线程）调用该对象的<strong>start()</strong>方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于<strong>就绪状态(ready)</strong>。就绪状态的线程在获得CPU时间后变为<strong>运行中状态(running)</strong>。</li><li><strong>阻塞(Blocked):</strong>表示线程阻塞于锁。</li><li><strong>等待(Waiting):</strong>进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)。</li><li><strong>超时等待(Timed_Waiting):</strong>该状态不同于<strong>Waiting</strong>，它可以在指定的时间后自行返回。</li><li><strong>终止(Terminated):</strong>表示该线程已经执行完毕。</li></ol></li></ul><p><img src="/2019/03/19/多线程/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt></p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ol><li><p><strong>新建(new):</strong>如果创建<strong>Thread</strong>类的实例但在调用<strong>start()</strong>方法前，线程处于新建(new)状态。</p></li><li><p><strong>就绪(Runnable)：</strong>调用<strong>start()</strong>方法后，线程处于<strong>runnable</strong>状态，但线程调度程序尚未选择它作为正在运行的线程。</p></li><li><p><strong>运行(Running)：</strong>如果线程调度程序已选择它，则线程处于运行状态.</p></li><li><p><strong>阻塞(Blocked):</strong>这时线程仍处于活动状态但当前没有资格运行的状态，阻塞分为三种：</p><ul><li><strong>等待阻塞(o.wait—&gt;等待队列):</strong>运行(running)中的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li><li><strong>同步阻塞(lock—&gt;锁池):</strong>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li><li><strong>其他阻塞(sleep/join):</strong>运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出I/O请求时，JVM会把该线程置为阻塞状态，当sleep()状态超时，join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></li><li><p><strong>终止(Terminated):</strong>线程处于终止或死亡状态,分为以下三种情况:</p><ul><li><strong>正常结束:</strong>run()或call()方法执行完毕，线程正常结束。</li><li><strong>异常结束:</strong>线程抛出一个未捕获的Exception或Error。</li><li><strong>调用stop:</strong>直接调用该线程的stop()方法来结束该线程，不推荐使用(易导致死锁)。</li></ul></li></ol><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li>创建线程的方式有<ul><li>通过继承<strong>Thread</strong>类</li><li>通过实现<strong>Runnable</strong>接口</li></ul></li></ul><h2 id="Thread类简单介绍"><a href="#Thread类简单介绍" class="headerlink" title="Thread类简单介绍"></a>Thread类简单介绍</h2><ul><li><strong>Thread</strong>类提供了在线程上创建和执行操作的构造函数和方法，<strong>Thread</strong>类扩展了<strong>Object</strong>类并实现了<strong>Runnable</strong>接口。</li></ul><p><img src="/2019/03/19/多线程/Thread%E7%B1%BB.png" alt="1552993473274"></p><h3 id="常用的Thread类构造函数"><a href="#常用的Thread类构造函数" class="headerlink" title="常用的Thread类构造函数"></a>常用的<strong>Thread</strong>类构造函数</h3><ul><li><code>Thread()</code></li><li><code>Thread(String name)</code></li><li><code>Thread(Runnable r)</code></li><li><code>Thread(Runnable r,String name)</code></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法名</th><th>概述</th></tr></thead><tbody><tr><td>public void run()</td><td>用于执行线程的操作</td></tr><tr><td>public void start()</td><td>开始执行线程，JVM调用线程上的run()方法</td></tr><tr><td>public void sleep(long miliseconds)</td><td>按指定的毫秒数等待线程死亡</td></tr><tr><td>public void join()</td><td>等待线程死亡</td></tr><tr><td>public void join(long miliseconds)</td><td>按指定的毫秒数等待线程死亡</td></tr><tr><td>public void getPriority()</td><td>返回线程的优先级</td></tr><tr><td>public void setPriority(int priority)</td><td>更改线程的优先级</td></tr><tr><td>public void stop()</td><td>用于停止线程(deprivated)</td></tr></tbody></table><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread1 th = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(th);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出</li></ul><p><img src="/2019/03/19/多线程/%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt></p><ul><li>join方法简单演示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:join()无参方法测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-21 20:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinDemo1 dj1 = <span class="keyword">new</span> JoinDemo1();</span><br><span class="line">        JoinDemo1 dj2 = <span class="keyword">new</span> JoinDemo1();</span><br><span class="line">        JoinDemo1 dj3 = <span class="keyword">new</span> JoinDemo1();</span><br><span class="line">        dj1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dj1.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        dj2.start();</span><br><span class="line">        dj3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li>我们可以看到当dj1执行完毕之后，dj2和dj3才开始执行</li><li>join(long miliseconds)方法简单演示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JoinDemo2 jd1 = <span class="keyword">new</span> JoinDemo2();</span><br><span class="line">        JoinDemo2 jd2 = <span class="keyword">new</span> JoinDemo2();</span><br><span class="line">        JoinDemo2 jd3 = <span class="keyword">new</span> JoinDemo2();</span><br><span class="line">        jd1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jd1.join(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jd2.start();</span><br><span class="line">        jd3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看控制台发现，当jd1完成其任务2000毫秒后，jd2和jd3才开始执行</li></ul><h2 id="Runnable接口简单介绍"><a href="#Runnable接口简单介绍" class="headerlink" title="Runnable接口简单介绍"></a>Runnable接口简单介绍</h2><ul><li><p><strong>Runnable</strong>接口由任何其实例由线程执行类实现，<strong>Runnable</strong>接口只有一个<strong>run()</strong>方法。</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">//用于执行线程的操作</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread1 th = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(th);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出</li></ul><p><img src="/2019/03/19/多线程/%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt></p><h2 id="Thread-与-Runnable区别"><a href="#Thread-与-Runnable区别" class="headerlink" title="Thread 与 Runnable区别"></a>Thread 与 Runnable区别</h2><ul><li>使用继承的话，不适合资源共享，实现接口，容易实现资源共享。</li><li>java是单继承，多实现的。</li></ul><h2 id="Thread类中的start-与-run-方法的区别"><a href="#Thread类中的start-与-run-方法的区别" class="headerlink" title="Thread类中的start() 与 run() 方法的区别"></a>Thread类中的start() 与 run() 方法的区别</h2><ul><li><strong>start()</strong>方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码</li><li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态 ,并没有运行。</li><li>方法 <strong>run()</strong>称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程</li></ul><h2 id="Java后台线程"><a href="#Java后台线程" class="headerlink" title="Java后台线程"></a>Java后台线程</h2><ul><li><strong>定义：</strong>守护线程也称为“服务线程”，他是后台线程，它具有一个特点，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。</li><li><strong>优先级：</strong>守护线程的优先级比较低，用于为系统中的其他对象和线程提供服务。</li><li><strong>设置：</strong>通过<code>setDaemon(true)</code>来设置线程为“守护线程”，将一个用户线程设置为守护线程的方式是在线程对象创建之前用线程对象的<code>setDaemon()</code>方法。</li><li>在<code>Daemon</code>线程中产生的新线程也是<code>Daemon</code>的。</li><li>线程是JVM级别的，以Tomcat为例，如果你在Web应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步，也就是说，即使你停止了Web应用，这个线程依旧是活跃的。</li><li><strong>example:</strong>垃圾回收线程是一个经典的守护线程，当我们的程序中不再需要任何运行的Thread程序时，垃圾回收线程会自动离开，它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</li><li><strong>生命周期：</strong>守护进程(Daemon)是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件，也就是说守护进程不依赖于终端，但是依赖于系统，与系统“同生共死”。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了，如果还有一个或以上的非守护线程则JVM不会退出。</li></ul><p><a href="https://github.com/YanMao186/Thread" target="_blank" rel="noopener">本案例代码均已放置到github，点击获取</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java多线程&quot;&gt;&lt;a href=&quot;#java多线程&quot; class=&quot;headerlink&quot; title=&quot;java多线程&quot;&gt;&lt;/a&gt;java多线程&lt;/h1&gt;&lt;h2 id=&quot;相关概念讲解&quot;&gt;&lt;a href=&quot;#相关概念讲解&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IO总结</title>
    <link href="http://yoursite.com/2019/03/18/IO%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/18/IO总结/</id>
    <published>2019-03-18T10:57:47.000Z</published>
    <updated>2019-03-19T12:42:47.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO基本概念讲解"><a href="#IO基本概念讲解" class="headerlink" title="IO基本概念讲解"></a>IO基本概念讲解</h1><h2 id="IO流概念"><a href="#IO流概念" class="headerlink" title="IO流概念"></a>IO流概念</h2><ul><li>IO流是实现输入/输出的基础，方便的实现了数据的输入/输出操作，在java把不同的输入/输出抽象为“流”,流是一组有顺序，有起点和终点的字节集合，是对数据传输的总称或抽象。</li></ul><h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><h4 id="输入流和输出流。"><a href="#输入流和输出流。" class="headerlink" title="输入流和输出流。"></a>输入流和输出流。</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入流：只能从中读取数据，而不能向其中写入数据。（如：从硬盘读取文件到内存）</span><br><span class="line">输出流：只能向其写入数据，而不能从中读取数据。（如：从内存读取数据到硬盘）</span><br></pre></td></tr></table></figure><h4 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字节流：以字节为单位，每次读取或写入是8位数据，可以读取任意类型数据。</span><br><span class="line">字符流：以字符为单为，每次读取或写入是16位数据，只能读取字符类型数据。</span><br><span class="line">读取文本文件优先考虑字符流，读取图片，视频等非文本类型的只能使用字节流。</span><br></pre></td></tr></table></figure><h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">节点流：直接与数据源相连，读入或读出，也被称之为低级流。</span><br><span class="line">处理流：是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写操作，也被称之为高效流。</span><br></pre></td></tr></table></figure><h3 id="IO流结构图"><a href="#IO流结构图" class="headerlink" title="IO流结构图"></a>IO流结构图</h3><p><img src="/2019/03/18/IO总结/IO.png" alt></p><h3 id="IO流的四大基类-四大基类均为抽象类不可实例化"><a href="#IO流的四大基类-四大基类均为抽象类不可实例化" class="headerlink" title="IO流的四大基类(四大基类均为抽象类不可实例化)"></a>IO流的四大基类(四大基类均为抽象类不可实例化)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">|_Reader</span><br><span class="line">|_Writer</span><br><span class="line">|_InputStream</span><br><span class="line">|_OutputStream</span><br></pre></td></tr></table></figure><ul><li><p>Reader常用方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//读取一个字符并以整数形式返回，如果返回-1表示已到输入流末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buffer)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buffer,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//读取length个字符并存储到一个字符数组buffer，从off位置开始，最多len，返回实际读取字符数，如果读取前已到输入流末尾返回-1.</span></span><br></pre></td></tr></table></figure></li><li><p>Writer常用方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="comment">//向输出流中写入字符数据，该字节数据为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] c)</span></span>;</span><br><span class="line"><span class="comment">//将一个字符类型的数组中的数据写入到输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] c,<span class="keyword">int</span> off,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//从一个字符类型的数组中的指定位置开始，length个字符写入到输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span></span>;</span><br><span class="line"><span class="comment">//将一个字符串中的字符写入到输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String ,<span class="keyword">int</span> off,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//将一个字符串从off开始的length个字符写入到输出流.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//将输出流中的缓冲数据全部写出到目的地。</span></span><br></pre></td></tr></table></figure><ul><li>InputStream常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//读取一个字节并以整数的形式返回,如果返回-1已到达输出流末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer)</span></span>;</span><br><span class="line"><span class="comment">//读取一系列字节并存储到一个数组，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] buffer,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//读取length个字节并保存到一个字节数组，从off位置开始存，最多len，返回实际读取的字节数，如果读取前已到输出流的末尾返回-1.</span></span><br></pre></td></tr></table></figure><ul><li>OutputStream常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span>;</span><br><span class="line"><span class="comment">//将一个字节类型的数组中的数据写入到输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//将一个字节类型的数组中的数据从指定位置开始，len个字节写入到输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//将输出流中的缓冲数据全部写出到目的地。</span></span><br></pre></td></tr></table></figure><p>==注：java的IO流执行完成后，均要关闭流，调用close()方法，释放资源==</p><ul><li>InputStream/OutpurStream简单演示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:测试高效流与普通流用时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-03 01:35</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        IO.buffer();</span><br><span class="line">        IO.file();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buffer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\迅雷下载\\win7x64.iso"</span>));</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\高效流.iso"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span> ((i = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"高效流用时："</span> + (l1 - l) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">file</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = System.nanoTime();</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"E:\\迅雷下载\\win7x64.iso"</span>));</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:\\file.iso"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span> ((i = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> l1 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"普通流用时："</span> + (l1 - l) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Reader/Writer简单演示</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IO2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\使用说明.txt"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:\\aaa.txt"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span>[] c = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((i = isr.read(c))!= -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(c,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IO基本概念讲解&quot;&gt;&lt;a href=&quot;#IO基本概念讲解&quot; class=&quot;headerlink&quot; title=&quot;IO基本概念讲解&quot;&gt;&lt;/a&gt;IO基本概念讲解&lt;/h1&gt;&lt;h2 id=&quot;IO流概念&quot;&gt;&lt;a href=&quot;#IO流概念&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>面向对象总结</title>
    <link href="http://yoursite.com/2019/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/17/面向对象总结/</id>
    <published>2019-03-17T08:27:22.000Z</published>
    <updated>2019-03-19T12:43:26.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象程序设计-Object-oriented-Programming-OOP"><a href="#面向对象程序设计-Object-oriented-Programming-OOP" class="headerlink" title="面向对象程序设计(Object-oriented Programming,OOP)"></a>面向对象程序设计(Object-oriented Programming,OOP)</h2><ul><li><code>首先基本概念的了解</code><ul><li><strong>对象</strong>：对象是类的实例。有行为和属性，如：人类是一个对象：属性有：姓名，性别，年龄…行为有：吃饭，睡觉等。</li><li><strong>类</strong>：类是一个模板，描述一类对象的行为和状态。</li><li><strong>方法</strong>：方法就是行为，一个类可以有多个方法。</li><li><strong>实例变量</strong>:每一个对象都有独特的实例变量，对象的状态由实例变量的值决定。<h1 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a><code>面向对象的三大特征</code></h1></li></ul></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><code>封装指一种抽象性函式接口实现细节部分包装(private),隐藏起来，然后给外部提供公共的方法</code></p><ul><li>如:实体类Person</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;   <span class="comment">//使用关键字对属性进行封装</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;   <span class="comment">//提供公共的setting/getting方法</span></span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>封装的优势</code><ol><li>减少耦合</li><li>对成员进行更精确的控制</li><li>隐藏信息，实现细节</li></ol></li></ul><h2 id="继承-is-a"><a href="#继承-is-a" class="headerlink" title="继承(is-a)"></a>继承(is-a)</h2><p><code>多个类中存在相同的行为和属性，将这些内容抽取到一个单独的类中(被称为基类，父类或超类),那么多个类(被称为基类，继承类或子类)无需再定义这些属性和行为，只要继承(extends)父类即可。</code></p><p><img src="/2019/03/17/面向对象总结/1552570451346.png" alt="1552570451346"></p><ul><li><p>如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-17 12:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String userName;</span><br><span class="line">    <span class="keyword">protected</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String userName, String gender, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//setting/getting方法此处省略。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", height="</span> + height +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-17 15:26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类可以有自己特有的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//通过快捷键生成的tostring（）我们已经可以看到,子类已经默认重写了父类的非私有属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-17 15:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(); <span class="comment">//首先进行父类测试</span></span><br><span class="line">        p.setAge(<span class="number">40</span>);</span><br><span class="line">        p.setGender(<span class="string">"男"</span>);</span><br><span class="line">        p.setHeight(<span class="number">180</span>);</span><br><span class="line"><span class="comment">//        p.heigth = 180;   这两种方法都可以进行赋值</span></span><br><span class="line">        p.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//        s.heigth = 175;   //我们发现子类的heigth不可以直接赋值，因为父类对他进行了私有化，但是提供了公共的setting/getting方法</span></span><br><span class="line">        s.setHeight(<span class="number">175</span>);</span><br><span class="line">        s.setAge(<span class="number">20</span>);</span><br><span class="line">        s.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        s.setGender(<span class="string">"男"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>控制台输出</code></p><p><img src="/2019/03/17/面向对象总结/1552810048863.png" alt="1552810048863"></p></li></ul><ul><li><p><code>继承的简单小结</code></p><ol><li>java不支持多继承(person extend Student,Teacher)，但是支持多重继承(A extend B        C extend B)</li><li>子类拥有父类非<code>private</code>的属性，方法。</li><li>子类可以拥有自己的属性和行为。</li><li>提高了类之间的耦合性(继承的一大缺点)。</li><li>java中类默认继承<code>Object</code>类。<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2></li></ol></li><li><p>多态面向对象中最重要的概念,有两种体现方式。</p><ol><li><p><code>重载(overload)</code></p><ul><li><p>何为重载：<code>我们称在一个类中有两个或两个以上的方法具有相同的方法名,但是参数列表不同，我们称之为重载。</code></p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * add()</span></span><br><span class="line"><span class="comment">         * add2()</span></span><br><span class="line"><span class="comment">         * 两者方法名相同，参数列表不同称之为重载</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       Count.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">       Count.add2(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add:"</span>+a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"add2:"</span>+a+b+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>重写(overwrite)</code></p><ul><li>何为重写：<code>重写发生在父子类之中，当子类继承父类，与父类中的方法同名，同参，我们称之为重写</code></li></ul></li><li><p>对象的多态性：<code>父类引用指向子类对象实体(父类 父 = new 子类())</code></p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li><p>抽象是隐藏实现细节并向用户显示供能的过程。</p></li><li><p>抽象可以让你专注于对象做什么（实现的功能）,而不是他如何做。</p></li><li><p>抽象类实现接口时，可以选择性的重写接口。</p></li><li><p>实现抽象的方法.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">absPerson</span></span>&#123;   <span class="comment">//用abstract修饰的类称为抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;  <span class="comment">//抽象方法没有实现,抽象类中的方法默认是抽象的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//非抽象方法要有实现（1.8以后支持）</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>接口是一种实现抽象的机制，接口中只能有抽象方法（默认抽象）</p></li><li><p>接口中可以定义静态常量和抽象方法。</p></li><li><p>用于实现耦合。</p></li><li><p>接口时隐式抽象的，当声明一个接口的时候，不必使用<code>abstract</code>关键字。</p></li><li><p>接口中的方法都是公共的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//接口中的静态常量</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius：半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="comment">//接口中的方法默认public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="抽象类和接口的异同"><a href="#抽象类和接口的异同" class="headerlink" title="抽象类和接口的异同"></a>抽象类和接口的异同</h2><ol><li>抽象类中的方法可以有方法体，接口中没有（1.8以后有）</li><li>抽象类中的成员变量可以是各种类型的，接口中成员变量只能是<code>public static final</code>类型的（默认）</li><li>接口中不能有静态代码块以及静态方法（1.8以后可以写静态方法），抽象类可以有静态代码块和静态方法。</li><li>类只能继承一个抽象类，却可以实现多个接口。</li><li>两者都不能实例化。（new)</li></ol><h2 id="类与类，接口与接口，类与接口的关系"><a href="#类与类，接口与接口，类与接口的关系" class="headerlink" title="类与类，接口与接口，类与接口的关系"></a>类与类，接口与接口，类与接口的关系</h2></li></ul><p>  <img src="/2019/03/17/面向对象总结/1552574794659.png" alt="1552574794659"></p><p><img src="/2019/03/17/面向对象总结/1552574827383.png" alt></p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ul><li>static主要用来内存管理，用于变量，代码块等，static属于类，而不是类的实例</li><li>静态变量<ul><li>静态变量可以用于引用所有对象的公共属性。</li><li>使程序存储器高效(节省内存)。</li></ul></li><li>静态方法<ul><li>静态方法属于类，而不属于类的对象。</li><li>可以直接调用静态方法，而无需创建类的实例。</li><li>静态方法可以直接访问静态数据成员，并可以更改静态数据成员的值</li></ul></li><li>静态代码块<ul><li>用于初始化静态数据成员。</li><li>在类加载时mian方法执行前执行。</li></ul></li></ul><h2 id="java聚合"><a href="#java聚合" class="headerlink" title="java聚合"></a>java聚合</h2><ul><li>如何一个类有一个类实体的引用(类中的类)则称之为聚合（has-a）</li><li>优势：代码可重用性。</li><li>以下以省，市为例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Bridge Pattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:地址类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr.Yan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-03-17 18:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String city; <span class="comment">//市</span></span><br><span class="line">    <span class="keyword">public</span> String province;<span class="comment">//省</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city, String province)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(id+<span class="string">""</span>+name);</span><br><span class="line">        System.out.println(address.city+address.province);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Address address1 = <span class="keyword">new</span> Address(<span class="string">"西安"</span>,<span class="string">"陕西"</span>);</span><br><span class="line">        Address address2 = <span class="keyword">new</span> Address(<span class="string">"成都"</span>,<span class="string">"四川"</span>);</span><br><span class="line"></span><br><span class="line">        Emp e = <span class="keyword">new</span> Emp(<span class="number">111</span>,<span class="string">"wang"</span>,address1);</span><br><span class="line">        Emp e2 = <span class="keyword">new</span> Emp(<span class="number">222</span>,<span class="string">"li"</span>,address2);</span><br><span class="line">        e.display();</span><br><span class="line">        e2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象程序设计-Object-oriented-Programming-OOP&quot;&gt;&lt;a href=&quot;#面向对象程序设计-Object-oriented-Programming-OOP&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计(Obj
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
