<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>MrYan</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="MrYan">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  '>
      
        
  <h1 class='title'>Yan</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;项目
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          MrYan
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://xaoxuu.com/wiki/material-x/"
                
                  rel="nofollow"
                
                
                id="https:xaoxuu.comwikimaterial-x">
								<i class='fas fa-book fa-fw'></i>&nbsp;主题文档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/20/Spring-Cloud快速入门/">
      Spring Cloud快速入门
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-20</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="What-s"><a href="#What-s" class="headerlink" title="What`s"></a>What`s</h2>
      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Spring-Cloud/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>Spring Cloud</a>
        
          <a href="/tags/微服务/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>微服务</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/19/SQL优化及补充/">
      SQL优化及补充
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-19</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/MySQL/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>MySQL</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建，查询，更新和删除数据，不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能，现在许多不同的数据库管理系统都支持不同的数据引擎，存储引擎主要有<ol>
<li>MyIsam</li>
<li>InnoDB</li>
<li>Memory</li>
<li>Archive</li>
<li>Federated</li>
</ol>
</li>
</ul>
<h4 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB(B+树)"></a>InnoDB(B+树)</h4><ul>
<li>InnoDB底层结构为B+树，B树的每个节点对应的InnoDB的一个page，page大小是固定的，一般设为16k。其中非叶子节点只有键值，叶子节点包含完成数据。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563521705026.png" alt="1563521705026"></p>
<ul>
<li>适用场景<ul>
<li>经常更新的表，适合处理多重并发的更新请求。</li>
<li>支持事务。</li>
<li>可以从灾难中恢复(通过bin-log日志等)。</li>
<li>外键约束，只有他支持外键。</li>
<li>支持自动增加列属性auto_increment。</li>
</ul>
</li>
</ul>
<h4 id="TokuDB-Fractal-Tree节点带数据"><a href="#TokuDB-Fractal-Tree节点带数据" class="headerlink" title="TokuDB(Fractal Tree节点带数据)"></a>TokuDB(Fractal Tree节点带数据)</h4><ul>
<li>TokuDB底层存储结构为<code>Fractal Tree</code>,与B+树有些类似，在Fractal Tree中，<strong>每一个child指针除了需要指向一个child节点外，还会带有一个Message Buffer，这个Message Buffer是一个FIFO的队列，用来缓存更新操作。</strong></li>
<li>如，一次插入操作只需要落在某节点的<code>Message Buffer</code>就可以马上返回了，并不需要搜索到叶子节点，这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</li>
<li>完全支持事务ACID</li>
<li>TokuDB在线添加索引，不影响读写操作，非常快的写入性能，Fractal-tree在事务实现上有优势，它主要适用于访问频率不高的数据或历史数据归档。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563522531352.png" alt="1563522531352"></p>
<h4 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h4><ul>
<li>MySQL默认的引擎，但是它没有对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整张表，效率会低一些。</li>
<li>MyIsam执行读取操作的速度很快，而且不占用大量的内存和存储资源，在设计之初就预想数据组织成有固定长度的记录，按顺序存储的，MyIsam是一种静态的索引结构。缺点是不支持事务。</li>
</ul>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul>
<li>Memory(也叫做HEAP)堆内存:使用存在内存中的内容来创建表，每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。MEMORY同时支持散列表索引和B树索引，B树索引可以使用部分查询和通配查询，也可以使用&lt;,&gt;和=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</li>
</ul>
<h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul>
<li>只支持insert和select操作(支持行级锁和缓冲区，可以提高实现高并发的插入)</li>
<li>只允许在自增ID列上加索引。</li>
<li>Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。当数据量非常大的时候Archive的插入性能表现会较MyISAM为佳。</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>索引(index)是帮助MySQL高效获取数据的数据结构，常见的查询算法，顺序查找，二分查找，二叉树排序查找，哈希散列法，分块查找，平衡多路搜索树B树。</li>
</ul>
<h4 id="优缺点及特点"><a href="#优缺点及特点" class="headerlink" title="优缺点及特点"></a>优缺点及特点</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>可以加快数据库的检索速度</li>
<li>降低数据库插入，修改，删除等维护的速度</li>
<li>只能创建在表上，不能创建到视图上。</li>
<li>既可以直接创建又可以间接创建。</li>
<li>可以在优化隐藏中使用索引。</li>
<li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引。</li>
</ol>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>创建唯一性索引，保证数据表中每一行数据的唯一性。</li>
<li>大大加快数据的检索速度，这是创建索引的最主要原因。</li>
<li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加，删除和修改的时候，索引也需要维护，降低数据维护的速度。</li>
</ol>
<h4 id="常见的索引原则"><a href="#常见的索引原则" class="headerlink" title="常见的索引原则"></a>常见的索引原则</h4><ol>
<li><strong>选择唯一性索引</strong>:唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录。</li>
<li><strong>为经常需要排序，分组和联合操作的字段建立索引</strong>。</li>
<li><strong>为常作为查询条件的字段建立索引。</strong></li>
<li><strong>限制索引的数目</strong>：越多的索引，会使更新表变得很浪费时间。</li>
<li><strong>尽量使用数据量少的索引</strong>：如果索引的值很长，那查询的速度会收到影响。</li>
<li><strong>尽量使用前缀来索引</strong>：如果索引字段的值很长，最好使用值的前缀来索引。</li>
<li><strong>删除不再使用或很少使用的前缀。</strong></li>
<li><strong>最左前缀匹配原则，非常重要的原则。</strong></li>
<li><strong>尽量选择区分度高的列作为索引</strong>：区分度的公式是表示字段不重复的比例。</li>
<li><strong>索引列不能参与计算，保持列“干净”，带函数的查询不参与索引。</strong></li>
<li><strong>尽量的扩展索引，不要新建索引。</strong></li>
</ol>
<h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol>
<li><strong>组合索引</strong>：实质上是将多个字段建到一个索引里，列指的组合必须唯一。</li>
<li><strong>聚集索引</strong>：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</li>
<li><strong>非聚集索引</strong>：唯一索引，普通索引，主键索引，全文索引。</li>
<li><strong>UNIQUE(唯一索引)</strong>：不可以出现相同的值，可以有NULL值。</li>
<li><strong>INDEX(普通索引)</strong>：允许出现相同的索引内容。</li>
<li><strong>PROMARY KEY(主键索引)</strong>：不允许出现相同的值。</li>
<li><strong>fulltext index(全文索引)</strong>：可以针对值中的某个单词，但效率呵呵。</li>
</ol>
<h4 id="MySQL如何为表字段添加索引"><a href="#MySQL如何为表字段添加索引" class="headerlink" title="MySQL如何为表字段添加索引"></a>MySQL如何为表字段添加索引</h4><ol>
<li>添加PRIMARY KEY(主键索引)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add primary key (&apos;column&apos;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加UNIQUE(唯一索引)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add unique (&apos;column&apos;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加INDEX(普通索引)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; add index indexname (&apos;column&apos;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加FULLTEXT(全文索引)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tablename add fulltext (&apos;column&apos;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加多列索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;tablename&apos; addd indexname (&apos;column1&apos;,&apos;column2&apos;,&apos;column3&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"><a href="#当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施" class="headerlink" title="当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施"></a>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，优化措施</h2><h4 id="限定数据的范围"><a href="#限定数据的范围" class="headerlink" title="限定数据的范围"></a>限定数据的范围</h4><ul>
<li>务必禁止不带任何限制数据范围条件的查询语句，比如：在查询订单历史时，我们可以控制在一个月的范围内。</li>
</ul>
<h4 id="读-写分离"><a href="#读-写分离" class="headerlink" title="读/写分离"></a>读/写分离</h4><ul>
<li>数据库拆分，主库负责写，从库负责读。</li>
</ul>
<h4 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h4><ul>
<li><strong>根据数据库中的数据表的相关性进行拆分</strong>，如：用户表中既有用户的登录信息又有用户的基本信息，可以把用户表拆成两张表，甚至放到单独的库做分库。简单来说垂直拆分是指数据表列的拆分，把一张表列比较多的表拆分为多张表。如下</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563531655922.png" alt="1563531655922"></p>
<ul>
<li><strong>垂直拆分优点</strong>：可以使行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区让事务变得更加复杂。</li>
</ul>
<h4 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h4><ul>
<li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的，水平拆分可以支撑非常大的数据量。</strong>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表数据拆成多张表来存放。如：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成的影响。</li>
<li>水平拆分可以支持非常大的数据量，需要注意的是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，<strong>所以水平拆分最好分库</strong>。<strong>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决</strong>，跨界点Join性能较差，逻辑复杂。</li>
<li><strong>尽量不要对数据进行分片，以为拆分会带来逻辑，部署，运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片的架构，这样可以减少一次和中间件的网络I/O。</li>
</ul>
<h4 id="数据库分片常见方案"><a href="#数据库分片常见方案" class="headerlink" title="数据库分片常见方案"></a>数据库分片常见方案</h4><ul>
<li><strong>客户端代理，分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现</strong>。当当网的ShardingJDBC,阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：在应用和数据中间加了一个代理层，分片逻辑统一维护在中间件服务中</strong>。Mycat，360的Atlas，网易的DDB等等都是这种架构实现的。</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol>
<li>对查询进行优化，应尽量避免全表扫面，首先应考虑在<code>where</code>及<code>order by</code>涉及的列上建立索引。</li>
<li>索引并不是越多越好，会降低维护的效率。</li>
<li><code>in</code>和<code>not in</code>要慎用。</li>
<li>避免在字段上进行计算操作。</li>
<li>临时表也可以用，要记得显式的删除。</li>
<li>避免频繁的创建删除数据表。</li>
<li>拆分大的<code>insert</code> <code>update</code>操作，提高并发性能。</li>
<li><strong>避免在<code>where</code>子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符</strong>，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>避免在<code>where</code>子句中对字段进行<code>null</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>避免在<code>where</code>子句中使用<code>or</code>来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li>………………………………</li>
</ol>
<h2 id="实践中如何优化MySQL"><a href="#实践中如何优化MySQL" class="headerlink" title="实践中如何优化MySQL"></a>实践中如何优化MySQL</h2><ol>
<li>SQL语句以及索引的优化。</li>
<li>数据库表结构的优化。</li>
<li><strong>数字类型</strong>：非万不得已不要使用DOUBLE。</li>
<li><strong>字符类型</strong>：非万不得已不要使用TEXT数据类型。</li>
<li><strong>时间类型</strong>：尽量使用<code>TIMESTAMP</code>类型，因为其存储空间只需要<code>DATETIME</code>类型的一半，对于只需要精确到某一天的数据类型，建议使用<code>DATE</code>类型，因为他们的存储空间只需要3个字节，比<code>TIMESTAMP</code>还少。</li>
<li>数据库引擎选择，对于<code>select</code>执行比较多的操作，很少插入删除更新的表使用<code>MyIsam</code>引擎。</li>
</ol>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><ul>
<li>事务是逻辑上的一组操作，要么都执行，要么都不执行</li>
</ul>
<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><ul>
<li>事务的最小执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
</ul>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><ul>
<li>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</li>
</ul>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><ul>
<li>并发访问数据库时，一个用户的事务不被其他的事务所干扰，各并发之间数据库是独立的。</li>
</ul>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><ul>
<li>一个事务被提交后。它对数据库中的数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><ul>
<li>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是”脏数据“，依据”脏数据“所作的操作可能是不正确的。</li>
</ul>
<h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><ul>
<li>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为”丢失修改“。如：事务1读取表中的数据为A=20，事务2也读取为A=20，事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19，事务1的修改丢失。</li>
</ul>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><ul>
<li>指在一个事务内多次读同一个数据，在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
</ul>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><ul>
<li>幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称之为幻读。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="READ-UNCOMMITTED-读未提交"><a href="#READ-UNCOMMITTED-读未提交" class="headerlink" title="READ-UNCOMMITTED(读未提交)"></a>READ-UNCOMMITTED(读未提交)</h5><ul>
<li>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读，幻读或不可重复读。</strong></li>
</ul>
<h5 id="READ-COMMITTED-读已提交"><a href="#READ-COMMITTED-读已提交" class="headerlink" title="READ-COMMITTED(读已提交)"></a>READ-COMMITTED(读已提交)</h5><ul>
<li>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或者不可重复读仍有可能发生。</strong></li>
</ul>
<h5 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE-READ(可重复读)"></a>REPEATABLE-READ(可重复读)</h5><ul>
<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
</ul>
<h5 id="SERIALIZABLE-可串行化"><a href="#SERIALIZABLE-可串行化" class="headerlink" title="SERIALIZABLE(可串行化)"></a>SERIALIZABLE(可串行化)</h5><ul>
<li>最高的隔离级别，完全服从ACID的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读，不可重复读以及幻读。</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
<th align="center">数据库默认隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ-UNCOMMITTED</td>
<td align="center">o</td>
<td align="center">o</td>
<td align="center">o</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">READ-COMMITTED</td>
<td align="center">x</td>
<td align="center">o</td>
<td align="center">o</td>
<td align="center">oracle/SQL server</td>
</tr>
<tr>
<td align="center">REPEATABLE-READ</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">o</td>
<td align="center">MySQL</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="数据库并发策略"><a href="#数据库并发策略" class="headerlink" title="数据库并发策略"></a>数据库并发策略</h2><ul>
<li>并发控制一般采用三种方法：<strong>乐观锁</strong>，<strong>悲观锁</strong>和<strong>时间戳</strong>。</li>
</ul>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</li>
</ul>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><ul>
<li>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</li>
</ul>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><ul>
<li>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，以上悲观锁所说的加“锁”，其实分为几种锁，分别是：排它锁（写锁）和共享锁（读锁）。</li>
</ul>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><ul>
<li>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时，Oracle 会自动应用行级锁：<ul>
<li><code>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE  [OF columns][WAIT n | NOWAIT]</code>;</li>
<li><code>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</code></li>
<li><code>使用 COMMIT 或 ROLLBACK 语句释放锁</code></li>
</ul>
</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><ul>
<li>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</li>
</ul>
<h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><ul>
<li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</li>
</ul>
<h2 id="基于Redis分布式锁"><a href="#基于Redis分布式锁" class="headerlink" title="基于Redis分布式锁"></a>基于Redis分布式锁</h2><ul>
<li>获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁</li>
<li>获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul>
<li>分库分表有<strong>垂直切分</strong>和<strong>水平切分</strong>两种</li>
</ul>
<h4 id="垂直切分-按照功能模块"><a href="#垂直切分-按照功能模块" class="headerlink" title="垂直切分(按照功能模块)"></a>垂直切分(按照功能模块)</h4><ul>
<li>将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563525859253.png" alt="1563525859253"></p>
<h4 id="水平切分-按照规划划分存储"><a href="#水平切分-按照规划划分存储" class="headerlink" title="水平切分(按照规划划分存储)"></a>水平切分(按照规划划分存储)</h4><ul>
<li>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563525903133.png" alt="1563525903133"></p>
<h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><h4 id="柔性事务-1"><a href="#柔性事务-1" class="headerlink" title="柔性事务"></a>柔性事务</h4><ul>
<li>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</li>
<li>通常所说的柔性事务分别为：<strong>两阶段型</strong>，<strong>补偿型</strong>，<strong>异步确保型</strong>，<strong>最大努力通知型</strong>几种。</li>
</ul>
<h5 id="两阶段型："><a href="#两阶段型：" class="headerlink" title="两阶段型："></a>两阶段型：</h5><ul>
<li>就是分布式事务两阶段提交，对应技术上的XA，JTA/JTS。这是分布式环境下事务处理的典型模式。</li>
</ul>
<h5 id="补偿型："><a href="#补偿型：" class="headerlink" title="补偿型："></a>补偿型：</h5><ul>
<li>TCC型事务(Try/Confirm/Cancel)可以归为补偿型。</li>
<li>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563526421770.png" alt="1563526421770"></p>
<h5 id="异步确保型"><a href="#异步确保型" class="headerlink" title="异步确保型"></a>异步确保型</h5><ul>
<li>通过将一系列同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响。</li>
</ul>
<p><img src="/2019/07/19/SQL优化及补充/1563526497943.png" alt="1563526497943"></p>
<h5 id="最大努力通知型-多次尝试"><a href="#最大努力通知型-多次尝试" class="headerlink" title="最大努力通知型(多次尝试)"></a>最大努力通知型(多次尝试)</h5><ul>
<li>这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <strong>允许在达到最大重试次数之后正常结束事务。</strong></li>
</ul>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability<br>（可用性）、Partition tolerance（分区容错性），三者不可得兼。</li>
</ul>
<h4 id="一致性-C"><a href="#一致性-C" class="headerlink" title="一致性(C)"></a>一致性(C)</h4><ul>
<li>在分布式系统中的所有数据备份，在同一时刻是否同样的值(等同于所有节点访问同一份最新的数据副本)</li>
</ul>
<h4 id="可用性-A"><a href="#可用性-A" class="headerlink" title="可用性(A)"></a>可用性(A)</h4><ul>
<li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</li>
</ul>
<h4 id="分区容忍性-P"><a href="#分区容忍性-P" class="headerlink" title="分区容忍性(P)"></a>分区容忍性(P)</h4><ul>
<li>以实际效果而言，分区相当于对通信的时限要求，系统如果不能在1时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/mysql/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>mysql</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/19/网络/">
      网络
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-19</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/HTTP-TCP-IP/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>HTTP/TCP/IP</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="网络7层协议"><a href="#网络7层协议" class="headerlink" title="网络7层协议"></a>网络7层协议</h2><ol>
<li><strong>物理层</strong>：主要定义物理设备标准，如：网线，光纤接口类型，各种传输介质的传输速率等。它主要作用是传输比特流(就是由1.0转换为电流强弱来进行传输，到达目的地后在转换为1，0，也就是我们常说的<strong>模数转换与数据转换</strong>)。这一层的数据叫做比特。</li>
<li><strong>数据链路层</strong>：主要将从物理层接受的数据进行<strong>MAC地址(网卡的地址)的封装与解封装</strong>。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。</li>
<li><strong>网络层</strong>：主要将从下一层接收到的数据<strong>进行IP地址的封装与解封装</strong>，在这一层工作的设备是<strong>路由器</strong>，常把这一层的数据叫做数据包。</li>
<li><strong>传输层</strong>：定义了一些<strong>传输数据的协议和端口号</strong>(WWW端口80等)，如<strong>TCP</strong>(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，<strong>UDP</strong>(用户数据报协议，与TCP特性相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将从下层接收的数据进行传输，到达目的地后再进行重组。常常把这一层数据叫做段。</li>
<li><strong>会话层</strong>：通过传输层(端口号：传输端口与接收端口)<strong>建立数据传输的通路</strong>，主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>
<li><strong>表示层</strong>：主要是进行对接收的数据进行<strong>解释，加密与解密，压缩与解压缩等</strong>（也就是把计算机能够识别的东西转换成人能够识别的东西，如：图片，声音等）。</li>
<li><strong>应用层</strong>：主要是一些终端的应用，比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（简单说就是我们可以在电脑屏幕上看见的东西，就属于终端）。</li>
</ol>
<p><img src="/2019/07/19/网络/timg.jpg" alt="timg"></p>
<h2 id="TCP-IP原理"><a href="#TCP-IP原理" class="headerlink" title="TCP/IP原理"></a>TCP/IP原理</h2><ul>
<li><p><strong>TCP/IP协议不是TCP和IP这两个协议的合称</strong>，而是指因特网整个TCP/IP协议族，从协议分层模型方面讲，TCP/IP由四个层次组成：<strong>网络接口层</strong>，<strong>网络层</strong>，<strong>传输层</strong>，<strong>应用层</strong>。</p>
<p><img src="/2019/07/19/网络/timg.jpg%E7%9A%84%E5%A4%A7%E8%8B%8F%E6%89%93.jpg" alt="timg.jpg的大苏打"></p>
</li>
</ul>
<h4 id="网络访问层"><a href="#网络访问层" class="headerlink" title="网络访问层"></a>网络访问层</h4><ul>
<li>有时也称作数据链路层或网络接口层，在TCP/IP参考模型中并没有详细描述，<strong>只是指出主机必须使用某种协议与网络相连</strong>。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>是整个体系结构中的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立的转向目标，这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同，高层如果需要顺序收发，那么就必须自行处理对分组的排序。<strong>互联网层使用因特网协议（IP）</strong>。</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li>传输层使源端和目的端机器上的对等实体可以进行会话，<strong>在这一层定义了两个端到端的协议</strong>：传输控制协议（TCP，UDP）<strong>TCP是面向连接的协议</strong>，它提供可靠的报文传输和对上层应用的连接服务，为此，除了基本的数据传输外，它还有可靠性保证，流量控制，多路复用，优先权和安全性控制等功能。<strong>UDP是面向无连接的不可靠传输的协议</strong>，主要用于步需要TCP的排序和流量控制等功能的应用程序。</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>应用层包含所有的高层协议，包括：<strong>虚拟终端协议（Telnet）,文件传输协议（FTP），电子邮件协议（SMTP）,域名服务（DNS），超文本传输协议（HTTP）等。</strong></li>
</ul>
<h2 id="TCP三次握手-四次挥手"><a href="#TCP三次握手-四次挥手" class="headerlink" title="TCP三次握手/四次挥手"></a>TCP三次握手/四次挥手</h2><ul>
<li>TCP在传输之前会进行三次沟通，一般称之为“三次握手”，传输完数据断开的时候要进行四次沟通，一般称之为“四次挥手”。</li>
</ul>
<h4 id="数据包简要概述"><a href="#数据包简要概述" class="headerlink" title="数据包简要概述"></a>数据包简要概述</h4><ol>
<li><strong>源端口号</strong>（16位）：它（连同源主机IP地址）标识源主机的一个应用进程。</li>
<li><strong>目的端口号</strong>（16位）：它（连同目的主机IP地址）标识目的主机的一个应用进程，<strong>这两个值加上IP报头中的源主机IP地址和目的主机IP地址确定唯一一个TCP连接</strong>。</li>
<li><strong>顺序号</strong>（32位）：<strong>用来标识从TCP源端向TCP目的端发送的数据字节流，他表示在这个报文段中的第一个数据字节的顺序号</strong>。如果将字节流看作在两个应用程序讲的单行流动，<strong>则TCP用顺序号对应每个字节进行计数</strong>。序号是32bit的无符号数，<strong>序号到达$$2^{32}-1$$后又从0开始，当建立一个新的连接时，SYN标志变1</strong>，顺序号字段包含由这个主板选择的该连接的初始顺序号ISN（Initial Sequence Number）。</li>
<li><strong>确认号ack</strong>（32位）：<strong>包含发送确认的一端所期望收到的下一个顺序号</strong>，因此，确认序号应当是上次已成功收到数据字节顺序号加1，<strong>只有ACK标志为1时确认序号字段才有效</strong>。TCP为应用层提供全双工服务，这意味着能在两个方向上独立地进行传输。因此，连接的每一端必须保证每个方向上的传输数据顺序号。</li>
<li><strong>TCP报头长度</strong>（4位）：给出报头中32bit字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部，然而，没有任选字段，正常的长度是20字节。</li>
<li><strong>保留数</strong>（6位）：保留给将来使用，目前必须置为0。</li>
<li><strong>控制位</strong>（6位）：在TCP报头中有6个标志比特，它们中有多个可同时被设置为1。依次为：<ol>
<li>URG：为1标识紧急指针有效，为0则忽略紧急指针值。</li>
<li>ACK：为1表示确认号有效，为0表示报文中不包含确认信息，忽略确认号字段。</li>
<li>PSH：为1表示是带有PUSH标志的数据，<strong>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</strong></li>
<li>RST：<strong>用于复位由于主机崩溃或其他原因而出现错误的连接</strong>，它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个RST为1的报文，那么一定发生了某些问题。</li>
<li>SYN：同步序号，<strong>为1表示连接请求</strong>，用于建立连接和使顺序号同步。</li>
<li>FIN：<strong>用于释放连接</strong>，为1表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ol>
</li>
<li><strong>窗口大小</strong>（16位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。</li>
<li><strong>校验和</strong>（16位）：此校验和是对整个的TCP报文段，<strong>包括TCP头部和TCP数据，以16位字进行计算所得</strong>，这是一个强制性的字段，一定是由发送端计算和存储，<strong>并由接收端进行验证</strong>。</li>
<li><strong>紧急指针</strong>（16位）：只有当URG标志置位1时紧急指针才有效。<strong>TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</strong></li>
<li><strong>选项</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size）。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项，<strong>它指明本端所能接收的最大长度的报文段</strong>。选项长度不一定是32位字的整数倍，所以要加填充位，使得报头长度成为整字数。</li>
<li><strong>数据</strong>：TCP报文段中的数据部分是可选的，在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首段，如果一方没有数据要发送，也使用没有任何数据的首段来确认收到的数据，在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ol>
<p><img src="/2019/07/19/网络/1563431855650.png" alt="1563431855650"></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li>第一次握手：主机A发送位码为<code>syn=1</code>，随机产生<code>seq number=1234567</code>的数据包到服务器，主机B由SYN=1知道，A要求建立联机。</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=<code>(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包</code>。</li>
<li>第三次握手：<code>主机A收到后检查ack number是否正确</code>，即第一次发送的seq number+1，以及位码ack是否为1，若正确，<code>主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功</code>。</li>
</ul>
<p><img src="/2019/07/19/网络/1563432346818.png" alt="1563432346818"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>TCP建立连接要进行三次握手，而断开连接要进行四次，这是由于TCP的半关闭造成的。因为TCP连接是全双工的（即数据可在两个方向上同时传递）所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫做半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。</li>
<li>第一次挥手：关闭客户端到服务器的连接，首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认，其中终值标志位FIN=1，序列号seq=u。</li>
<li>第二次挥手：服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。</li>
<li>第三次挥手：关闭服务器到客户端的连接：也是发送一个FIN给客户端。</li>
<li>第四次挥手：客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li>
<li>主机A发送FIN后，进入终止等待状态，服务器B收到主机A连接释放报文段后，就立即给主机A发送确定，然后服务器B就进入<code>close-wait</code>状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。此时。若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入<code>time-wait</code>，注意，此时TCP连接还没有释放掉，然后经过时间等待计数器设置的2MSL后，A才进入到close状态。</li>
</ul>
<p><img src="/2019/07/19/网络/1563435685702.png" alt="1563435685702"></p>
<h2 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h2><p><img src="/2019/07/19/网络/1563454607638.png" alt="1563454607638"></p>
<h4 id="对应的协议不同"><a href="#对应的协议不同" class="headerlink" title="对应的协议不同"></a>对应的协议不同</h4><h6 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h6><ol>
<li><strong>FTP</strong>：定义了文件传输协议，使用<code>21端口</code>。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</li>
<li><strong>Telnet</strong>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是纯字符界面的，<code>支持BBS的服务器将23端口打开，对外提供服务</code>。</li>
<li><strong>SMTP</strong>：定义了简单邮件传输协议，现在很多邮件服务器都用的是这个协议，用于邮件发送。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有SMTP端口设置，<code>服务器开放的是25端口</code>。</li>
<li><strong>POP3</strong>：和SMTP对应，POP3用于接收邮件。通常情况下，<code>POP3协议所用的是110端口</code>。也就是说，只要你有相应的使用POP3协议的程序，就可以不以Web方式登录进邮箱页面，直接用邮件程序就可以收到邮件。</li>
<li><strong>HTTP协议</strong>：是从Web服务器传输超文本到本地浏览器的传输协议。</li>
</ol>
<h6 id="UDP对应的协议"><a href="#UDP对应的协议" class="headerlink" title="UDP对应的协议"></a>UDP对应的协议</h6><ol>
<li><strong>DNS</strong>：用于域名解析服务，将域名地址转换为IP地址。<code>DNS用的是53端口</code>。</li>
<li><strong>SNMP</strong>：简单的网络协议，<code>使用161端口</code>，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li><strong>TFTP</strong>：简单文件传输协议，该协议在<code>端口69上使用UDP服务</code>。<h2 id="TCP如何保证可靠性传递"><a href="#TCP如何保证可靠性传递" class="headerlink" title="TCP如何保证可靠性传递"></a>TCP如何保证可靠性传递</h2></li>
</ol>
<ul>
<li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并不给出响应，这是TCP发送数据端超时后会重发数据。</li>
<li><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层。</li>
<li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据。</li>
<li><strong>应答机制</strong>：当TCP收到发自TCP连接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。</li>
<li><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
<li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ul>
<h2 id="TCP流量控制-拥塞控制"><a href="#TCP流量控制-拥塞控制" class="headerlink" title="TCP流量控制/拥塞控制"></a>TCP流量控制/拥塞控制</h2><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul>
<li><strong>原因</strong>：如果发送方把数据发送的过快，接收方可能来不及接收，这就会造成数据的丢失。</li>
<li><strong>原理</strong>：是利用滑动窗口实现的，接收方告诉发送方自己的接收窗口大小，然后发送方发送窗口不能超过接收方给出的接收窗口值。</li>
</ul>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><ul>
<li>发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态的在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。</li>
<li>慢开始的算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</li>
<li>这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下：</li>
</ul>
<p><img src="/2019/07/19/网络/1563459696361.png" alt="1563459696361"></p>
<ul>
<li>上图中，发送方每收到一个确认就cwnd+1，也就是说发送发发送2就收到2个，所以就是cwnd就是4，也就是翻倍成长的道理，每次都是翻倍，也就是指数增长。为了防止cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。用法如下：<ul>
<li>当cwnd &lt; ssthresh时，使用慢开始算法。</li>
<li>当cwnd &gt; ssthresh时，改用拥塞避免算法。</li>
<li>当cwnd = ssthresh时，慢开始与拥塞避免算法任意。</li>
</ul>
</li>
</ul>
<h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><ul>
<li>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有收到1确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判断，所以都当作拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法，如下：</li>
</ul>
<p><img src="/2019/07/19/网络/1563463668758.png" alt="1563463668758"></p>
<h4 id="快速重传快速恢复"><a href="#快速重传快速恢复" class="headerlink" title="快速重传快速恢复"></a>快速重传快速恢复</h4><ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为了使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，如下</li>
</ul>
<p><img src="/2019/07/19/网络/1563503812096.png" alt></p>
<ul>
<li><p>快重传配合使用的还有快速恢复算法，有两个特点：</p>
<ul>
<li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 <code>ssthresh</code>门限减半。但是接下去并不执行慢开始算法。</p>
</li>
<li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将<code>cwnd 设置为 ssthresh</code>的大小，然后执行拥塞避免算法。如下</p>
<p><img src="/2019/07/19/网络/1563504121286.png" alt></p>
</li>
</ul>
</li>
</ul>
<h2 id="TCP状态转移"><a href="#TCP状态转移" class="headerlink" title="TCP状态转移"></a>TCP状态转移</h2><p><img src="/2019/07/19/网络/1563508119629.png" alt="1563508119629"></p>
<ol>
<li><p><strong>CLOSED</strong>：起始点，在超时或者连接关闭时进入此状态。</p>
</li>
<li><p><strong>LISTEN</strong>：svr端在等待连接过来时候的状态，svr端为此要调用<code>socket，bind，listen函数</code>，就能进入此状态。此称为应用程序被动打开(等待客户端来连接)。</p>
</li>
<li><p><strong>STN_SENT</strong>：客户端发起连接，发送SYN给服务器端。如果服务器端不能连接，则直接进入<code>CLOSED状态</code>。</p>
</li>
<li><p><strong>SYN_RCVD</strong>：跟3对应，服务器端接收客户端的<code>SYN请求</code>，服务器端由<code>LISTEN状态进入SYN_RCVD状态</code>。同时<code>服务器端要回应一个ACK</code>，<code>同时发送一个SYN给客户端</code>；另外一种情况，<code>客户端在发起SYN的同时接收到服务器端的SYN请求，客户端就会由SYN_SENT到SYN_RCVD状态</code>。</p>
</li>
<li><p><strong>ESTABLISHED</strong>：服务器和客户端在完成3次握手后进入状态，说明已经可以开始传输数据了。</p>
</li>
<li><p><strong>FIN_WAIT_1</strong>：主动关闭的一方，由状态5进入此状态，具体的动作时发送FIN给对方。</p>
</li>
<li><p><strong>FIN_WAIT_2</strong>：主动关闭的一方，接收到对方的<code>FIN ACK</code>，进入此状态。由此不能再接收对方的数据，但是能够向对方发送数据。</p>
</li>
<li><p><strong>CLOSE_WAIT</strong>：接收到<code>FIN</code>以后，被动关闭的一方进入此状态，具体动作时接收到<code>FIN</code>，同时发送<code>ACK</code>。</p>
</li>
<li><p><strong>LAST_ACK</strong>：被动关闭的一方，发起关闭请求，由状态8进入此状态。具体动作时发送FIN给对方，<code>同时在接收到ACK时进入CLOSED状态</code>。</p>
</li>
<li><p><strong>CLOSING</strong>：两边同时发起关闭请求时，会由<code>FIN_WAIT_1</code>进入此状态。<code>具体动作是，接收到FIN请求，同时响应一个ACK</code>。</p>
</li>
<li><p><strong>TIME_WAIT</strong>：从图中可以看到，有三个状态可以转化为此状态</p>
<p>   a.<code>由FIN_WAIT_2进入此状态</code>：在双方不同时发起FIN的情况下，主动关闭的一方在完成自身发起的关闭请求后，接收到被动关闭一方的FIN后进入的状态。</p>
<p>   b. <code>由CLOSING状态进入</code>：双方同时发起关闭，都做了发起FIN的请求1，同时接收到了FIN并做了ACK的情况下，由CLOSINT状态进入。</p>
<p>   c. <code>由FIN_WAIT_1状态进入</code>：同时接收到FIN（对方发起），ACK（本身发起的FIN回应），与b的区别在于本身发起的FIN回应的ACK先于对方的FIN请求到达，而b是FIN先到达。这种国情况概率最小。</p>
</li>
</ol>
<h4 id="当一个tcp监听了80端口后，udp还能否监听80端口"><a href="#当一个tcp监听了80端口后，udp还能否监听80端口" class="headerlink" title="当一个tcp监听了80端口后，udp还能否监听80端口"></a>当一个tcp监听了80端口后，udp还能否监听80端口</h4><ul>
<li>：由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块，因此各自的端口号也相互独立，如 TCP 有一个 255 号端口，UDP 也可以有一个 255 号端口，二者并不冲突。</li>
</ul>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><ul>
<li>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。</li>
</ul>
<h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><ul>
<li>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。</li>
</ul>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><ul>
<li><p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成：发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。</p>
<ul>
<li>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。</li>
<li>p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。</li>
<li>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</li>
</ul>
<p><img src="/2019/07/19/网络/1563507810510.png" alt="1563507810510"></p>
</li>
</ul>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><ul>
<li>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。</li>
<li>如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</li>
</ul>
<p><img src="/2019/07/19/网络/1563507862436.png" alt="1563507862436"></p>
<h4 id="连续ARQ的注意事项"><a href="#连续ARQ的注意事项" class="headerlink" title="连续ARQ的注意事项"></a>连续ARQ的注意事项</h4><ul>
<li>同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</li>
<li>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。</li>
<li>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</li>
</ul>
<h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h4 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h4><ul>
<li>关于 SYN Flood 攻击。一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫tcp_syncookies 的参数来应对这个事——当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，请先千万别用 tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
</ul>
<h4 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h4><ul>
<li>DDoS 攻击是 Distributed Denial of Service 的缩写，即不法黑客组织通过控制服务器等资源，发动对包括国家骨干网络、重要网络设施、政企或个人网站在内的互联网上任一目标的攻击，致使目标服务器断网，最终停止提供服务。</li>
<li>预防:1.高防服务器 主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等 2.DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。3.CDN加速 在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</li>
</ul>
<h4 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h4><ul>
<li>DNS 欺骗就是攻击者冒充 域名服务器 的一种欺骗行为。</li>
<li>预防：<ul>
<li>1.使用入侵检测系统 </li>
<li>2.使用 DNSSEC</li>
</ul>
</li>
</ul>
<h4 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h4><ul>
<li>重放攻击又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。</li>
<li>预防：<ul>
<li>1.加随机数 </li>
<li>2.加时间戳</li>
</ul>
</li>
</ul>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><ul>
<li><p>所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。</p>
</li>
<li><p>预防：</p>
<ul>
<li><p>1.加密处理 将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令。</p>
</li>
<li><p>2.确保数据库安全 只给访问数据库的 web 应用功能所需的最低的权限，撤销不必要的公共许可 。</p>
</li>
<li><p>3.输入验证 检查用户输入的合法性，确信输入的内容只包含合法的数据。数据检查应当在客户端和服务器端都执行之所以要执行服务器端验证，是为了弥补客户端验证机制脆弱的安全性。</p>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>HTTP是一个无状态协议。无状态是指客户端(Web浏览器)和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务端发出请求，然后服务器返回响应（response），连接就被关闭了，再服务器端不保留连接的有关信息。HTTP遵循请求（Requset）/应答（Response）模型。客户机（浏览器）向服务器发送请求。服务器处理请求并返回适当的应答。所有HTTP连接都被构成一套请求和响应。</li>
</ul>
<h4 id="http请求报文与响应报文"><a href="#http请求报文与响应报文" class="headerlink" title="http请求报文与响应报文"></a>http请求报文与响应报文</h4><ul>
<li><strong>http请求报文</strong><ul>
<li>HTTP请求报文由请求行，请求头，空行和请求数据4部分组成。</li>
<li>请求行：(get/post方法，url中的path路径，http版本)</li>
<li>请求头（header）关键字/值对组成。</li>
<li>请求数据（body）：http响应报文由状态行，响应头部，空行，响应数据组成。</li>
</ul>
</li>
<li><strong>http响应报文</strong><ul>
<li>HTTP响应由四个部分组成：<ul>
<li>状态码（Status Code）：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码<code>HttpServletResponse.SC_OK</code>。</li>
<li>HTTP头部（HTTP Header）：它们包含了更多的关于相应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。</li>
<li>空行</li>
<li>主体（Body）：包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h4><ol>
<li><strong>地址解析</strong></li>
</ol>
<ul>
<li>如用客户端请求页面:<code>http://localhost:8080/index.html</code>从中分解出协议名，主机名，端口，对象路径等部分。对于这个地址解析后如下：<ul>
<li>协议名：<code>http</code></li>
<li>主机名：<code>localhost</code></li>
<li>端口：<code>8080</code></li>
<li>对象路径：<code>/index.html</code></li>
</ul>
</li>
<li>在这一步，需要域名系统DNS解析域名得到主机的IP地址。</li>
</ul>
<ol start="2">
<li><strong>封装HTTP请求数据包</strong></li>
</ol>
<ul>
<li>把上面的部分结合本机自己的信息，封装成一个HTTP请求数据包。</li>
</ul>
<ol start="3">
<li><strong>封装成TCP包并建立连接</strong></li>
</ol>
<ul>
<li>封装成TCP包，建立TCP连接(TCP的三次握手)</li>
</ul>
<ol start="4">
<li><strong>客户机发送请求命令</strong></li>
</ol>
<ul>
<li>客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)，协议版本号，后面是MIME信息包括请求修饰符，客户机信息和内容。</li>
</ul>
<ol start="5">
<li><strong>服务器响应</strong></li>
</ol>
<ul>
<li>服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号，一个成功或错误的代码，后面是MIME信息包括服务器信息，实体信息和可能的内容。</li>
</ul>
<ol start="6">
<li><strong>服务器关闭TCP连接</strong></li>
</ol>
<ul>
<li>服务器关闭TCP连接，一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码<code>Connection:keep-alive</code>,TCP连接在发送后任然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li>
</ul>
<p><img src="/2019/07/19/网络/1563437731001.png" alt="1563437731001"></p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul>
<li><p>HTTPS(Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443。过程大致如下：</p>
<ol>
<li><p><strong>建立连接获取证书</strong></p>
<ol>
<li>SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其他一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）。</li>
</ol>
</li>
<li><p><strong>证书验证</strong></p>
<ol>
<li>Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li>
</ol>
</li>
<li><p><strong>数据加密和传输</strong></p>
<ol>
<li>如果确认证书有效，那么生成对称密钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li>
</ol>
<p><img src="/2019/07/19/网络/1563438724225.png" alt="1563438724225"></p>
</li>
</ol>
</li>
</ul>
<h4 id="SSL工作原理"><a href="#SSL工作原理" class="headerlink" title="SSL工作原理"></a>SSL工作原理</h4><ul>
<li><p><strong>RSA握手协议</strong></p>
<ul>
<li>Client 给出协议版本号、一个客户端生成的随机数（Client random），<br>以及客户端支持的加密方法。</li>
<li>Server 确认双方使用的加密方法，并给出数字证书、以及一个服务器<br>生成的随机数（Server random）。</li>
<li>Client 确认数字证书有效，然后生成一个新的随机数（Premaster secr<br>et），并使用数字证书中的公钥，加密这个随机数，发给 Server。</li>
<li>Server 使用自己的私钥，获取 Client 发来的随机数（即 Premaster se<br>cret）。</li>
<li>Client 和 Server 根据约定的加密方法，使用前面的三个随机数，生成” 对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ul>
</li>
<li><p><strong>记录协议</strong></p>
<ul>
<li>记录协议 对数据传输提供保密性和完整性。</li>
<li>记录协议过程。</li>
</ul>
<p><img src="/2019/07/19/网络/InkedSnipaste_2019-07-19_13-45-11_LI.jpg" alt="InkedSnipaste_2019-07-19_13-45-11_LI"></p>
</li>
<li><p><strong>警报协议</strong></p>
<ul>
<li>如果是警告，则值为1，如果是致命错误，则值为2。</li>
</ul>
</li>
</ul>
<h4 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>HTTP版本</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
<td>1.0</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（如：提交表单或上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有的资源的修改。</td>
<td>1.0</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
<td>1.0</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能</td>
<td>1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
<td>1.1</td>
</tr>
<tr>
<td>PATCH</td>
<td>是对PUT方法的补充，用来对已知资源进行局部更新</td>
<td>1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的信息</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
<td>1.1</td>
</tr>
</tbody></table>
<h4 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h4><ul>
<li>GET被强制服务器支持</li>
<li>浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据</li>
<li>GET请求发送的数据更小(IE2048/firefox65536/chrome8182/opera190000字符)</li>
<li>GET请求是不安全的</li>
<li>GET请求是幂等的</li>
<li>POST请求不能被缓存</li>
<li>POST请求相对于GET请求是安全的</li>
<li>以下情况，请使用POST请求<ul>
<li>无法使用缓存文件(更新服务器上的文件或数据库)</li>
<li>向服务器发送大量数据(POST没有数据量限制)</li>
<li>发送包含未知字符的用户输入时，POST比GET更稳定也更可靠</li>
</ul>
</li>
<li>GET使用URL或Cookie传参。而POST将数据放在Body中。GET的URL会有长度上的限制，则POST的数据则可以非常大。POST比GET安全，因为数据在地址栏上不可见。</li>
<li>幂等<ul>
<li>从定义上看，HTTP方法的幂等性是指一次或多次请求某一个资源应该具有相同的副作用。</li>
<li>POST并不是幂等的。</li>
</ul>
</li>
</ul>
<h4 id="Http长连接-短连接"><a href="#Http长连接-短连接" class="headerlink" title="Http长连接/短连接"></a>Http长连接/短连接</h4><ul>
<li><strong>无状态</strong>：HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议(无连接)。</li>
<li><strong>长连接</strong>：从HTTP1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码<code>Connection:keep-alive</code>。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。<code>Keep-Alive</code>不会永久保持连接，他有一个保持时间，可以在不同的服务器软件(如：Apache)中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</li>
<li><strong>短链接</strong>：在HTTP1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问某个HTML或其他类型的web页中包含有其他的web资源(如:js，图像，css等)，每遇到这样一个web资源，浏览器就会重新建立一个HTTP会话。</li>
<li>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</li>
</ul>
<h4 id="什么时候用长连接，短连接"><a href="#什么时候用长连接，短连接" class="headerlink" title="什么时候用长连接，短连接"></a>什么时候用长连接，短连接</h4><ul>
<li><strong>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况下</strong>。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket创建也是对资源的浪费。</li>
<li>短连接一般用于web网站的http服务，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。</li>
</ul>
<h4 id="http1-1和1-0的区别"><a href="#http1-1和1-0的区别" class="headerlink" title="http1.1和1.0的区别"></a>http1.1和1.0的区别</h4><ul>
<li>1.0需要<code>keep-alive</code>参数来告知服务器要建立一个长连接，而1.1默认支持长连接。</li>
<li>1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401时候，客户端就可以不用发送请求body了，节约了带宽。</li>
<li>host域，1.0没有host域，1.1才开始支持</li>
<li>带宽优化及网络连接的使用，1.0中，存在一些浪费带宽的现象，如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，1.1则在请求头引入<code>range头域</code>，它允许只请求资源的某个部分，即返回码是206，这样方便了开发者自由的选择以便充分利用带宽和连接。</li>
</ul>
<h4 id="http2-0和1-0的区别"><a href="#http2-0和1-0的区别" class="headerlink" title="http2.0和1.0的区别"></a>http2.0和1.0的区别</h4><ul>
<li><strong>新的二进制</strong>(Binary Format):Http1.x的解析是基于文本的。基于文本协议的格式解析存在缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑Http2.0的协议解析决定采用二进制形式，实现方便且健壮。</li>
<li><strong>多路复用</strong>(MultiPlexing):即连接共享，建立起一个连接请求后，可以在这个链接上一直发送，不要等待上一次发送完并且收到回复后才能发送下一个(Http1.0是这样的)，是可以同时发送多个请求，互相并不干扰。</li>
<li><strong>header压缩</strong>:Http1.x的header带有大量信息，而且每次都要重复发送，Http2.0利用了<code>Hpack</code>对消息进行压缩传输，客户端和服务器维护一个动态链表(当一个头部没有出现的时候，就插入，已经出现了就用表中的索引值进行代替)，避免了重复header的传输，又减少了需要传输的大小。</li>
<li><strong>服务端推送</strong>(server push):就是客户端请求html的时候，服务器顺带把此html需要的css,js也一起发送给客户端，而不像1.0中需要请求一次html，然后再请求一次css，然后再请求一次js。</li>
</ul>
<h4 id="http与https区别"><a href="#http与https区别" class="headerlink" title="http与https区别"></a>http与https区别</h4><ul>
<li>https 协议需要申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl加密传输协议</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</li>
<li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。<ul>
<li>HTTP 的 URL 以 http:// 开头 ，而 HTTPS 的 URL 以 https://<br>开头</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层</li>
<li>HTTP 无需加密，而 HTTPS 对传输的数据进行加密</li>
<li>HTTP 无需证书，而 HTTPS 需要认证证书</li>
</ul>
</li>
</ul>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ul>
<li>CDN一般包含<strong>分发服务系统，负载均衡系统和管理系统</strong>。</li>
</ul>
<p><img src="/2019/07/19/网络/CDN%E6%9E%B6%E6%9E%84.jpg" alt="CDN架构"></p>
<h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><ul>
<li>其基本工作单元就是各个<code>Cache</code>服务器。负责直接响应用户请求，将内容快速分发到用户；同时负责内容更新，保证和源站内容的同步。</li>
<li>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：网页加速服务，流媒体加速服务，应用加速服务等。每个子服务系统都是分布式的服务集群，由功能类似，地域接近的分布部署的<code>Cache</code>集群组成。</li>
<li>在承担内容同步，更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个<code>Cache</code>设备的健康状况，响应情况，内容缓存状况等，以便管理调度系统能够根据设定的策略决定由那个<code>Cache</code>设备来响应用户的请求。</li>
</ul>
<h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><ul>
<li>负载均衡系统是整个CDN系统的中枢，负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</li>
<li>使用分级实现，最基本的两级调度体系包括全局负载均衡(GSLB)和本地负载均衡(SLB)。</li>
<li>GSLB根据用户地址和用户请求的内容，<strong>主要根据就近性原则，确定向用户服务的节点。一般通过DNS解析或者应用层重定向(HTTP 3XX重定向)的方式实现。</strong></li>
<li>SLB主要负责节点内部的负载均衡。当用户请求从GSLB调度到SLB时，SLB会根据节点内各个Cache设备的工作状况和内容分布情况等对用户请求重定向。<strong>SLB的实现有四层调度（LVS），七层调度（Nginx）和链路负载调度等。</strong></li>
</ul>
<h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><ul>
<li>分为运营管理和网络管理子系统。</li>
<li>网络管理系统实现对CDN系统的设备管理，拓扑管理，链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用web方式实现。</li>
<li>运营管理是对CDN系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集，整理，交付工作。<strong>包括用户管理，产品管理，计费管理，统计分析等。</strong></li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Http/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>Http</a>
        
          <a href="/tags/tcp-ip/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>tcp/ip</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/16/Java并发补充/">
      Java并发补充
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-16</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul>
<li><p>线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行，他的主要特点为：<strong>线程复用，控制最大并发数，管理线程</strong>。</p>
</li>
<li><p><strong>线程复用</strong></p>
<ul>
<li>每一个Thread的类都有一个start()方法，当调用start()启动线程时Java虚拟机会调用该类的run()方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。<strong>我们可以继承重写Thread类，在其start()方法中添加不断循环调用传递过来的Runnable对象</strong>。这就是线程池的实现原理。<strong>循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的</strong>。</li>
</ul>
</li>
<li><p><strong>线程池的组成</strong></p>
<ul>
<li>一般的线程池主要分为4个组成部分<ul>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程：线程池中的线程。</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行。</li>
<li>任务队列：用于存放处理的任务，提供一种缓冲机制。</li>
</ul>
</li>
<li>Java中的线程池1是通过Executor实现的。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563331336349.png" alt="1563331336349"></p>
<ul>
<li><code>ThreadPoolExecutor</code>中的构造方法<ul>
<li><code>corePoolSize</code>：指定了线程池中的线程数量。</li>
<li><code>maximumPoolSize</code>:指定了线程池中的最大线程数量。</li>
<li><code>keepAliveTime</code>：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li>
<li><code>utnit</code>:keepAliveTime的单位。</li>
<li><code>workQueue</code>:任务队列，被提交但尚未被执行的任务。</li>
<li><code>threadFactory</code>:线程工厂，用于创建线程，一般使用默认值。</li>
<li><code>handler</code>:拒绝策略，当任务太多来不及处理，如何拒绝任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="keyword">this</span>(corePoolSize,maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拒绝策略</strong></p>
<ul>
<li>线程池中的线程已经用完，无法继续为新任务服务，同时，等待队列也已经排满，再也塞不下新的任务，这时我们就需要拒绝策略机制合理的处理这个问题。</li>
<li>JDK内置的拒绝策略如下：<ul>
<li><code>AbortPolicy</code>:直接抛出异常，阻止系统正常运行。</li>
<li><code>CallerRunsPolicy</code>:只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li><code>DiscardOldestPolicy</code>:丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li><code>DiscardPolicy</code>:该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，这是最好的一种方案。</li>
<li>上述内置拒绝策略实现了<code>RejectedExecutionHandler</code>接口，若以上策略仍无法满足实际需要，完全可以自己扩展<code>RejectedExecutionHandler</code>接口。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池工作过程</strong></p>
<ol>
<li>线程池刚创建时，里面没有一个线程，任务队列是作为参数传递进来的，不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用execute()方法添加一个任务时，线程池会做以下判断：<ol>
<li>如果正在运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行这个队列。</li>
<li>如果正在运行的线程数大于或等于<code>corePoolSize</code>,那么将这个任务放入队列。</li>
<li>如果这时队列满了，而且正在运行的线程数小于<code>maximumPoolSize</code>，那么还要创建非核心线程立即运行这个任务。</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>,那么线程池会抛出异常<code>RejectExecutionException</code>。</li>
</ol>
</li>
<li>当一个线程完成任务时，他会从队列中取出下一个任务来执行。</li>
<li>当一个线程无事可做时，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li>
</ol>
</li>
</ul>
<h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><ul>
<li><p>在阻塞队列中，线程阻塞分为两种情况。</p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336228088.png" alt="1563336228088"></p>
<ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336249697.png" alt="1563336249697"></p>
</li>
</ul>
<h4 id="阻塞队列主要方法"><a href="#阻塞队列主要方法" class="headerlink" title="阻塞队列主要方法"></a>阻塞队列主要方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：抛出一个异常。</li>
<li>特殊值：返回一个特殊值(null或false，视情况而定)。</li>
<li>阻塞：在成功操作之前，一直阻塞线程。</li>
<li>超时：放弃前只在最大的时间内阻塞。</li>
</ul>
<ul>
<li><p><strong>插入操作</strong></p>
<ul>
<li><code>public abstract boolean add(E paramE)</code>:将指定元素插入到此队列中(如果立即可行且不会违反容量限制)，成功时返回true,如果当前没有可用的空间，则抛出<code>IllegalStateException</code>.如果该元素是NULL，则会抛出<code>NullPointerException</code>异常。</li>
<li><code>public abstract boolean offer(E paramE)</code>:将指定元素插入此队列中(如果立即可行且不会违反容量限制)，成功时返回<code>true</code>，如果当前没有可用的空间，则返回<code>false</code>。</li>
<li><code>public abstract void put(E paramE) throws InterruptedException</code>:将指定元素插入到此队列中，将等待可用的空间(如果有必要)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> checkNotNull(paramE);</span><br><span class="line"> ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;</span><br><span class="line"> localReentrantLock.lockInterruptibly();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length)</span><br><span class="line">     <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">     enqueue(paramE);</span><br><span class="line">         localReentrantLock.unlock();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 		localReentrantLock.unlock();</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>offer(E o,long timeout,TimeUnit unit)</code>:可以设定等待时间，如果在指定的时间内，还不能往队列中加入<code>BlockingQueue</code>,则返回失败。</li>
</ul>
</li>
<li><p><strong>获取数据操作</strong></p>
<ul>
<li><code>poll(time)</code>取出<code>BlockingQueue</code>里面排在首位的对象，若不能立即取出，则可以等待time参数规定的时间，取不到时返回<code>null</code>。</li>
<li><code>poll(long timeout,TimeUnit unit)</code>:从<code>BlockingQueue</code>取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，返回失败。</li>
<li><code>take()</code>:取出<code>BlockingQueue</code>里排在首位的对象，若<code>BlockingQueue</code>为空，阻断进入等待状态直到<code>BlockintQueue</code>有新的数据被加入。</li>
<li><code>drainTo()</code>:一次性从<code>BlockingQueue</code>获取所有可用的数据对象(还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率，不需要多次分批加锁或释放锁。</li>
</ul>
</li>
</ul>
<h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul>
<li><code>ArrayBlockingQueue</code>:由数组结构组成的有界阻塞队列(公平，非公平)。<ul>
<li>用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序，<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平的访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素，通常情况下为了保证公平性会降低吞吐量，我们可以使用代码创建一个公平的阻塞队列<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true)；</code>。</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code>:由链表结构组成的有界阻塞队列(两个独立锁提高并发)。<ul>
<li>基于链表的阻塞队列，同<code>ArrayListBlockQueue</code>类似，此队列按照先进先出(FIFO)的原则对元素进行排序，而<code>LinkedBlockingQueue</code>之所以能高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<code>LinkedBlockingQueue会默认一个类似无限大小地容量(Integer.MAX_VALUE)</code>。</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code>:支持优先级排序的无界阻塞队列(compareTo排序实现优先)。<ul>
<li>是一个支持优先队列的无界队列，默认情况下元素采取自然顺序升序排列，可以自定义实现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序，需要注意的是不能保证同优先级元素的顺序。</li>
</ul>
</li>
<li><code>DelayQueue</code>:使用优先级队列实现的无界阻塞队列(缓存失效，定时任务)。<ul>
<li><strong>是一个支持延迟获取元素的无界阻塞队列</strong>，队列使用<code>PriorityQueue</code>来实现，队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素，我们可以将<code>DelayQueue</code>运用到如下场景<ul>
<li>缓存系统的设计，可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行。比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
</li>
</ul>
</li>
<li><code>SynchronousQueue</code>:不存储元素的阻塞队列(不存储数据，可用于传递数据)。<ul>
<li><strong>是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素</strong>。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li>
</ul>
</li>
<li><code>LinkedTransferQueue</code>:由链表结构组成的无界阻塞队列。<ul>
<li>是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列，相对于其他阻塞队列，LinkedTransferQueue多了<code>tryTransfer()和transfer()</code>方法</li>
<li><strong>transfer()方法</strong>：如果当前有消费者正在等待接收元素(消费者使用take()方法或者带时间限制的poll()方法时)，<strong>transfer()方法可以把生产者传入的元素立即transfer给消费者.如果没有消费者在等待接收元素，transfer()方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</strong></li>
<li><strong>tryTransfer()方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者，如果没有消费者等待接收元素，则返回false。和<code>transfer()</code>的区别是<code>tryTransfer()</code>无论消费者是否接收，方法立即返回，而<code>transfer()</code>是必须等到消费者消费了才返回。</li>
<li>对于带有时间限制的<code>tryTransfer(E e,long timeout,TimeUnit unit)</code>方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>
</ul>
</li>
<li><code>LinkedBlockingDeque</code>:由链表结构组成的双向阻塞队列。<ul>
<li>是一个由链表组成的<strong>双向阻塞队列</strong>。<strong>所谓的双向队列指的是你可以从队列的两端插入和移除元素</strong>。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst(),addLast(),offerFirst(),offerLast(),peekFirst(),peekLast()</code>等方法，以First结尾的方法，表示插入，获取或移除双端队列的第一个元素，以Last结尾的方法，表示插入，获取和移除双端队列的最后一个元素。另外插入方法add()等同于addLast(),移除方法remove()等同于removeFirst()。但是take()方法却等同于takeFirst()。</li>
<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀，另外双向队列可以用在“工作窃取”模式中。</li>
</ul>
</li>
</ul>
<h2 id="CyclicBarrier-CountDownLatch和Semaphore的用法"><a href="#CyclicBarrier-CountDownLatch和Semaphore的用法" class="headerlink" title="CyclicBarrier,CountDownLatch和Semaphore的用法"></a>CyclicBarrier,CountDownLatch和Semaphore的用法</h2><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h4><ul>
<li><code>CountDownLatch</code>位于java.util.concurrent包下，使用它可以实现类似计数器的功能。如有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以利用CountDownLatch来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"等待2个子线程执行完毕"</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)"></a>CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</h4><ul>
<li><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code>可以被重用，暂且把这个状态叫做barrier,当调用<code>await()</code>之后，线程就处于barrier。CyclicBarrier中最重要的方法就是<code>await()</code>,它有两个重载版本：</p>
<ol>
<li><code>public int await()</code>:用来挂起当前线程，直至所有线程都到达<strong>barrier状态</strong>再同时执行后续任务。</li>
<li><code>pubilc int await(long timeout,TimeUnit unit)</code>:让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><ul>
<li><p><strong>Semaphore可以控制同时访问的线程个数</strong>，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。</p>
</li>
<li><p>Semaphore常用的方法：</p>
<ol>
<li><code>public void acquire()</code>:用来获取一个许可，若无许可能够获取，则会一直等待，直到获得许可。</li>
<li><code>public void acquire(int permits)</code>:获取permits许可。</li>
<li><code>public void release()</code>:释放许可(在释放许可之前，必须先获得许可)。</li>
<li><code>public void release(int permits)</code>:释放permits个许可。</li>
</ol>
</li>
<li><p>上述4个方法都会被阻塞，如果想立即得到执行结果，可以使用下述方法。</p>
<ol>
<li><code>public boolean tryAcquire()</code>:尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li><code>public boolean tryAcquire(long timeout,TimeUnit unit)</code>:尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。</li>
<li><code>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)</code>:尝试获取permits个许可，若在指定的时间内获取成功，则返回true，否则返回false。</li>
<li><code>public boolean tryAcquire(int permits)</code>:尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li>还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完</span></span><br><span class="line"><span class="comment"> 了，其他工人才能继续使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，<strong>CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</strong></li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
<h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul>
<li><strong><em>newCachedThreadPool</em></strong><ul>
<li>创建一个可根据需要创建新线程的线程池，但是在以前已经构造的线程可用时将重用它们，对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能，调用<strong>execute</strong>将重用以前构造的线程(如果线程可用)，如果现有线程没有可用的，则创建一个新的线程并添加到线程池中，终止并从缓存中移除那些已有60秒未被使用的线程，因此，长时间保持空闲的线程池不会使用任何资源。</li>
</ul>
</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>创建一个可重用固定线程数的线程池，以共享的无界队列来运行这些线程，在任意点，在大多数nThreads线程会处于处理任务的活动状态，如果在所有线程处于活动时提交附加任务，则在有可用线程之前，附加1任务将在队列中等待，如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个线程将代替它执行后续的任务(如果需要),在某个线程被显式地关闭之前，池中的线程将一直存在。</li>
</ul>
</li>
<li><strong>newScheduledThreadPool</strong><ul>
<li>创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。</li>
</ul>
</li>
<li><strong>newSingleThreadExecutor</strong><ul>
<li><strong>Executors.newSingleThreadExecutor()</strong>返回一个线程池(只有一个线程),这个线程池可以在线程死后(或发生异常)重新启动一个线程来代替原有的线程继续执行下去。</li>
</ul>
</li>
</ul>
<h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p><img src="/2019/07/16/Java并发补充/1563288982967.png" alt="1563288982967"></p>
<ul>
<li><strong>线程等待(wait)</strong><ul>
<li>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁，因此，wait()方法一般用在同步方法或同步代码块中。</li>
</ul>
</li>
<li><strong>线程睡眠(sleep)</strong><ul>
<li>sleep导致当前线程休眠，与wait不同的是sleep不会释放当前占用的锁，sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态。</li>
</ul>
</li>
<li><strong>线程让步(yield)</strong><ul>
<li>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片，一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li>
</ul>
</li>
<li><strong>线程中断(interrupt)</strong><ul>
<li>调用interrupt()方法并不会中断一个正在运行的线程，就是说处于Running状态的线程并不会因为被中止而被终止，仅仅改变了内部维护的中断标识位而已。</li>
<li>若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出<strong>InterruptedException</strong>,从而使线程提前结束TIMED-WATING状态。</li>
<li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</li>
</ul>
</li>
<li><strong>Join等待其他线程终止</strong><ul>
<li>join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待CPU的执行。</li>
</ul>
</li>
<li><strong>线程唤醒(notify)</strong><ul>
<li>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与该对象上主动同步的其他所有线程进行竞争，类似的方法还有notifyAll(),唤醒在此监视器上等待的所有线程。</li>
</ul>
</li>
<li><strong>其他常用方法</strong><ul>
<li><code>isAlive()</code>:判断一个线程是否存活。</li>
<li><code>activeCount()</code>:程序中活跃的线程数。</li>
<li><code>enumerate()</code>:枚举程序中的线程。</li>
<li><code>currentThread()</code>:得到当前线程。</li>
<li><code>isDaemon()</code>:一个线程是否为守护线程。</li>
<li><code>setDaemon()</code>:设置一个线程为守护线程。</li>
<li><code>setName()</code>:为线程设置名称。</li>
<li><code>setPriority()</code>:设置一个线程的优先级。</li>
<li><code>getPriority()</code>:获得一个线程的优先级。</li>
</ul>
</li>
</ul>
<h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><ul>
<li><strong>同步锁</strong><ul>
<li>当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种问题的出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据，Java中可已使用synchronized关键字来取得一个对象的同步锁。</li>
</ul>
</li>
<li><strong>死锁</strong><ul>
<li>就是多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。</li>
</ul>
</li>
</ul>
<h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><ul>
<li>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</li>
</ul>
<h4 id="变量可见性"><a href="#变量可见性" class="headerlink" title="变量可见性"></a>变量可见性</h4><ul>
<li>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</li>
</ul>
<h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul>
<li>volatile禁止了指令重排。</li>
</ul>
<h4 id="比Synchronized更轻量级的同步锁"><a href="#比Synchronized更轻量级的同步锁" class="headerlink" title="比Synchronized更轻量级的同步锁"></a>比Synchronized更轻量级的同步锁</h4><ul>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比Synchronized更轻量级的同步机制，volatile适合于这种场景：“<strong>一个变量被多个线程共享，线程直接给这个变量赋值</strong>”。</li>
<li>当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读写变量都从内存中读，跳过CPU cache这一步。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563354774642.png" alt="1563354774642"></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<ol>
<li>对变量的些操作不依赖于当前值(如i++)，或者说是单纯的1变量赋值(boolean flag = true)</li>
<li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用<code>volatile</code>。</li>
</ol>
</li>
</ul>
<h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><ul>
<li>进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性JVM解决了可见性和有序性的问题，而锁解决了原子性的问题，在理想的情况下我们希望做到“同步”和“互斥”，有以下的实现方式.</li>
</ul>
<h4 id="将数据抽象为一个类，并将数据的操作作为这个类的方法"><a href="#将数据抽象为一个类，并将数据的操作作为这个类的方法" class="headerlink" title="将数据抽象为一个类，并将数据的操作作为这个类的方法"></a>将数据抽象为一个类，并将数据的操作作为这个类的方法</h4><ul>
<li>将数据抽象为一个类，并将对这个数据的操作作为这个类的方法，这样可以很容易做到同步，只要在方法上加上<code>synchronized</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data= data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.dec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(add).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable对象作为一个类的内部类"><a href="#Runnable对象作为一个类的内部类" class="headerlink" title="Runnable对象作为一个类的内部类"></a>Runnable对象作为一个类的内部类</h4><ul>
<li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><ul>
<li>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</li>
</ul>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ol>
<li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</li>
<li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li>
<li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null</code>;</li>
</ol>
<p><img src="/2019/07/16/Java并发补充/1563357402171.png" alt="1563357402171"></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>最常用于解决数据库连接，Session管理等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">     Session s = (Session) threadSession.get(); </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">             s = getSessionFactory().openSession(); </span><br><span class="line">             threadSession.set(s); </span><br><span class="line">             &#125; </span><br><span class="line">    	 &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">     		<span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>都是用来协调多线程对共享对象，变量的访问。</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁。</li>
<li>都保证了可见性和互斥性。</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的<br>不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻<br>塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言<br>实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等</li>
</ol>
<h2 id="Volatile和Synchronized的区别"><a href="#Volatile和Synchronized的区别" class="headerlink" title="Volatile和Synchronized的区别"></a>Volatile和Synchronized的区别</h2><ol>
<li>volatile不会进行加锁操作。</li>
<li>volatile变量作用类似于同步变量读写操作。</li>
<li>volatile不如Synchronized安全。</li>
<li>volatile无法同时保证内存可见性和原子性。</li>
</ol>
<h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul>
<li>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li>
</ul>
<h4 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h4><ul>
<li>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</li>
<li>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</li>
</ul>
<h4 id="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><a href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成" class="headerlink" title="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"></a>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</h4><ul>
<li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358149513.png" alt="1563358149513"></p>
<h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul>
<li>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</li>
</ul>
<h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><ul>
<li>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</li>
</ul>
<h4 id="JVM的线程调度实现-抢占式调度"><a href="#JVM的线程调度实现-抢占式调度" class="headerlink" title="JVM的线程调度实现(抢占式调度)"></a>JVM的线程调度实现(抢占式调度)</h4><ul>
<li>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</li>
</ul>
<h4 id="线程让出cpu的情况"><a href="#线程让出cpu的情况" class="headerlink" title="线程让出cpu的情况"></a>线程让出cpu的情况</h4><ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。</li>
</ol>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><ul>
<li><strong>先来先服务调度算法(FCDS)</strong><ul>
<li>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</li>
</ul>
</li>
<li><strong>短作业(进程)优先调度算法</strong><ul>
<li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</li>
</ul>
</li>
</ul>
<h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><ul>
<li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</li>
<li><strong>非抢占式优先权算法</strong><ul>
<li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
</li>
<li><strong>抢占式优先权调度算法</strong><ul>
<li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
<li><strong>高响应比优先调度算法</strong><ul>
<li>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</li>
</ul>
</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358860683.png" alt="1563358860683"></p>
<h4 id="基于时间片的轮询调度算法"><a href="#基于时间片的轮询调度算法" class="headerlink" title="基于时间片的轮询调度算法"></a>基于时间片的轮询调度算法</h4><ul>
<li><strong>时间片轮转法</strong><ul>
<li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</li>
</ul>
</li>
<li><strong>多级反馈队列调度算法</strong><ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li>
</ol>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h4 id="概念特性"><a href="#概念特性" class="headerlink" title="概念特性"></a>概念特性</h4><ul>
<li>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</li>
<li>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</li>
</ul>
<h4 id="原子包java-util-concurrent-atomic-锁自旋"><a href="#原子包java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包java.util.concurrent.atomic(锁自旋)"></a>原子包java.util.concurrent.atomic(锁自旋)</h4><ul>
<li>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">        <span class="keyword">return</span> current; </span><br><span class="line"> 	&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul>
<li>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li>
<li>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li>
<li>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</li>
</ul>
<h2 id="什么是AQS-抽象的队列同步器"><a href="#什么是AQS-抽象的队列同步器" class="headerlink" title="什么是AQS(抽象的队列同步器)"></a>什么是AQS(抽象的队列同步器)</h2><ul>
<li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563360810227.png" alt="1563360810227"></p>
<ul>
<li>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br><strong>getState()，setState()，compareAndSetState()</strong>。</li>
<li>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li>
</ol>
</li>
</ul>
<h4 id="AQS资源共享方式"><a href="#AQS资源共享方式" class="headerlink" title="AQS资源共享方式"></a>AQS资源共享方式</h4><ul>
<li><strong>Exclusive独占资源-ReentrantLock</strong><ul>
<li>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</li>
</ul>
</li>
<li><strong>Share 共享资源-Semaphore/CountDownLatch</strong><ul>
<li>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</li>
</ul>
</li>
</ul>
<h4 id="同步器的实现ABS核心-state资源状态计数"><a href="#同步器的实现ABS核心-state资源状态计数" class="headerlink" title="同步器的实现ABS核心(state资源状态计数)"></a>同步器的实现ABS核心(state资源状态计数)</h4><ul>
<li>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</li>
</ul>
<h4 id="ReentrantReadWriteLock实现独占和共享两种方式"><a href="#ReentrantReadWriteLock实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock实现独占和共享两种方式"></a>ReentrantReadWriteLock实现独占和共享两种方式</h4><ul>
<li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java-并发/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>-java -并发</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/15/Collection总结/">
      Collection总结
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-15</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="集合架构图"></p>
<h2 id="图中大体概述"><a href="#图中大体概述" class="headerlink" title="图中大体概述"></a>图中大体概述</h2><ul>
<li>Iterator:可以通过迭代器遍历集合中的数据</li>
<li>Collection:是集合list,set,Queue的最基本的接口</li>
<li>Map：是映射表的基础接口</li>
</ul>
<h4 id="List接口详解"><a href="#List接口详解" class="headerlink" title="List接口详解"></a>List接口详解</h4><ul>
<li><p>List作为有序的Collection的代表，共有三个实现类，分别为<strong>ArrayList</strong>,<strong>LinkedList</strong>,<strong>Vector</strong>。</p>
</li>
<li><p><strong>ArrayList</strong></p>
<ul>
<li><p>内部是通过数组实现的，它允许对元素进行快速随机访问，缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中，当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制，移动，代价比较高，因此，它适合于随机查找与遍历，不适合插入和删除。</p>
<p><img src="/2019/07/15/Collection总结/1563183452932.png" alt="1563183452932"></p>
</li>
</ul>
</li>
<li><p><strong>LinkList</strong></p>
<ul>
<li><p>内部是双链表结构存储数据，适合数据的插入与删除，随机访问和遍历速度比较慢，此外，还提供了List接口中没有定义的方法，专门用于操作表头和表位元素，可以当作堆栈，队列和双向队列使用。</p>
<p><img src="/2019/07/15/Collection总结/1563183654460.png" alt="1563183654460"></p>
</li>
</ul>
</li>
<li><p><strong>Vector</strong></p>
<ul>
<li>与ArrayList一样，也是通过数组结构实现的，不同于它的是Vector支持线程的同步，避免多线程同时而引起的不一致性，但实现同步需要很高的花费，因此，效率不及ArrayList。</li>
</ul>
</li>
<li><p><strong>List简单总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层结构</th>
<th>优缺点</th>
<th>线程安全性</th>
<th>扩容</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>数组</td>
<td>查询快 ，插入/删除慢</td>
<td>不安全</td>
<td>当前容量*1.5+1</td>
</tr>
<tr>
<td>LinkList</td>
<td>双链表</td>
<td>插入/删除快，查找慢</td>
<td>不安全</td>
<td>———–</td>
</tr>
<tr>
<td>Vector</td>
<td>数组</td>
<td>查询快，插入/删除慢</td>
<td>安全</td>
<td>默认一倍扩容</td>
</tr>
</tbody></table>
<h4 id="Set集合详解"><a href="#Set集合详解" class="headerlink" title="Set集合详解"></a>Set集合详解</h4><ul>
<li><p>Set重视元素的唯一性，用于存储无序(存和取的顺序不一定相同)元素，值不能重复，根据对象的hashCode值进行判断的，如果想要让两个对象视为相等的，就必须覆盖Object的hashCode和equals方法。它的主要实现类：<strong>HashSet</strong>，<strong>TreeSet</strong>，<strong>LinkHashSet</strong>。</p>
</li>
<li><p><strong>HashSet</strong></p>
<ul>
<li>HashSet存储元素的顺序不是按照存入时的顺序，而是按照哈希值来存取数据的，元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先会判断两个元素的哈希值，如果哈希值一样，再比较equals，如果equals相等就视为同一个元素，否则就不是同一个元素。</li>
<li>哈希值相同equals为false的元素的存储问题，当出现这种情况是会在相同的哈希值下顺延，也就是哈希一样的存一列，HashSet通过hashCode值来确定元素在内存中的位置，一个hashCode位置上可以存放多个元素。</li>
</ul>
</li>
<li><p><strong>TreeSet</strong></p>
<ul>
<li>TreeSet是使用二叉树对新add()的对象按照指定的顺序排序(升序，降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</li>
<li>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序。</li>
<li>比较次对象与指定对象的顺序，如果该对象小于，等于或大于指定对象，则分别返回负整数，零或正整数。</li>
</ul>
</li>
<li><p><strong>LinkHashSet</strong></p>
<ul>
<li><p>LinkHashSet继承HashSet和LinkedHashMap来实现的，LinkedHashSet底层使用LinkHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层结构</th>
<th>优缺点</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>HashMap</td>
<td>存取快，排列无序，不可重复,可为null</td>
<td>不安全</td>
</tr>
<tr>
<td>TreeSet</td>
<td>二叉树</td>
<td>排列有序，不可重复</td>
<td>安全</td>
</tr>
<tr>
<td>LinkHashSet</td>
<td>Hash表+双向链表</td>
<td>排列有序，不可重复</td>
<td>不安全</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="Map集合详解"><a href="#Map集合详解" class="headerlink" title="Map集合详解"></a>Map集合详解</h4><ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>HashMap(1.7)是数组和链表的结合体，数组每个元素存的是链表的头结点，往hashmap里面放键值对的时候先得到key的hashcode，然后重新计算hashcode，然后与length-1按位与，计算数组下标1，如果该下标对应的链表为空，则直接把键值对作为链表头结点，如果不为空，则1遍历链表看是否有key值相同，有就把value替换，没有就把该对对象作为链表的第一个节点，原有的节点为它的后续节点。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/Inked1.7_LI.jpg" alt="Inked1.7_LI"></p>
<ul>
<li><p>HashMap(1.8)是数组+链表+红黑树，当链表长度&gt;=8时转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入，删除，查找等算法。</p>
<p><img src="/2019/07/15/Collection总结/1563193744210.png" alt="1563193744210"></p>
</li>
<li><p>HashMap扩容</p>
<ul>
<li>初始容量16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。</li>
<li>扩容机制：使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有的Entry数的元素拷贝到新的Entry数组中，Java1.7重新计算每个元素在数组中的位置，Java1.8中不是从新计算，而是使用的是2次幂的扩展，所以，元素的位置要么是在原来的位置，要么是在原位置再移动2次幂的位置在扩展HashMap的时候，不需要像1.7的实现那样重新计算hash，只需要看看原来的hash值新增加的那个bit是1还是0就行了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</li>
</ul>
</li>
<li><p>HashMap为什么线程不安全(hash碰撞和扩容导致)</p>
<ul>
<li>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。加入A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</li>
<li>删除键值对的代码如上：当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写回到该数组位置去，其实写回的时候可能其他的线程已经把这个位置给修改过了，就会覆盖其他线程的修改当多个线程同时检测到总数量超过门限制的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有一个线程生成新的数组被赋给table变量，其他线程的均会丢失，而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</li>
<li>想要实现线程安全，那么就要调用collections类的静态方法<strong>synchronizeMap()</strong>实现</li>
</ul>
</li>
<li><p><strong>HashTable</strong></p>
<ul>
<li>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</li>
</ul>
</li>
<li><p><strong>TreeMap</strong></p>
<ul>
<li>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</li>
</ul>
</li>
<li><p><strong>LinkedHashMap</strong></p>
<ul>
<li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
</ul>
</li>
<li><p><strong>ConcurrentHashMap</strong></p>
<ul>
<li><p>Segment</p>
<ul>
<li>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/1563194323007.png" alt="1563194323007"></p>
</li>
<li><p>并行度</p>
<ul>
<li>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</li>
</ul>
</li>
<li><p>Java8实现</p>
<ul>
<li>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/1563194333363.png" alt="1563194333363"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层</th>
<th>优缺点</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td>
<td>key/value都可为null，查询快，递增排序</td>
<td>不安全</td>
</tr>
<tr>
<td>HashTable</td>
<td>散列表</td>
<td>key和Value都不可为null，递减排序</td>
<td>安全</td>
</tr>
<tr>
<td>TreeMap</td>
<td>红黑树</td>
<td>递增排序</td>
<td>不安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td>
<td>递增排序</td>
<td>安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>链表+哈希</td>
<td>存取一致</td>
<td>不安全</td>
</tr>
</tbody></table>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li><strong>Iterator和ListIterator的区别</strong><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
</li>
<li><strong>快速失败(fail-fast)和安全失败(fail-safe)的区别</strong><ul>
<li>Iterator的安全失败是基于对底层集合做拷贝，因此，不受原集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下的所有类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全1失败的迭代器永远不会抛出这样的异常。</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/集合/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>集合</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/14/JVM-五-GC分析/">
      JVM(五)GC分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-14</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="Java-GC分析"><a href="#Java-GC分析" class="headerlink" title="Java GC分析"></a>Java GC分析</h2><h4 id="什么是Java-GC"><a href="#什么是Java-GC" class="headerlink" title="什么是Java GC"></a>什么是Java GC</h4><ul>
<li>Java GC(Garbage Collection,垃圾收集,垃圾回收)机制,是Java与C++/C的主要区别之一,作为Java开发者,不需要专门编写内存回收和垃圾清理代码,对内存泄露和溢出问题,这是因为在Java虚拟机中,存在自动内存管理和垃圾收集机制,该机制对JVM中的内存进行标记,并确定那些内存需要回收,根据一定的回收策略,自动的回收内存,永不停息的保证JVM中的内存空间,防止出现内存泄漏和溢出问题，Java GC机制已经日益完善，几乎可以自动的为我们做绝大多数事情，但是，如果开发大型的软件开发，就必须要研究Java GC机制。</li>
<li>简单总结下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。</li>
</ul>
<h4 id="如何获取Java-GC日志"><a href="#如何获取Java-GC日志" class="headerlink" title="如何获取Java GC日志"></a>如何获取Java GC日志</h4><ul>
<li><p><strong>命令获取Java GC日志</strong></p>
<ul>
<li>Java自动的工具行命令，jstat可以动态的监控JVM内存的使用，统计垃圾回收的各项信息。</li>
<li>如：<code>jstat -gc</code>统计垃圾回收堆的行为</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc.png" alt="gc"></p>
<ul>
<li>也可以设置时间打印(图中每100ms打印一次，共打印200次)</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gctime.png" alt="gctime"></p>
</li>
<li><p><strong>GC参数</strong></p>
<ul>
<li>JVM的GC日志的主要参数包括如下：<ul>
<li><code>-XX:+PrintGC</code>输出GC日志</li>
<li><code>-XX:+PrintGCDetails</code>输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX:+PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如2019-7-14T17:17:17.177+0800)</li>
<li><code>-XX:PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</li>
</ul>
</li>
<li>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</li>
</ul>
</li>
<li><p><strong>Tomcat配置示例</strong></p>
<ul>
<li>在Tomcat的启动参数中添加JVM的相关参数，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"><span class="string">-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"><span class="string">-Djava.awt.headless=true </span></span><br><span class="line"><span class="string">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"><span class="string">-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"><span class="string">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数概况<ul>
<li><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</li>
<li><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是<br>Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young<br>genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio<br>设置成比较大的值（比如65536)来做到。</li>
<li><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</li>
<li><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li>
<li><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code><br>设置gc日志的格式。</li>
<li><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔。</li>
<li><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代。</li>
</ul>
</li>
</ul>
<h4 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h4><ul>
<li>Young GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">18.093</span>+<span class="number">0800</span>: <span class="number">25.395</span>: [GC [PSYoungGen: <span class="number">274931</span>K-&gt;<span class="number">10738</span>K(<span class="number">274944</span>K)] <span class="number">371093</span>K-&gt;<span class="number">147186</span>K(<span class="number">450048</span>K), <span class="number">0.0668480</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.08</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li>Full GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">19.160</span>+<span class="number">0800</span>: <span class="number">25.462</span>: [Full GC [PSYoungGen: <span class="number">10738</span>K-&gt;<span class="number">0</span>K(<span class="number">274944</span>K)] [ParOldGen: <span class="number">136447</span>K-&gt;<span class="number">140379</span>K(<span class="number">302592</span>K)] <span class="number">147186</span>K-&gt;<span class="number">140379</span>K(<span class="number">577536</span>K) [PSPermGen: <span class="number">85411</span>K-&gt;<span class="number">85376</span>K(<span class="number">171008</span>K)], <span class="number">0.6763541</span> secs] [Times: user=<span class="number">1.75</span> sys=<span class="number">0.02</span>, real=<span class="number">0.68</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young<br>gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。</p>
</li>
<li><p>通过两张图非常明显看出GC日志构成：</p>
<ul>
<li>Young GC日志：</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/%E5%89%8D%E5%8D%8A%E6%AE%B5%E5%88%86%E6%9E%90.jpg" alt="前半段分析"></p>
<ul>
<li>Full GC日志：</li>
</ul>
</li>
</ul>
<p>![full GC_LI](JVM-五-GC分析/full GC_LI.jpg)</p>
</li>
</ul>
<h4 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h4><ul>
<li><p><strong>GChisto</strong></p>
<ul>
<li>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</li>
<li>配置好本地的jdk环境后，双击GChisto.jar，在弹出的输入框点击add选择gc.log日志。<br><img src="/2019/07/14/JVM-五-GC分析/gc1.jpg" alt="gc1"></li>
<li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc2.jpg" alt="gc2"></p>
<ul>
<li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p>
</li>
<li><p>GC Timeline：显示整个时间线上的垃圾收集<img src="/2019/07/14/JVM-五-GC分析/gc3.jpg" alt="gc3"></p>
</li>
<li><p>这款工具已经不再维护了。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/13/JVM-四-JVM优化/">
      JVM(四)JVM优化
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-13</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="常用的JVM优化工具介绍"><a href="#常用的JVM优化工具介绍" class="headerlink" title="常用的JVM优化工具介绍"></a>常用的JVM优化工具介绍</h2><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>​    JVM Process Status Tool,显式指定系统内所有的HotSpot虚拟机进程.</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jps [options] [hostid]</code></p>
</li>
<li><p><strong>option参数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l:输出主类全名或jar路径</span><br><span class="line">-q:只输出LVMID</span><br><span class="line">-m:输出JVM启动时传递给main()的参数</span><br><span class="line">-v:输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>演示</strong></p>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jps%E6%BC%94%E7%A4%BA.png" alt="jps演示"></p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>​    jstat(JVM statisics Monitoring)是用于监视虚拟机运行时状态信息的命令,可以显示出虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jstat [option] LVMID [interval] [count]</code></p>
</li>
<li><p><strong>参数</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option]:操作参数</span><br><span class="line"><span class="function"> LVMID:本地虚拟机进程<span class="title">ID</span></span></span><br><span class="line"><span class="function">[<span class="title">interval</span>]:连续输出的时间间隔</span></span><br><span class="line"><span class="function">[<span class="title">count</span>]:连续输出的次数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>option参数讲解</strong></p>
<ol>
<li>class:监视类加载,卸载数量,总空间以及耗费的时间</li>
</ol>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jstatclass.png" alt="jstatclass"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Loader:加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes:class</span>字节大小</span></span><br><span class="line"><span class="function"><span class="title">Unloaded</span>:未加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes</span>:未加载<span class="title">class</span>的字节大小</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:加载时间</span></span><br></pre></td></tr></table></figure>

<pre><code>2. compiler:输出JIT编译过的方法数量耗时等</code></pre><p><img src="/2019/07/13/JVM-四-JVM优化/compiler.png" alt="compiler"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compiled:编译数量</span></span><br><span class="line"><span class="function"><span class="title">Failed</span>:编译失败数量</span></span><br><span class="line"><span class="function"><span class="title">Invalid</span>:无效数量</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:编译耗时</span></span><br><span class="line"><span class="function"><span class="title">FailedType</span>:失败类型</span></span><br><span class="line"><span class="function"><span class="title">FailedMethod</span>:失败方法的全限定名</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>gc:垃圾回收堆的行为统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gc.png" alt="gc"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">PC 当前perm的容量 (KB)</span><br><span class="line">PU perm的使用 (KB)</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11660 5000 100</span><br><span class="line"><span class="meta">#</span> 每隔5000ms输出11660的gc情况,一共输出100次</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>gccapacity:与gc相同,不过还会输出Java堆各区域使用到的最大,最小空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccapacity.png" alt="gccapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>gcutil:同gc,不过输出的是已使用空间占总空间的百分比</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcutil.png" alt="gcutil"></p>
<ol start="6">
<li>gccause:垃圾收集统计概述,附加最近两次垃圾回收事件到的原因</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccause.png" alt="gccause"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LGCC:最近垃圾回收的原因</span></span><br><span class="line"><span class="function"><span class="title">GCC</span>:当前垃圾回收的原因</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>gcnew:统计新生代1的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnew.png" alt="gcnew"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>gcnewcapacity:新生代与其相应的内存空间的统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnewcapacity.png" alt="gcnewcapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NGC:当前年轻代的容量 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0CMX</span>:最大的<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0C</span>:当前<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">ECMX</span>:最大<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">EC</span>:当前<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>gcold:统计旧生代的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcold.png" alt="gcold"></p>
<ol start="10">
<li>gcoldcapacity:统计旧生代的大小和空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcoldcapacity.png" alt="gcoldcapacity"></p>
<ol start="11">
<li>printcompilation:hotspot编译方法统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/Snipaste_2019-07-13_16-55-48.png" alt="Snipaste_2019-07-13_16-55-48"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line"><span class="built_in">Type</span>：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure>

<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump : 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat : to <span class="built_in">print</span> permanent generation statistics</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<ol>
<li><p>dump常用格式</p>
<p><code>-dump::live,format=b,file=&lt;filename&gt; pid</code></p>
<p>dump堆到文件,format指定输出格式,live指是活着的对象,file指文件名</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/dump.png" alt="dump"></p>
<ol start="2">
<li>finalizerinfo:打印等待回收对象的信息</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/info.png" alt="info"></p>
<p>​    可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行的finalizer方法的对象</p>
<ol start="3">
<li><p>heap:打印heap的概要信息,GC使用的算法,heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">finalizerinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Number</span> <span class="title">of</span> <span class="title">objects</span> <span class="title">pending</span> <span class="title">for</span> <span class="title">finalization</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">heap</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">using</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">object</span> <span class="title">allocation</span>.</span></span><br><span class="line"><span class="function"><span class="title">Parallel</span> <span class="title">GC</span> <span class="title">with</span> 4 <span class="title">thread</span>(<span class="title">s</span>)	//<span class="title">GC</span>方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Configuration</span>:		//堆内存初始化配置</span></span><br><span class="line"><span class="function">   <span class="title">MinHeapFreeRatio</span>         = 0</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapFreeRatio</span>         = 100</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapSize</span>              = 734003200 (700.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewSize</span>                  = 44564480 (42.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxNewSize</span>               = 244318208 (233.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">OldSize</span>                  = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewRatio</span>                 = 2</span></span><br><span class="line"><span class="function">   <span class="title">SurvivorRatio</span>            = 8</span></span><br><span class="line"><span class="function">   <span class="title">MetaspaceSize</span>            = 21807104 (20.796875<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">CompressedClassSpaceSize</span> = 1073741824 (1024.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxMetaspaceSize</span>         = 17592186044415 <span class="title">MB</span></span></span><br><span class="line"><span class="function">   <span class="title">G1HeapRegionSize</span>         = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Usage</span>:			//堆内存使用情况</span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Young</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function"><span class="title">Eden</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 34078720 (32.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 19266416 (18.373886108398438<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 14812304 (14.126113891601562<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   56.5350341796875% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">From</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 4417480 (4.212837219238281<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 825400 (0.7871627807617188<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   84.25674438476562% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.0% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Old</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 90128 (0.0859527587890625<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 89563120 (85.41404724121094<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.10052954244334796% <span class="title">used</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5507 <span class="title">interned</span> <span class="title">Strings</span> <span class="title">occupying</span> 497712 <span class="title">bytes</span>.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>histo:打印堆的对象统计,包括对象数,内存大小等等</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/histo.png" alt="histo"></p>
<h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>​    jhat命令是与jmap搭配使用,用来分析jmap生成的dump,jhat内置了一个微型的HTTP/HTML服务器,生成dump的分析结果后,可以在浏览器中查看,在此需要注意,一般不会直接在服务器上进行分析,因为jhat是一个耗时并且耗费硬件资源的过程,一般把服务器生成的dump文件复制到本地或其他机器上进行分析.</p>
<ul>
<li><p>命令格式</p>
<p><code>jhat [dumpfile]</code></p>
</li>
<li><p>参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line"></span><br><span class="line">-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line"></span><br><span class="line">-port port-number 设置 jhat HTTP server 的端口号. 默认值 <span class="number">7000</span>.&gt;</span><br><span class="line"></span><br><span class="line">-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line"></span><br><span class="line">-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as <span class="keyword">not</span> being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line"></span><br><span class="line">-debug int 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line"></span><br><span class="line">-version 启动后只显示版本信息就退出&gt;</span><br><span class="line"></span><br><span class="line">-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<p>​    第一步:导出堆</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">dump:live</span>,<span class="title">file</span>=<span class="title">a.map</span> 11660</span></span><br><span class="line"><span class="function"><span class="title">Dumping</span> <span class="title">heap</span> <span class="title">to</span> <span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">a.map</span> ...</span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">dump</span> <span class="title">file</span> <span class="title">created</span></span></span><br></pre></td></tr></table></figure>

<p>​    第二步:分析堆文件</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jhat</span> <span class="title">a.map</span></span></span><br><span class="line"><span class="function"><span class="title">Reading</span> <span class="title">from</span> <span class="title">a.map</span>...</span></span><br><span class="line"><span class="function"><span class="title">Dump</span> <span class="title">file</span> <span class="title">created</span> <span class="title">Sat</span> <span class="title">Jul</span> 13 18:51:20 <span class="title">CST</span> 2019</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">read</span>, <span class="title">resolving</span>...</span></span><br><span class="line"><span class="function"><span class="title">Resolving</span> 2299776 <span class="title">objects</span>...</span></span><br><span class="line"><span class="function"><span class="title">Chasing</span> <span class="title">references</span>, <span class="title">expect</span> 459 <span class="title">dots</span>.............................</span></span><br><span class="line"><span class="function"><span class="title">Eliminating</span> <span class="title">duplicate</span> <span class="title">references</span>.........................</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">resolved</span>.</span></span><br><span class="line"><span class="function"><span class="title">Started</span> <span class="title">HTTP</span> <span class="title">server</span> <span class="title">on</span> <span class="title">port</span> 7000</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>.</span></span><br></pre></td></tr></table></figure>

<p>​    第三步:查看HTML</p>
<p><img src="/2019/07/13/JVM-四-JVM优化/1563015344059.png" alt="1563015344059"></p>
</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>​    jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native<br>stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java<br>stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。    </p>
<ul>
<li><p>命令格式</p>
<p><code>jstack [option] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jstack</span> -<span class="title">l</span> 11660|<span class="title">more</span></span></span><br><span class="line"><span class="function">2019-07-13 18:58:09</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">OpenJDK</span> 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (25.152-<span class="title">b11</span> <span class="title">mixed</span> <span class="title">mode</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 216" #550 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7ba000</span> <span class="title">nid</span>=0<span class="title">x1d5c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005dbef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.getTask</span>(<span class="title">ThreadPoolExecutor.java</span>:1066)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.runWorker</span>(<span class="title">ThreadPoolExecutor.java</span>:1127)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor</span>$<span class="title">Worker.run</span>(<span class="title">ThreadPoolExecutor.java</span>:617)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">Thread.java</span>:745)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">Locked</span> <span class="title">ownable</span> <span class="title">synchronizers</span>:</span></span><br><span class="line"><span class="function">        - <span class="title">None</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 215" #549 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7c0000</span> <span class="title">nid</span>=0<span class="title">x3b44</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005daef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">-- <span class="title">More</span>  --</span></span><br></pre></td></tr></table></figure>

<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>​    jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
</li>
<li><p>命令格式</p>
<p><code>jinfo [option] [args] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">System</span> <span class="title">Properties</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">java.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">preload.project.path</span> = <span class="title">D</span>:/<span class="title">code</span>/<span class="title">IdeaProjects</span>/<span class="title">JVM</span></span></span><br><span class="line"><span class="function"><span class="title">sun.java.launcher</span> = <span class="title">SUN_STANDARD</span></span></span><br><span class="line"><span class="function"><span class="title">idea.config.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span></span></span><br><span class="line"><span class="function"><span class="title">sun.management.compiler</span> = <span class="title">HotSpot</span> 64-<span class="title">Bit</span> <span class="title">Tiered</span> <span class="title">Compilers</span></span></span><br><span class="line"><span class="function"><span class="title">sun.nio.ch.bugLevel</span> =</span></span><br><span class="line"><span class="function"><span class="title">idea.paths.selector</span> = <span class="title">IntelliJIdea2017</span>.3</span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.client.alive.path</span> = "<span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">AppData</span>\<span class="title">Local</span>\<span class="title">Temp</span>\<span class="title">kotlin</span>-<span class="title">idea</span>-4516842704025065651-<span class="title">is</span>-<span class="title">running</span>"</span></span><br><span class="line"><span class="function"><span class="title">os.name</span> = <span class="title">Windows</span> 10</span></span><br><span class="line"><span class="function"><span class="title">sun.boot.class.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">resources.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">rt.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">sunrsasign.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jsse.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jce.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">charsets.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jfr.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">classes</span></span></span><br><span class="line"><span class="function"><span class="title">sun.desktop</span> = <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">idea.plugins.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span>\<span class="title">plugins</span></span></span><br><span class="line"><span class="function"><span class="title">java.vm.specification.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">java.runtime.version</span> = 1.8.0<span class="title">_102</span>-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">io.netty.serviceThreadPrefix</span> = <span class="title">Netty</span></span></span><br><span class="line"><span class="function"><span class="title">user.name</span> = 严茂</span></span><br><span class="line"><span class="function"><span class="title">kotlin.incremental.compilation</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">idea.home.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">JetBrains</span>\<span class="title">IntelliJ</span> <span class="title">IDEA</span> 2017.3.4</span></span><br><span class="line"><span class="function"><span class="title">user.language</span> = <span class="title">zh</span></span></span><br><span class="line"><span class="function"><span class="title">jdt.compiler.useSingleThread</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">sun.boot.library.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">bin</span></span></span><br><span class="line"><span class="function"><span class="title">java.version</span> = 1.8.0<span class="title">_102</span></span></span><br><span class="line"><span class="function"><span class="title">user.timezone</span> = <span class="title">Asia</span>/<span class="title">Shanghai</span></span></span><br><span class="line"><span class="function"><span class="title">java.net.preferIPv4Stack</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.enabled</span> =</span></span><br><span class="line"><span class="function"><span class="title">sun.arch.data.model</span> = 64</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/12/JVM-三-GC算法-垃圾收集器/">
      JVM(三)GC算法-垃圾收集器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-12</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    垃圾收集通常被称之为”<strong>GC</strong>“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生成,随线程的销毁而销毁,栈帧随着方法的进入和退出做入栈和出栈操作,实现了自动的内存清理,因此,内存垃圾回收主要集中在java堆和方法区中,在程序运行期间,这部分的内存的分配和使用1都是动态的.</p>
<h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活一般有两种方式.</p>
<ul>
<li><p><strong>引用计数</strong>:每个对象有一个计数属性,新增一个引用时计数加1,引用释放时计数减1,计数为0时可以回收,此方法简单,无法解决对象相互循环引用的问题.</p>
</li>
<li><p><strong>可达性分析</strong>:从GC Roots开始向下搜寻,搜寻所走过的路径称之为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明对象是不可用的,不可达对象.</p>
</li>
<li><p>在Java中,GC Roots包括:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性实体引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li>
</ul>
</li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    <strong>标记-清除</strong>算法分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象,之所以说它是最基础的收集算法,是因为后续的收集算法都是基于这种思路并对其缺点进行改善而得到的.</p>
<p>​    它主要有两个缺点:<strong>一是效率问题</strong>,标记和清除过程的效率都不高,<strong>二是空间问题</strong>,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致,当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作.</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​    GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>​    “<strong>分代收集</strong>”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    如果说收集算法是内存回收的方法论,垃圾收集器就是内存回收的具体实现</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>​    串行收集器是最稳定,效率最高的收集器,可能会产生较长的停顿,只使用一个线程去回收,新生代,老年代使用串行回收;新生代复制算法,老年代标记-压缩;垃圾收集的过程中会服务暂停.</p>
<p>参数控制:<code>-XX:+UseSerialGC</code>串行收集器</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="串行收集器"></p>
<p>​    ParNew收集器ParNew收集器就是Serial收集器的多线程版本,新生代并行,老年代串行;新生代复制算法,老年代标记-压缩.</p>
<p>参数控制:</p>
<ul>
<li><p><code>-XX:+UseParNewGC</code>ParNew收集器</p>
</li>
<li><p><code>-XX:ParallelGCThreads</code>限制线程数量</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt="串行收集器2"></p>
</li>
</ul>
<h4 id="Paralle收集器"><a href="#Paralle收集器" class="headerlink" title="Paralle收集器"></a>Paralle收集器</h4><p>​    Parallel   Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>​    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>​    从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>​        其中初始标记、重新标记这两个步骤仍然需要“Stop  The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>​    由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p>​    <strong>优点</strong>: 并发收集、低停顿<br>​    <strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制:</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）    </p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/CMS.jpg" alt="CMS"></p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>​    G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：</p>
<ul>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ul>
<p>​        上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/G1.jpg" alt="G1"></p>
<p>​    G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent  Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young  GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE2.png" alt="图2"></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE3.png" alt="图3"></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%A4%8D%E5%88%B6%E6%B8%85%E9%99%A4.jpg" alt="复制清除"></p>
<h4 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h4><table>
<thead>
<tr>
<th></th>
<th>新生代GC策略</th>
<th>老年代GC策略</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>组合1</td>
<td>Serial</td>
<td>Serial Old</td>
<td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
</tr>
<tr>
<td>组合2</td>
<td>Serial</td>
<td>CMS+Serial Old</td>
<td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td>
</tr>
<tr>
<td>组合3</td>
<td>ParNew</td>
<td>CMS</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 <code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td>
</tr>
<tr>
<td>组合4</td>
<td>ParNew</td>
<td>Serial Old</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td>
</tr>
<tr>
<td>组合5</td>
<td>Parallel Scavenge</td>
<td>Serial Old</td>
<td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td>组合6</td>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td align="left">Parallel Old是Serial Old的并行版本</td>
</tr>
<tr>
<td>组合7</td>
<td>G1GC</td>
<td>G1GC</td>
<td align="left"><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code> #暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code> #暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小； <code>-XX:SurvivorRatio=6</code> #幸存区比例</td>
</tr>
</tbody></table>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/11/JVM-二-java类的加载机制/">
      JVM(二)java类的加载机制
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-11</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h3 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1. 什么是类加载"></a>1. 什么是类加载</h3><ul>
<li>类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个<strong>java.lang.Class</strong>对象,用来封装类在方法区内的数据结构,类的加载的最终是位于堆中的<strong>Class对象</strong>,Class对象封装了类在方法区的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口.</li>
<li>类加载器并不需要等到某个类被初次主动使用时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件异常问题,类加载器必须在程序首次主动使用该类时才报告错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误.</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p>
<ul>
<li>加载.class文件的方式<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip,jar等文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
</li>
</ul>
<h3 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类的加载过程"></h3><ul>
<li>一个java类的完整生命周期会经历<strong>加载,连接,初始化,使用和卸载</strong>五个阶段,其中,加载,验证,准备和初始化这四个阶段发生的顺序是确定的,但解析阶段则不一定,在某些情况下可以在初始化阶段之后开始,这是为了支持Java的运行时绑定.此外还需要注意这里的几个阶段是按顺序开始的,而不是按顺序进行或完成,因为这些阶段通常都是互相交叉混合进行的,通常在一个阶段执行的过程中调用或激活另一个阶段.</li>
<li><strong>加载</strong><ul>
<li>查找并加载类的二进制数据是类加载过程的第一个阶段,在加载阶段,虚拟机需要完成以下三件事.<ul>
<li>通过一个类的全限定类名来获取其定义的二进制字节流.</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象,作为对方法区中这些数据的访问入口.</li>
</ul>
</li>
<li>相对于类加载的其他阶段而言,加载阶段是可控性最强的阶段,因此开发者即可以使用系统提供的类加载器来完成加载,也可以自定义自己的类加载器来完成加载.</li>
<li>加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象,这样便可以通过该对象访问方法区中的这些数据.</li>
</ul>
</li>
<li><strong>连接</strong><ul>
<li><strong>验证:确保被加载的类的正确性.</strong><ul>
<li>验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全,验证阶段大致会完成4个阶段的检验动作.<ul>
<li><strong>文件格式验证</strong>:验证字节流是否符合Class文件格式的规范,如:是否以<code>0xCAFEBABE</code>开头,主次版本号是否在当前虚拟机的处理范围之内,常量池中的常量是否有不被支持的阶段.</li>
<li><strong>元数据验证</strong>:对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求;如:这个类是否有父类,除了<code>java.lang.Object</code>之外的.</li>
<li><strong>字节码验证</strong>:通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的.</li>
<li><strong>符号引用验证</strong>:确保解析动作能正确执行.</li>
</ul>
</li>
<li>验证阶段是非常重要的,但不是必须的,它对程序运行期没有影响,如果所引用的类经过反复验证,那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间.</li>
</ul>
</li>
<li><strong>准备:为类的静态变量分配内存,并将其初始化为默认值</strong><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配,对于该阶段的注意事项.<ul>
<li>这时进行内存分配的仅包括类变量(static),而不包括实例变量,实例变量会在对象实例化时随着对象一块分配在Java堆中.</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如:0,0L,null,false等等),而不是被在Java代码中被显式地赋予的值.</li>
<li>如果类字节地字段属性表中存在<code>ConstantValue</code>属性,即同时被final和static修饰,那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值.</li>
</ul>
</li>
</ul>
</li>
<li><strong>解析:把类中的符号引用转换为直接引用</strong><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用进行,符号引用就是一组符号来描述目标,可以是任何字面量.</li>
<li>直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄.</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>初始化,为类的静态变量赋予正确的初始值,JVM负责对类进行初始化,主要对类变量进行初始化,在Java中对类变量进行初始值设定有两种方式.<ul>
<li>声明类变量是指定初始化</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</li>
<li>JVM初始化步骤<ul>
<li>加入这个类还没有被加载和连接,则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被1初始化,则先加载其直接父类</li>
<li>假如类中有初始化语句,则系统依次执行这些初始化语句</li>
</ul>
</li>
<li>类初始化时机:只有当对类的主动使用的时候才会导致类的初始化,类的主动使用包括以下六种<ul>
<li>创建类的实例,也就是new的方法</li>
<li>访问某个类或接口的静态变量,或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化某个类的子类,则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类,直接使用java.exe命令来运行某个主类.</li>
</ul>
</li>
</ul>
</li>
<li><strong>结束生命周期</strong><ul>
<li>在这几种情况下,Java虚拟机将结束生命周期<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>先看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">     System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到,没有获取到ExtClassLoader的父Loader,原因是Bootstrap Loadder是用C写的,找不到一个确定的返回父Loader的方法,于是就返回null.</p>
<ul>
<li>类加载器的层次关系图</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="类加载器"></p>
<ul>
<li><strong>启动类加载器</strong>:负责加载存放在<code>JDK/jre/lib</code>下,或被<code>-Xbootclasspath</code>参数指定的路径中的,并且能被虚拟机识别的类库,启动类加载器是无法被Java程序直接引用的.</li>
<li><strong>扩展类加载器</strong>:该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,他负责加载<code>JDK/jre/lib/ext</code>目录中,或者由<code>java.ext.dirs</code>系统变量指定的路径中的所由类库,开发者可以直接使用扩展类加载器.</li>
<li><strong>应用程序类加载器</strong>:该类加载器由<code>sun.misc.Launcher#AppClassLoader</code>来实现,它负责加载用户类路径所指定的类,开发者可以直接使用该类加载器,如果程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器.</li>
</ul>
<h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><ul>
<li><strong>全盘负责</strong>:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Classs也将由该类加载器负责载入,除非显式使用另外一个类加载器来载入.</li>
<li><strong>父类委派</strong>:先让父类加载器试图加载该类,只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类.</li>
<li><strong>缓存机制</strong>:缓存价值将会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,只有缓存区不存在,系统才会读取该类对应的二进制数据,并将其转换为Class对象,存入缓存区,这就是为什么修改Class后,必须重启JVM,程序的修改才会生效.</li>
</ul>
<h3 id="4-类的加载"><a href="#4-类的加载" class="headerlink" title="4. 类的加载"></a>4. 类的加载</h3><ul>
<li>类的加载有三种方式<ul>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2", false, loader); </span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块执行了);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>:将类的.class文件加载到JVM中之外1,还会对类进行解释,执行类中的static块.</li>
<li><code>ClassLoader.loadClass()</code>:只干一件事,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newlnstance才会去执行static块</li>
<li><code>Class.forName(name,initialize,loader)带参函数也可以控制是否加载static块,并且只有调用newInstance()方法采用调用构造函数,创建类的对象</code>.</li>
</ul>
<h3 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h3><ul>
<li>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>双亲委派机制<ul>
<li>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li>
</ul>
</li>
<li>双亲委派模型意义<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
</li>
</ul>
<h3 id="6-自定义类加载器"><a href="#6-自定义类加载器" class="headerlink" title="6. 自定义类加载器"></a>6. 自定义类加载器</h3><ul>
<li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输<br>Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classData = loadClassData(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.ym.jvm.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意<ul>
<li>这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的.</li>
<li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式.</li>
<li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载.</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/11/JVM-一-内存结构/">
      JVM(一)内存结构
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-11</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1562826662961.jpg" alt="jvm内存结构"></p>
<p>​    JVM内存结构主要有三大块:<strong>堆内存</strong>,<strong>方法区</strong>和<strong>栈</strong></p>
<p>​    <strong>堆内存</strong>是JVM内存中最大的一块区域,由年轻代和老年代组成,而年轻代由可分为三部分,EdenSpace,FromSpace,ToSpace,默认情况下三者比例为8:1:1的比例.</p>
<p>​    <strong>方法区</strong>存储类信息,常量,静态变量等数据,是线程共享的区域.</p>
<p>​    <strong>栈</strong>又可以分为java虚拟机栈和本地方法栈主要用于方法的执行</p>
<h3 id="2-JVM内存区域分配"><a href="#2-JVM内存区域分配" class="headerlink" title="2.JVM内存区域分配"></a>2.JVM内存区域分配</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1562827418260.jpg" alt="jvm内存分配"></p>
<ul>
<li>图中控制参数说明<ul>
<li>-Xmx:设置堆内存的最大值</li>
<li>-Xms:设置堆内存的最小值</li>
<li>-XX:MaxNewSize:设置新生代内存的最大值</li>
<li>-XX:NewSize:设置新生代内存的最小值</li>
<li>-XX:MaxPermSize:设置永久代内存的最大值</li>
<li>-XX:PermSize:设置永久代内存的最小值</li>
<li>-Xss:设置每个线程的堆栈大小</li>
</ul>
</li>
</ul>
<h3 id="3-JVM与系统之间调用关系"><a href="#3-JVM与系统之间调用关系" class="headerlink" title="3. JVM与系统之间调用关系"></a>3. JVM与系统之间调用关系</h3><p><img src="/2019/07/11/JVM-一-内存结构/JVM%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1562828203417.jpg" alt="JVM与系统调用"></p>
<ul>
<li>方法区,堆属于所有线程间所共享的,而栈,程序计数器是属于线程私有的.</li>
<li><strong>java堆</strong><ul>
<li>对于大多数应用来说,java堆是java虚拟机所管理的内存中最大的一块,java堆是所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.</li>
<li>java堆时垃圾收集器管理的主要区域,因此很多时候也被称之为”<strong>GC堆</strong>“.</li>
<li>java堆可以位于物理上不连续的内存空间中,只要逻辑上时连续的即可</li>
<li>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出<strong>OutOfMemoryError</strong>异常.</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>与java堆一样,是各个线程间共享的内存区域,它主要用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</li>
<li>方法区与java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾回收.(垃圾回收在方法区出现的频率很小)</li>
<li>当方法区无法满足内存分配需求时,将抛出<strong>OutOfMemoryError</strong>异常.</li>
<li>方法区的执行都是随着线程的,原始类型的本地变量以及引用都存放在线程栈中,而引用关联的对象,都存在堆中.</li>
</ul>
</li>
<li><strong>程序计数器</strong><ul>
<li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码的信号指示器,在虚拟机的概念模型中字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</li>
<li>由于java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器只会执行一条独立的程序计数器,各条线程之间的1计数器互不影响,独立存储,我们称这种内存区域为”线程私有”的内存.</li>
<li>如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址,如果正在执行的是Natvie方法,这个计数器值则为空.</li>
</ul>
</li>
<li><strong>JVM栈</strong><ul>
<li>同程序计数器,java虚拟机栈也是线程私有的,<strong>它的生命周期与线程一样,虚拟机描述的是java方法执行的内存模型</strong>,每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表,朝左栈,动态链接,方法出口等信息.<strong>每一个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机中从入栈到出栈的过程.</strong></li>
<li>局部变量表存放了编译器可知的各种基本类型数据类型,对象引用(reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</li>
<li>在java虚拟机规范中,对这个区域规定了两种异常状况,如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<strong>StackOverFlowError</strong>异常,如果虚拟机可以动态的扩展,当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常.</li>
</ul>
</li>
<li><strong>本地方法栈</strong><ul>
<li>本地方法栈与虚拟机栈所发挥的作用时非常相似的,区别不过时虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务,虚拟机规范中对本地方法栈中的方法使用的语言,使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由的实现它.</li>
<li>与虚拟机栈一样,本地方法栈区域也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常</li>
</ul>
</li>
</ul>
<h3 id="4-使用JConsole查看java的相关信息"><a href="#4-使用JConsole查看java的相关信息" class="headerlink" title="4. 使用JConsole查看java的相关信息."></a>4. 使用JConsole查看java的相关信息.</h3><ul>
<li><p>找到%JAVA_HOME%\bin目录<img src="/2019/07/11/JVM-一-内存结构/javahome.png" alt="javahome"></p>
</li>
<li><p>执行cmd,输入jconsole命令,将会打开JConsole面板.<img src="/2019/07/11/JVM-一-内存结构/Jconsole.png" alt="Jconsole"></p>
</li>
<li><p>选择你要查看的进程点击连接,成功后如下.<img src="/2019/07/11/JVM-一-内存结构/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="控制面板"></p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        <div class="prev-next">
          
          <p class="current">
            1 / 2
          </p>
          
            <a class="next" rel="next" href="/page/2/">
              <section class="post next">
                &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
              </section>
            </a>
          
        </div>
      </div>

    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@xaoxuu.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/xaoxuu"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=63035382"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="/blog/archives/" href="/blog/archives/"
          
            rel="nofollow"
          
          
          id="blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="/projects/" href="/projects/"
          
          
          id="projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="/friends/" href="/friends/"
          
            rel="nofollow"
          
          
          id="friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/material-x/" href="https://xaoxuu.com/wiki/material-x/"
          
            rel="nofollow"
          
          
          id="https:xaoxuu.comwikimaterial-x">
          
            <i class="fas fa-book fa-fw" aria-hidden="true"></i>
          
          主题文档
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(15)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/jvm/" style="font-size: 20.67px; color: #6c6c6c">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 17.33px; color: #828282">多线程</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 14px; color: #999">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.7">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:me@xaoxuu.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/xaoxuu"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=63035382"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Yan</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/6d/a0c9e6f9efad8b731cb7376504bd10d79d2053.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>

</body>
</html>
