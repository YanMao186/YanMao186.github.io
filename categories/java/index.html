<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Category: java | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十八章/">
      java编程思想第十八章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h2><h3>对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</h3>

<ul>
<li><strong>Java 1.0</strong>版本以来，<strong>Java</strong>的<strong>I/O</strong>类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于<strong>Unicode</strong>的类。在<strong>JDK 1.4</strong>中，添加了<strong>nio</strong>类(对于“新<strong>I/O</strong>”来说，这是一个从现在起我们将要使用若干年的名称，即使它们在<strong>JDK 1.4</strong>中就已经被引入了，因此它们已经“旧”了)添加进来是为了改进性能及功能。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul>
<li><strong>File</strong>(文件)类这个名字具有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。==它既能代表一个特定文件的名称，有能代表一个目录下的一组文件的名称==。如果它指的是一个文件集，我们就可以对此集合调用<strong>list()</strong>方法，这个方法会返回一个字符数组。</li>
</ul>
<h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><ul>
<li><p>假设查看一个目录列表，可以用两种方法来使用<strong>File</strong>对象。如果调用不带参数的<strong>list()</strong>方法，便可以获得此<strong>File</strong>对象包含的全部列表。但是，如果我们想要获得一个受限列表，如：想得到所有拓展名为<strong>.java</strong>的文件，那么就需要使用“<strong>目录过滤器</strong>”，这个类会告诉我们怎么显示符合条件的<strong>File</strong>对象。</p>
</li>
<li><p>通过使用<strong>java.utils.sort()</strong>和<strong>String.CASE_INSENSITIVE.ORDERComparator</strong>，可以很容易的对结果进行排序(按字母顺序)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">            Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DirFilter</strong>这个类存在的唯一原因就是<strong>accept()</strong>方法。创建这个类的目的在于把<strong>accept()</strong>方法提供给<strong>list()</strong>使用，使<strong>list()</strong>可以回调<strong>accept()</strong>，进而以决定哪些文件包含在列表中。因此，这种结构也常常被称为==回调==。更具体的说，这是一个==策略模式==。==策略的目的就是提供了代码行为的灵活性==。</p>
</li>
<li><p><strong>accept()</strong>方法必须接受一个代表某个特定文件所在目录的<strong>File</strong>对象，以及包含那个文件的一个<strong>String</strong>。注意：==<strong>list()</strong>方法会为此目录对象下的每个文件名调用<strong>accept()</strong>,来判断该文件是否包含在内；判断结果由<strong>accept()</strong>返回的布尔值决定。==</p>
</li>
</ul>
<h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><ul>
<li><strong>File</strong>类不仅仅只代表存在的文件或目录。也可以用<strong>File</strong>对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，检查某个<strong>File</strong>对象代表的是一个文件还是一个目录，并可以删除文件。</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><strong>I/O</strong>库中常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。“流”屏蔽了实际的<strong>I/O</strong>设备中处理数据的细节。</li>
<li><strong>Java</strong>类库中的<strong>I/O</strong>类分成==输入和输出==两部分。通过==继承==，任何自<strong>InputStream</strong>或<strong>Reader</strong>派生而来的类都含有名为<strong>read()</strong>的基本方法，==用于读取单个字节或者字节数组==。同样，任何自<strong>OutputStream</strong>或<strong>Writer</strong>派生而来的类都含有名为<strong>write()</strong>的基本方法，==用于写单个字节或者字节数组==。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个流对象来提供所期望的功能(这是装饰器设计模式)。</li>
<li>实际上。<strong>Java</strong>中的“<strong>流</strong>”类库让人迷惑的主要原因就在于：==创建单一的结果流，却需要创建多个对象==。</li>
<li>在<strong>Java 1.0</strong>中，类库的设计者首先限定与<strong>输入</strong>有关的所有类都应该从<strong>InputStream</strong>继承,而<strong>输出</strong>有关的所有类都应该从<strong>OutputStream</strong>继承。</li>
</ul>
<h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul>
<li><strong>InputStream</strong>的作用是用来表示那些从不同数据源产生输入的类。包括：<ol>
<li>字节数组。</li>
<li><strong>String</strong>对象。</li>
<li>文件。</li>
<li>“管道”，工作方式与实际管道类似，即，从一端输入，从另一端输出。</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集和并到一个流内。</li>
<li>其他数据源，如<strong>Internet</strong>连接等。</li>
</ol>
</li>
<li>每一种数据源都有相应的<strong>InputStream</strong>子类。另外，<strong>FileInputStream</strong>也属于一种<strong>InputStream</strong>，为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayInputStream</strong></td>
<td>允许将内存的缓冲区当作<strong>InputStrem</strong>使用</td>
<td>缓冲区，字节将从中取出<br>          作为一种数据源：将其与<strong>FileterInputStream</strong>对象相连以提供有用接口</td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong></td>
<td>将<strong>String</strong>转换为<strong>InputStream</strong></td>
<td>字符串。底层实现实际使用<strong>StringBuffer</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td>用于从文件中读取信息</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象1相连以提供有用接口</td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td>产生用于写入相关<strong>PipedOutputStream</strong>的数据。实现“管道化”概念</td>
<td><strong>PipedOutputStream</strong><br>          作为多线程中的数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
<td>将两个或多个<strong>InputStream</strong>对象转换成单一<strong>InputStream</strong></td>
<td>两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<strong>Enumeration</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterInputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中“装饰器”为其他类的<strong>InputStream</strong>类提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><ul>
<li>该类型的类决定了输出所要去往的目标：字节数组，文件或管道。</li>
<li><strong>FilterOutputStream</strong>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td>
<td>缓冲区大小(可选的)<br>          用于指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td>用于将信息写至文件。</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td>任何写入其中的信息都会自动作为相关<strong>PipedInputStream</strong>的输出。实现“管道化”概念</td>
<td><strong>PipedInputStream</strong>          <br>指定用于多线程的数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中，“装饰器”为其他<strong>OutputStream</strong>提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><ul>
<li><strong>Java I/O</strong>类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是<strong>Java I/O</strong>类库里存在<strong>filter</strong>(过滤器)类的原因所在抽象类<strong>filter</strong>是所有装饰器的基类。</li>
<li>==装饰器必须具有和它所装饰的对象相同的接口==，但它也可以扩展接口，这种情况只发生在个别<strong>filter</strong>类中。</li>
<li>装饰器的==缺点==：在编写程序时，==增加了代码的复杂性==。<strong>Java I/O</strong>类库操作不便的原因在于：我们必须创建许多类—“核心” <strong>I/O</strong>类型加上所有的装饰器，才能得到我们所希望的单个<strong>I/O</strong>对象。</li>
<li><strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>是用来提供装饰器类接口以控制特定输入流(<strong>InputStream</strong>)和输出流(<strong>OutputStream</strong>)的两个类。<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>分别自<strong>I/O</strong>类库中的基类<strong>InputStream</strong>和<strong>OutputStream</strong>派生而来，这两个类是装饰器的必要条件。</li>
</ul>
<h4 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a>通过FilterInputStream从InputStream读取数据</h4><ul>
<li><strong>FilterInputStream</strong>类能够完成两件完全不同的事情。<ol>
<li><strong>DataInputStream</strong>允许我们读取不同的基本类型数据以及<strong>String</strong>对象(所有的方法都以“<strong>read</strong>”开头，如：<strong>readByte()</strong>,<strong>readFloat()</strong>等等)。搭配相应的<strong>DataOutputStream</strong>,就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</li>
<li>其他<strong>FilterInputStream</strong>类则在内部修改<strong>InputStream</strong>的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。</li>
</ol>
</li>
<li>我们几乎每次都要对输入进行缓冲—–不管我们正在连接的是什么<strong>I/O</strong>设备，所以，<strong>I/O</strong>类库把无缓冲输入(而不是缓冲输入)作为特殊情况(或只是方法调用)就显得更加合理了。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataInputStream</strong></td>
<td>与<strong>DataOutputStream</strong>搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)。</td>
<td><strong>InputStream</strong><br>包含用于读取基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td>使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。</td>
<td><strong>InputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong></td>
<td>跟踪输入流中的行号；可调用<strong>getLineNumber()</strong>和<strong>setLineNumber(int)</strong>。</td>
<td><strong>InputStream</strong><br>仅增加了行号，因此可能要与接口对象搭配使用。</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td>具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退。</td>
<td><strong>InputStream</strong><br>通常作为编译器的扫面器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td>
</tr>
</tbody></table>
<h4 id="通过FilterOutPutStream向OutputStream写入"><a href="#通过FilterOutPutStream向OutputStream写入" class="headerlink" title="通过FilterOutPutStream向OutputStream写入"></a>通过FilterOutPutStream向OutputStream写入</h4><ul>
<li>与<strong>DataInputStream</strong>对应的是<strong>DataOutputStream</strong>，它可以将各种<strong>基本数据类型</strong>以及<strong>String</strong>对象格式化输出到“流”中；这样，任何设备上的任何<strong>DataInputStream</strong>都能够读取它们。所有的方法都以”<strong>wirte</strong>“开头，如<strong>writeByte()</strong>,<strong>writeFloat()</strong>等等。</li>
<li><strong>PrintStream</strong>最初目的便是为了以可视化格式打印所有的<strong>基本数据类型</strong>以及<strong>String</strong>对象。这和<strong>DataOutputStream</strong>不同，后者的目的是将数据元素置入“流”中，使<strong>DataInputStream</strong>能够可移植地重构它们。</li>
<li><strong>PrintStream</strong>可能会有些问题，因为它捕捉了所有的<strong>IOException</strong>(因此，我们必需使用<strong>checkError()</strong>自行测试错误状态，如果出现错误它返回<strong>true</strong>)。另外，<strong>PrintStream</strong>也未完全国际化，不能以平台无关地方式处理换行动作(这些问题在<strong>printWriter</strong>中得到了解决)。</li>
<li><strong>BufferedOutputStream</strong>是一个修改过的<strong>OutputStream</strong>，<strong>它对数据流使用缓冲技术</strong>；因此当每次向流写入时，不必每次都进行实际的物理写操作。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
<td>与<strong>DataInputStream</strong>搭配使用，因此可以按照可移植方式向流中写入基本类型数据(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)</td>
<td><strong>OutputStream</strong><br>包含用于写入基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td>用于产生格式化输出。其中<strong>DataOutputStream</strong>处理数据的存储，<strong>PrintStream</strong>处理显示。</td>
<td><strong>OutputStream</strong>,可以用<strong>boolean</strong>值指示是否在每次换行时清空缓冲区(可选的)应该是对<strong>OutputStream</strong>对象的“<strong>final</strong>”封装。</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td>使用它以避免每次发送数据时都要进行实际的写操作。代表“使用缓冲区”。可以调用<strong>flush()</strong>清空缓冲区。</td>
<td><strong>OutputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
</tbody></table>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul>
<li><strong>Java 1.1</strong>对基本的<strong>I/O</strong>流类库进行了重大的修改。<strong>InputStream</strong>和<strong>OutputStream</strong>在以面向==字节==形式的<strong>I/O</strong>中提供极有价值的功能，<strong>Reader</strong>和<strong>Writer</strong>则提供兼容<strong>Unicode</strong>与面向==字符==的<strong>I/O</strong>功能。</li>
<li>有时我们必须把来自“<strong>字节</strong>”层次结构中的类和“<strong>字符</strong>”层次结构中的类结合起来使用。为了实现这个目的，要用到”<strong>适配器</strong>“(adapter)类：<strong>InputStreamReader</strong>可以把<strong>InputStream</strong>转换为<strong>Reader</strong>，而<strong>OutputStreamWriter</strong>可以把<strong>OutputStream</strong>转换为<strong>Writer</strong>。</li>
<li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的<strong>I/O</strong>流继承层次结构仅支持<strong>8位字节流</strong>，并且不能很好地处理<strong>16位的Unicode字符</strong>。由于<strong>Unicode</strong>用于<strong>字符国际化</strong>(<strong>Java</strong>本身的<strong>char</strong>也是16位的<strong>Unicode</strong>)，所以添加<strong>Reader</strong>和<strong>Writer</strong>继承层次结构就是为了在所有的<strong>I/O</strong>操作中都支持<strong>Unicode</strong>。</li>
</ul>
<h4 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h4><ul>
<li>在某些场合中，==面向字节==的<strong>InputStream</strong>和<strong>OutputStream</strong>才是正确的解决方案；特别是，<strong>java.util.zip</strong>类库就是==面向字节的而不是面向字符==的。因此，最明智的做法就是尽量尝试使用<strong>Reader</strong>和<strong>Writer</strong>，一旦程序代码无法成功编译，我们就会发现自己==不得不使用面向字节==的类库。</li>
<li>下面展示了在两个继承层次结构中，信息的来源和去处(即数据物理上来自哪里及去向哪里)之间的关系：</li>
</ul>
<table>
<thead>
<tr>
<th>来源与去处：Java 1.0类</th>
<th>相应的Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong><br>适配器：<strong>InputStreamReader</strong></td>
</tr>
<tr>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong><br>适配器：<strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td><strong>FileReader</strong></td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileWriter</strong></td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong>(已弃用)</td>
<td><strong>StringReader</strong></td>
</tr>
<tr>
<td>无</td>
<td><strong>StringWriter</strong></td>
</tr>
<tr>
<td><strong>ByteArrayInputStream</strong></td>
<td><strong>CharArrayReader</strong></td>
</tr>
<tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td><strong>CharArrayWriter</strong></td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td><strong>PipedReader</strong></td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td><strong>PipedWriter</strong></td>
</tr>
</tbody></table>
<h4 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h4><ul>
<li>对于<strong>InputStream</strong>和<strong>OutputStream</strong>来说，我们会使用<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>的装饰器子类来修改“<strong>流</strong>”以满足特殊需要。<strong>Reader</strong>和<strong>Writer</strong>的类继承层次结构继续沿用相同的思想，但是并不完全相同。</li>
</ul>
<table>
<thead>
<tr>
<th>过滤器 Java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FilterInputStream</strong></td>
<td><strong>FilterReader</strong></td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td><strong>FilterWriter</strong>(抽象类，没有子类)</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedReader</strong>(也有<strong>readLine()</strong>)</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td><strong>DataInputStream</strong></td>
<td>使用<strong>DataInputStream</strong>(除了当需要使用<strong>readLine()</strong>时以外，这时应该使用<strong>BufferedReader</strong>)</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td><strong>PrintWriter</strong></td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong>(已弃用)</td>
<td><strong>LineNumberReader</strong></td>
</tr>
<tr>
<td><strong>StreamTokenizer</strong></td>
<td><strong>StreamTokenizer</strong>(使用接受<strong>Reader</strong>的构造器)</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td><strong>PushbackReader</strong></td>
</tr>
</tbody></table>
<ul>
<li>无论我们何时使用<strong>readLine()</strong>,都不应该使用<strong>DataInputStream</strong>(这会遭到编译器的强烈反对)，而应该使用<strong>BufferedReader</strong>。除这一点，<strong>DataInputStream</strong>仍然是<strong>I/O</strong>类库的首选。</li>
<li><strong>PrintWriter</strong>提供了一个既能接受<strong>Writer</strong>对象又能接受任何<strong>OutputStream</strong>对象的构造器。<strong>PrintWriter</strong>的格式化接口实际上与<strong>PrintStream</strong>相同。</li>
<li>有一种<strong>PrintWriter</strong>构造器还有一个选项，就是“<strong>自动执行清空</strong>”选项。如果构造器设置此选项，则每个<strong>Println()</strong>执行之后，便会自动清空。</li>
</ul>
<h4 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h4><table>
<thead>
<tr>
<th>以下这些Java 1.0类在Java 1.1中没有相应类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
</tr>
<tr>
<td><strong>File</strong></td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>DataOutputStream</strong>，在使用时没有任何变化；因此如果想以“可传输的”格式存储和检索数据，可以使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构。</li>
</ul>
<h3 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h3><ul>
<li><strong>RandomAccessFile</strong>适用于由大小已知的记录组成的文件，所以我们可以使用<strong>seek()</strong>将记录从一处转移到另一处，然后读取或者修改记录。</li>
<li>除了实现了<strong>DataInput</strong>和<strong>DataOutput</strong>接口之外，它和这两个继承层次结构没有任何关联。甚至不适用<strong>InputStream</strong>和<strong>OutputStream</strong>类中已有的任何功能。它是一个完全独立的类，这么做是因为<strong>RandomAccessFile</strong>拥有和别的<strong>I/O</strong>类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。</li>
<li>只有RandomAccessFile支持搜寻方法，并且只适用于文件。</li>
</ul>
<h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I/O流的典型使用方式"></a>I/O流的典型使用方式</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul>
<li><p>如果想要打开一个文件用于字符输入，可以使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputReader</strong>。为了提高速度，我们希望对那个文件进行缓冲，那么将所产生的引用传给一个<strong>BufferedReader</strong>构造器。由于<strong>BufferedReader</strong>也提供了<strong>readLine()</strong>方法，所以这是我们的最终对象和进行读取的接口。当<strong>readLine()</strong>将返回<strong>null</strong>时，你就达到了文件的末尾。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串<strong>sb</strong>用来累计文件的全部内容(包括必须添加的换行符，因为<strong>readLine()</strong>已将它们删掉)。最后，调用<strong>close()</strong>关闭文件。</p>
</li>
</ul>
<h4 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h4><ul>
<li><p>下面，从<strong>BufferedInputFile.read()</strong>读入的<strong>String</strong>结果被用来创建一个<strong>StringReader</strong>。然后调用<strong>read()</strong>每次读取一个字符，并把它发送到控制台。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = sr.read())!= -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read()</strong>是以<strong>int</strong>形式返回下一字节，因此必须类型转型为<strong>char</strong>才能正确打印。</p>
</li>
</ul>
<h4 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h4><ul>
<li><p>要读取格式化数据，可以使用<strong>DataInputStream</strong>,它是一个面向字节的<strong>I/O</strong>类(不是面向字符的)。因此我们必须使用<strong>InputStream</strong>类而不是<strong>Reader</strong>类。当然，可以用<strong>InputStream</strong>以字节的形式读取任何数据(如一个文件)，不过，这里使用的是字符串。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile</span><br><span class="line">                                    .read(<span class="string">"D://HelloWorld.java"</span>)</span><br><span class="line">                                    .getBytes()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>必须为<strong>ByteArrayInputStream</strong>提供字节数组，为了产生该数组<strong>String</strong>包含了一个可以实现此项工作的<strong>getBytes()</strong>方法。所产生的<strong>ByteArrayInputStream</strong>是一个适合传递给<strong>DataInputStream</strong>的<strong>InputStream</strong>。</p>
</li>
<li><p>如果我们从<strong>DataInputStream</strong>用<strong>readByte()</strong>一次一个字节读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束。相反，我们可以使用<strong>available()</strong>方法查看还有多少可供存储的字符。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesrEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul>
<li><p>FileWriter对象可以向文件写入数据。创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出(尝试移除此包装来感受对性能的影响——缓冲往往能显著地增加I/O操作地性能)。下面，为了提供格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可作为普通文本文件读取。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://HelloWorld.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            out.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">2: 	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">3: 	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">4: 	&#125;</span></span><br><span class="line"><span class="comment">5: &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦读完输入数据流，<strong>readLine()</strong>会返回<strong>null</strong>。我们可以看到要为<strong>out</strong>显示调用<strong>close()</strong>。如果我们不为所有的输出文件调用<strong>close()</strong>,就会发现缓冲区内容不会被刷新清空，那么它们就不完整。</p>
</li>
</ul>
<h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><ul>
<li><p><strong>PrintWriter</strong>可以对数据进行格式化，以便人们阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用<strong>DataOutputStream</strong>写入数据，并用<strong>DataInputStream</strong>恢复数据。当然，这些流可以是任意形式。注意：<strong>DataOutputStream</strong>和<strong>DataInputStream</strong>是==面向字节==的，因此要使用<strong>InputStream</strong>和<strong>OutputStream</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">That was pi</span></span><br><span class="line"><span class="comment">1.41413</span></span><br><span class="line"><span class="comment">Square root of 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>DataOutputStream</strong>写入数据，<strong>Java</strong>保证我们可以使用<strong>DataInputStream</strong>准确地读取数据—无论读和写数据的平台多么不同。</p>
</li>
<li><p>当使用<strong>DataOutputStream</strong>时，写字符串并且让<strong>DataInputStream</strong>能够恢复它的==唯一可靠==的做法就是使用<strong>UTF-8</strong>编码，在示例中是用<strong>writeUTF()</strong>和<strong>readUTF()</strong>实现的。</p>
</li>
<li><p><strong>writeDouble()</strong>将<strong>double</strong>类型的数字存储到流中，并用相应的<strong>readDouble()</strong>恢复它(对于其他的数据类型，也有类似方法用于读写)。</p>
</li>
</ul>
<h4 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h4><ul>
<li><p>使用<strong>RandomAccessFile</strong>，类似于组合使用了<strong>DataInputStream</strong>和<strong>DataOutputStream</strong>(因为它实现了相同的接口：<strong>DataInput</strong>和<strong>DataOutput</strong>)。另外，利用<strong>seek()</strong>可以在文件中到处移动，并修改文件中的某个值。</p>
</li>
<li><p>使用<strong>RandomAccessFile</strong>时，你必须知道文件排版，这样才能正确使用它。<strong>RandomAccessFile</strong>拥有读取基本类型和<strong>UTF-8</strong>字符串的各种方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">" "</span>+rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">            rf.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">            rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">            rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 7.069999999999999</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 47.001</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>display()</strong>方法打开了一个文件，并以<strong>double</strong>值的形式显示了其中的七个元素。在<strong>main()</strong>中，首先创建了文件，然后打开并修改它。因为<strong>double</strong>总是8字节长，所以为了用<strong>seek()</strong>查找第5个双精度值，你只需用5*8来产生查找位置。</p>
</li>
</ul>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul>
<li>程序的<strong>所有输入</strong>都可以来自于<strong>标准输入</strong>，它的<strong>所有输出</strong>也都可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送到<strong>标准错误</strong>。<strong>标准I/O</strong>的意义在于：我们可以很容易地把程序串联起来，一个程序的<strong>标准输出</strong>可以成为另一个程序的<strong>标准输入</strong>。</li>
</ul>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul>
<li><p>按照标准<strong>I/O</strong>模型，<strong>Java</strong>提供了<strong>System.in</strong>,<strong>System.out</strong>,<strong>System.err</strong>。其中<strong>System.out</strong>已经事先被包装成了<strong>printStream</strong>对象。<strong>System.err</strong>同样也是<strong>PrintStream</strong>，但是<strong>System.in</strong>却是一个没有被包装过的未经加工的<strong>InputStream</strong>。这意味着尽管我们可以立即使用<strong>System.out</strong>和<strong>System.err</strong>，但是在读取<strong>System.in</strong>之前必须对其进行包装。</p>
</li>
<li><p>通常我们会用<strong>readLine()</strong>一次一行地读取输入，我们可以将<strong>System.in</strong>包装成<strong>BufferedReader</strong>来使用这要求我们必须用<strong>InputStreamReader</strong>把<strong>System.in</strong>转换成<strong>Reader</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><ul>
<li><p><strong>System.out</strong>是一个<strong>PrintStream</strong>，而<strong>PrintStream</strong>是一个<strong>OutputStream</strong>。<strong>PrintWriter</strong>有一个可以接受<strong>OutputStream</strong>作为参数的构造器。所以，只要需要，就可以使用那个构造器把<strong>System.out</strong>转换成<strong>PrintWriter</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将第二个参数设为<strong>true</strong>，以便开启自动清空功能；否则，有可能看不到输出。</p>
</li>
</ul>
<h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><ul>
<li><p><strong>System</strong>类提供了一些简单的静态方法调用，以允许我们对标准输入，输出和错误<strong>I/O</strong>流进行<strong>重定向</strong>：</p>
<ul>
<li><strong>setIn(InputStream)</strong></li>
<li><strong>setOut(PrintStream)</strong></li>
<li><strong>setErr(PrintStream)</strong></li>
</ul>
</li>
<li><p>如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"D://test.txt"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>I/O</strong>重定向操纵的是<strong>字节流</strong>，而不是字符流；因此我们使用的是<strong>InputStream</strong>和<strong>OutputStream</strong>，而不是<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
</ul>
<h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><ul>
<li><p><strong>JDK 1.4</strong>的<strong>java.nio.*</strong>包中引入了新的<strong>Java I/O</strong>类库，其目的在于<strong>提高速度</strong>。速度的提高在<strong>文件I/O</strong>和<strong>网络I/O</strong>中都有可能发生。</p>
</li>
<li><p>速度的提高来自所使用的结构更接近于操作系统执行<strong>I/O</strong>的方式：<strong>通道和缓冲器</strong>。</p>
</li>
<li><p>唯一直接与通道交互的缓冲器是<strong>ByteBuffer</strong>—也就是说，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<strong>ByteBuffer</strong>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但却正好，因为这是大多数操作系统中更有效的映射方式。</p>
</li>
<li><p>旧<strong>I/O</strong>类库中有三个类被修改了，用以产生<strong>FileChannel</strong>。分别是<strong>FileInputStream</strong>,<strong>FileOutputStream</strong>以及用于<strong>既读又写</strong>的<strong>RandomAccessFile</strong>。注意这些是<strong>字节操作流</strong>，与低层的<strong>nio</strong>性质一致。<strong>Reader</strong>和<strong>Writer</strong>这种<strong>字符模式类</strong>不能用于产生通道；但是<strong>java.nio.channels.Channels</strong>类提供了实用方法，用以在通道中产生<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
<li><p>下面演示上面的三种类型的流，用于产生<strong>可写</strong>的，<strong>可读可写</strong>的及<strong>可读</strong>的通道。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span> (buff.hasRemaining())</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buff.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Some text Some more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getChannel()</strong>将会产生一个<strong>FileChannel</strong>。通道是一种相当基础的东西：可以向它传送用于读写的<strong>ByteBuffer</strong>，并且可以锁定文件的某些区域用于独占式访问。</p>
</li>
<li><p>将字节存放于<strong>ByteBufferr</strong>的方法之一是：使用一种“<strong>put</strong>”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<strong>warp()</strong>方法将已存在的字节数组“包装”到<strong>ByteBuffer</strong>中。一旦如此，就不再复制底层的数组，而是把它作为所产生的<strong>ByteBuffer</strong>的存储器，我们称之为数组支持的<strong>ByteBuffer</strong>。</p>
</li>
<li><p>对于只读访问，我们必须显式地使用静态的<strong>allocate()</strong>方法来分配<strong>ByteBuffer</strong>。<strong>nio</strong>的目标就是快速移动大量数据，因此<strong>ByteBuffer</strong>的大小就显得尤为重要。</p>
</li>
<li><p>甚至达到更高的速度也有可能，方法就是使用<strong>allocateDirect()</strong>而不是<strong>allocate()</strong>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p>
</li>
<li><p>一旦调用<strong>read()</strong>来告知<strong>FileChannel</strong>向<strong>ByteBuffer</strong>存储字节，就必须调用缓冲器上的<strong>fip()</strong>，让它做好让别人读取字节的准备。</p>
</li>
<li><p>如果打算使用缓冲器执行进一步的<strong>read()</strong>操作，我们也必须得调用<strong>clear()</strong>来为每个<strong>read()</strong>做好准备。如下面这个简单文件复制程序。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，打开一个<strong>FileChannel</strong>用于读，而打开另一个以用于写。<strong>ByteBuffer</strong>被分配了空间，当<strong>FileChannel.read()</strong>返回<strong>-1</strong>时，表示我们已经到达了输入的末尾。每次<strong>read()</strong>操作之后，就会将数据输入到缓冲器中，<strong>filp()</strong>则是准备缓冲器以便它的信息可以由<strong>write()</strong>提取。<strong>write()</strong>操作之后，信息仍在缓冲器中，接着<strong>clear()</strong>操作则对所有的内部指针重新排序，以便缓冲器在另一个<strong>read()</strong>操作期间能够做好接受数据的准备。</p>
</li>
<li><p>上面的程序并不是处理此类操作的理想方式，特殊方法<strong>transferTo()</strong>和<strong>transferFrom()</strong>允许我们将一个通道和另一个通道直接相连。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><ul>
<li><p>尽管ByteBuffer只能保留字节类型的数据，但是它具有可以从其他所容纳的字节中产生出各种不同基本类型值的方法。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; bb.limit())</span><br><span class="line">            <span class="keyword">if</span> (bb.get() != <span class="number">0</span>)</span><br><span class="line">                System.out.print(<span class="string">"nonzero"</span>);</span><br><span class="line">        System.out.print(<span class="string">"i ="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"Howdy!"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = bb.getChar())!= <span class="number">0</span>)</span><br><span class="line">            System.out.print(c+<span class="string">" "</span>+<span class="string">"\b"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">        System.out.println(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getInt());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getLong());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getFloat());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getDouble());</span><br><span class="line">        bb.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i =1025Howdy!</span></span><br><span class="line"><span class="comment">12390</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">9.9471144E7</span></span><br><span class="line"><span class="comment">9.9471142E7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在分配一个<strong>ByteBuffer</strong>之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零，它的确是这样做的。这里一共检测了<strong>1024</strong>个值(由缓冲器的<strong>limit()</strong>决定)，并且所有的值都是<strong>0</strong>。</p>
</li>
<li><p>向<strong>ByteBuffer</strong>插入基本类型数据的最简单方式是：利用<strong>asCharBuffer(),asShortBuffer()</strong>等获得该缓冲器上的视图，然后使用视图的<strong>put()</strong>方法，使用<strong>ShortBuffer</strong>的<strong>put()</strong>方法时，需要进行类型转换。</p>
</li>
</ul>
<h4 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h4><ul>
<li><p>视图缓冲器(view buffer)可以让我们通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong>。<strong>ByteBuffer</strong>依然是实际存储数据的地方，“支持”着前面的视图。因此，对视图的修改都会映射成为对<strong>ByteBuffer</strong>中数据的修改。这使得我们可以很方便地向<strong>ByteBuffer</strong>插入数据。视图还允许我们从<strong>ByteBuffer</strong>一次一个地或者成批的读取基本类型值。下面，通过<strong>IntBuffer</strong>操纵<strong>ByteBuffer</strong>中的<strong>int</strong>型数值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">888</span>,<span class="number">345</span>,<span class="number">3456</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span> (ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">1811</span></span><br><span class="line"><span class="comment">888</span></span><br><span class="line"><span class="comment">345</span></span><br><span class="line"><span class="comment">3456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先用重载后的<strong>put()</strong>方法存储一个整数数组。接着<strong>get()</strong>和<strong>put()</strong>方法调用直接访问底层<strong>ByteBuffer</strong>中的某个整数位置。</p>
</li>
<li><p>一旦底层的<strong>ByteBuffer</strong>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型。</p>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p>Java I/O类库中的类支持读写压缩格式的数据流，这些类不是从Reader和Writer类派生而来的，而是属于InputStream和OutputStream继承层次结构的一部分。这是因为压缩类库是按字节方式而不是字符方式处理的。</p>
<table>
<thead>
<tr>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CheckedInputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>InputStream</strong>产生校验和(不仅是解压缩)</td>
</tr>
<tr>
<td><strong>CheckedOutputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>OutputStream</strong>产生校验和(不仅是压缩)</td>
</tr>
<tr>
<td><strong>DeflaterOutputStream</strong></td>
<td>压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipOutputStream</strong></td>
<td>一个<strong>DeflaterOutputStream</strong>，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td><strong>GZIPOutputStream</strong></td>
<td>一个个<strong>DeflaterOutputStream</strong>，用于将数据压缩成GZIP文件格式</td>
</tr>
<tr>
<td><strong>InflaterInputStream</strong></td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td><strong>GZIPInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩GZIP文件格式的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h4><ul>
<li><p>如果对单个数据流进行压缩，<strong>GZIP</strong>可能是一个比较适合的选择。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: \nGZIPcompress file\n"</span>+</span><br><span class="line">                    <span class="string">"\tUses GZIP comression to compress"</span> + <span class="string">"the file to test.gz"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"E://test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file"</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read())!= -<span class="number">1</span>)</span><br><span class="line">            out.write(c);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">"D://test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine())!= <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将输出流封装成<strong>GZIPOutputStream</strong>或<strong>ZipOutputStream</strong>，并将输入流封装成<strong>GZIPInputStream</strong>或<strong>ZipInputStream</strong>即可。</p>
</li>
</ul>
<h4 id="Java档案文件"><a href="#Java档案文件" class="headerlink" title="Java档案文件"></a>Java档案文件</h4><ul>
<li><p><strong>Zip</strong>格式也被应用于<strong>JAR</strong>(Java Archive,Java档案文件)文件格式中。这种格式就像<strong>Zip</strong>一样，可以将一组文件压缩到单个压缩文件中。</p>
</li>
<li><p>如果不采用<strong>JAR</strong>文件，<strong>Web</strong>浏览器在下载构成一个应用的所有文件时必须重复多次请求<strong>Web</strong>服务器；而且所有这些文件都是未经压缩的。如果将所有这些文件合并到一个<strong>JAR</strong>文件中，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，可以使传输时间更短。另外，处于安全考虑，<strong>JAR</strong>文件中的每个条目都可以加上数字化签名。</p>
</li>
<li><p><code>jar [options] destination [manifest] inputfile(s)</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>创建一个新的或空的压缩文档</td>
</tr>
<tr>
<td>t</td>
<td>列出目录表</td>
</tr>
<tr>
<td>x</td>
<td>解压所有文件</td>
</tr>
<tr>
<td>x file</td>
<td>解压该文件</td>
</tr>
<tr>
<td>f</td>
<td>意指：“我打算指定一个文件名。” 如果没有用这个选项，jar假设所有的输入都来自标准输入；或者在创建一个文件时，输出对象也假设为标准输出。</td>
</tr>
<tr>
<td>m</td>
<td>表示第一个参数将是用户自建的清单文件的名字</td>
</tr>
<tr>
<td>v</td>
<td>产生详细输出，描述jar所作的工作</td>
</tr>
<tr>
<td>O</td>
<td>只存储文件，不压缩文件(用来创建一个可放在类路径中的JAR文件)</td>
</tr>
<tr>
<td>M</td>
<td>不自动创建文件清单</td>
</tr>
</tbody></table>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul>
<li>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。</li>
<li><strong>Java</strong>的对象序列化将那些实现了<strong>Serializable</strong>接口的对象转换成了一个<strong>字节序列</strong>，并能在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。</li>
<li>序列化可以实现轻量级持久性。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久化的效果。</li>
<li>对象序列化主要是为了支持两种特性：<ol>
<li><strong>Java</strong>的<strong>远程方法调用(Remote Method Invocation,RMI)</strong>，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li>
<li>对<strong>Java Beans</strong>来说，对象的序列化也是必须的。使用<strong>Bean</strong>时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保留下来，并在程序启动时进行后期恢复；这种具体的工作就是由对象序列化完成的。</li>
</ol>
</li>
<li>要序列化一个对象，首先要创建某些<strong>OutputStream</strong>对象，然后将其封装在一个<strong>ObjectOutputStream</strong>对象内。这时，只需要调用<strong>writeObject()</strong>即可将对象序列化，并将其发送给<strong>OutputStream</strong>(对象化序列是基于字节的，因要使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构)。要反向进行该过程(即将一个序列化还原为一个对象)，需要将一个<strong>InputStream</strong>封装在<strong>ObjectInputStream</strong>内，然后调用<strong>readObject()</strong>。我们最后获得的是一个引用，它指向一个向上转型的<strong>Object</strong>，所以必须向下转型才能直接设置它们。</li>
</ul>
<h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><ul>
<li><p>我们将一个对象序列化，并通过网络将其作为文件传递给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个文件吗？</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    setter&amp;getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"D://X.file"</span>));</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://X.file"</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件和读取<strong>mystery</strong>对象的内容都需要<strong>User</strong>的<strong>Class</strong>对象；而<strong>Java</strong>虚拟机找不到<strong>User.class</strong>(除非它正好在类路径<strong>Classpath</strong>内)。这样就会得到一个<strong>ClassNotFoundException</strong>的异常。必须保证<strong>Java</strong>虚拟机能找到相关的<strong>.class</strong>文件。</p>
</li>
</ul>
<h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><ul>
<li>某些情况下你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</li>
<li>在这些特殊情况下，可通过实现<strong>Externalizable</strong>接口—–代替实现<strong>Serialzable</strong>接口—来对序列化进行控制。<strong>Externalizable</strong>接口继承了<strong>Serializable</strong>接口，同时还增加了两个方法：<strong>writeExternal()</strong>和<strong>readExternal()</strong>。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</li>
</ul>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><ul>
<li><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息，通常就会面临这种情况。即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式访问它。</p>
</li>
<li><p>如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个的关闭序列化。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"username = "</span>+username+<span class="string">"&amp;&amp;"</span>+<span class="string">"password = "</span>+password+<span class="string">"&amp;&amp;"</span>+<span class="string">"date"</span>+date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">"Tom"</span>,<span class="string">"11111111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span>+ a);</span><br><span class="line">        ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">                o.writeObject(a);</span><br><span class="line">                o.close();</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Recovering object at "</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        a = (Logon)in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span> + a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = 11111111&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">Recovering object at Sun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = null&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>date</strong>字段被存储到磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
</li>
<li><p>由于<strong>Externalizable</strong>对象在默认情况下不保存它们的任何字段，所以<strong>transient</strong>关键字只能和<strong>Serializable</strong>对象一起使用。</p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/I-O/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>I/O</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十七章/">
      java编程思想第十七章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h2><h3 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h3><p><img src="/2019/11/17/java编程思想第十七章/1572948167233-1573995500325.png" alt="1572948167233"></p>
<ul>
<li>Java SE5新添加了：<ul>
<li><strong>Queue</strong>接口(<strong>LinkedList</strong>已经为实现该接口做了修改及其实现<strong>PrioityQueue</strong>和各种风格的<strong>BlockingQueue</strong>)。</li>
<li><strong>ConcurrentMap</strong>接口及其实现<strong>ConcurrentHashMap</strong>(用于多线程机制)。</li>
<li><strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>,它们也是用与多线程机制。</li>
<li><strong>EnumSet</strong>和<strong>EnumMap</strong>，为使用<strong>enum</strong>而设计的<strong>Set</strong>和<strong>Map</strong>的特殊实现。</li>
<li>在<strong>Collections</strong>类中的的多个便利方法，虚线框表示<strong>abstract</strong>类，它们只是部分实现了特定接口的工具。如：你可以在创建自己的<strong>Set</strong>,那么并不用从<strong>Set</strong>接口开始并实现其中的全部方法，只需从<strong>AbstractSet</strong>继承，然后执行一些创建新类必须的工作。</li>
</ul>
</li>
</ul>
<h3 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h3><ul>
<li><p>容器的填充仍然像java.util.Arrays一样面临不足。就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill()。与Arrays版本一样，此fill()方法也是只是复制同一个对象引用来填充整个容器的，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StringAddress&#123;"</span> +</span><br><span class="line">                <span class="string">"s='"</span> + s + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>,<span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"World"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;]</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面展示了两种对单个对象引用来填充Collection的方式。</p>
<ul>
<li>第一种是使用<strong>Collections.nCopies()</strong>创建传递给构造器的<strong>List</strong>，此处填充的是<strong>ArrayList</strong>。</li>
<li>第二种是使用<strong>Collection.fill()</strong>,<strong>fill()</strong>方法的用处有限，因为它只能替换已经在<strong>List</strong>中存在的元素，而不能添加新元素。</li>
</ul>
</li>
</ul>
<h3 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends T&gt;)</td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true(可选的)移除容器中的所有元素(可选的)</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection&lt;?&gt;)</td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素时返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>，可以用来遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回true(可选的)</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素。只要有移除动作发生就返回true(可选的)</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素(应用集合论的“交集”概念)。只要Collection发生了改变就返回true(可选的)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中元素的数目</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素(可选)</td>
</tr>
</tbody></table>
<ul>
<li>其中不包括随机访问所选择元素的<strong>get()</strong>方法。因为<strong>Collection</strong>包括<strong>Set</strong>，而<strong>Set</strong>是自己维护内部顺序的。因此，如果想检查<strong>Collection</strong>中的元素，那就必须使用迭代器。</li>
</ul>
<h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><ul>
<li>执行各种不同的添加和移除的方法在<strong>Collection</strong>接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。</li>
<li>接口时面向对象设计中的契约，它声明“<strong>无论你选择如何实现该接口，我保证你可以向该接口发送这些消息</strong>”，但是可选操作违反了这个非常基本的原则，它声明调用某些方法将不会执行有意义的行为，相反，他会抛出异常。</li>
<li>如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。</li>
<li>为什么将方法定义为可选的？因为这样做可以防止在设计中出现==接口爆炸==的情况。容器类库中的其他设计看起来总是为了描述每个主题的各种变体，而最终患上了接口过剩症。甚至这么做仍不能捕捉接口的各种特例，因为总有人发明新的接口，“未获支持的操作”这种方式可以实现Java容器类库的一个重要目标：==容器应该易学易用==。未获支持的操作是一种特例，可以延迟到需要时再实现。但是为了让这种方式能工作。<ol>
<li><strong>UnsupportedOperationException</strong>必须是一种罕见事件，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。这种设计留下了一个“后门”，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么它仍旧适合现有的类库。</li>
<li>如果一个操作是未获支持的，那么在实现接口的时候可能就会导致<strong>UnsupportedOperationException</strong>异常。毕竟，它表示编程上有错误，使用了不正确的接口实现。</li>
</ol>
</li>
<li>未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。</li>
</ul>
<h4 id="未获支持的操作"><a href="#未获支持的操作" class="headerlink" title="未获支持的操作"></a>未获支持的操作</h4><ul>
<li><p>常见的未获支持的操作，都来源于背后由==固定尺寸的数据结构支持的容器==，当你用<strong>Arrays.asList()</strong>将数组转换为<strong>List</strong>时，就会得到这样的容器。还可以通过使用<strong>Collections</strong>类中的“不可修改”的方法，选择创建任何会抛出<strong>UnsupportedOperationException</strong>的容器(包括Map)。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---"</span>+msg+<span class="string">"---"</span>);</span><br><span class="line">        Collection&lt;String&gt; c = list;</span><br><span class="line">        Collection&lt;String&gt; subList = list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.retainAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"retainAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.removeAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"removeAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"clean()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.add(<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.addAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.remove(<span class="string">"C"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"remove()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(<span class="number">0</span>,<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A B C D E F G H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"Modifiable Copy"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"Arrays.asList()"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList()"</span>, Collections.unmodifiableList(</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;(list)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Modifiable Copy---</span></span><br><span class="line"><span class="comment">---Arrays.asList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">---unmodifiableList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">List.set()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arrays.asList()</strong>会生成一个<strong>List</strong>，它基于一个固定大小的数组，仅支持那些不会改变数组大小的操作，任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个<strong>UnsupportedOpreationException</strong>异常，以表示对未获支持操作的调用(一个编程错误)。</p>
</li>
<li><p>应该把<strong>Arrays.asList()</strong>的结果作为构造器的参数传递给任何<strong>Collection</strong>(或者使用<strong>addAll()</strong>方法，或<strong>Collections.addAll()</strong>静态方法)，这样可以生成允许使用所有的方法的普通容器，这样的调用会产生新的尺寸可调的底层数据结构。</p>
</li>
<li><p><strong>Collections</strong>类中的”不可修改”的方法将容器包装到了一个代理中，只要你执行任何试图修改容器的操作，这个代理都会产生<strong>UnsupportedOperationException</strong>异常，使用这些方法的目标就是产生”常量”容器对象。</p>
</li>
</ul>
<h3 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h3><ul>
<li><p>在<strong>Java</strong>中像<strong>Integer</strong>和<strong>String</strong>这样的<strong>Java</strong>预定义的类型，这些类型被设计为可以在容器内部使用。当你创建自己的类型时，要意识到<strong>Set</strong>需要一种方式来维护存储顺序，而存储顺序如何维护，则是在<strong>Set</strong>的不同实现之间会有所变化。因此，不同的<strong>Set</strong>实现不仅具有不同的行为，而且它们对于可以在特定的<strong>Set</strong>中放置的元素的类型也有不同的要求。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Set</strong>(interface)</td>
<td>存入<strong>Set</strong>的每个元素都必须是唯一的，因为<strong>Set</strong>不保存重复元素。加入<strong>Set</strong>的元素必须定义<strong>equals()</strong>方法以确保对象的唯一性。<strong>Set</strong>与<strong>Collection</strong>有完全一样的接口。<strong>Set</strong>接口不保证维护元素的次序。</td>
</tr>
<tr>
<td><strong>HashSet</strong>(项目中最常使用)</td>
<td>为快速查找而设计的<strong>Set</strong>。存入<strong>HashSet</strong>的元素必须定义<strong>hashCode()</strong></td>
</tr>
<tr>
<td><strong>TreeSet</strong></td>
<td>保持次序的<strong>Set</strong>，底层为树结构。使用它可以从<strong>Set</strong>中提取有序的序列。元素必须实现<strong>Comparable</strong>接口。</td>
</tr>
<tr>
<td><strong>LinkedHashSet</strong></td>
<td>具有<strong>HashSet</strong>的查询速度，且内部使用链表维护元素的顺序(插入的顺序)。于是在使用迭代器遍历<strong>Set</strong>时，结果会按元素的次序显示。元素也必须定义<strong>hashCode()</strong>方法。</td>
</tr>
</tbody></table>
</li>
<li><p>你必须为散列存储和树形存储都创建一个<strong>equals()</strong>方法，但是<strong>hashCode()</strong>只有在这个类将被置于<strong>HashSet</strong>或<strong>LinkedHashSet</strong>中时才是必需的。但是建议你应该在覆盖<strong>equals()</strong>方法时，总是同时覆盖<strong>hashCode()</strong>方法。</p>
</li>
<li><p>下面演示为了成功的使用特定的Set实现类而必须定义的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        i = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i == ((SetType)o).i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeType arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arg.i &lt; i ? -<span class="number">1</span> : (arg.i == i ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fill</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(</span><br><span class="line">                        type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="comment">[7, 7, 0, 8, 5, 9, 4, 1, 1, 3, 2, 3, 1, 9, 2, 8, 4, 6, 5, 4, 6, 8, 0, 3, 7, 5, 0, 6, 2, 9]</span></span><br><span class="line"><span class="comment">[2, 6, 1, 7, 1, 4, 0, 0, 9, 9, 9, 4, 7, 8, 0, 3, 8, 8, 7, 6, 3, 5, 5, 1, 6, 2, 2, 4, 3, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException: java.lang.ClassCastException: com.ym.ThinkingInJava.SetType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: com.ym.ThinkingInJava.HashType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了证明那些方法对于某种特定的<strong>Set</strong>是必需的，并且同时还要避免代码重复，我们创建了三个类，基类<strong>SetType</strong>只存储一个<strong>int</strong>，并且通过<strong>toString()</strong>方法产生它的值。因为所有在<strong>Set</strong>中存储的类都必须具有<strong>equals()</strong>方法，因此在基类中也有该方法。其等价性是基于这个<strong>int</strong>类型的<strong>i</strong>的值来确定的。</p>
</li>
<li><p><strong>HashType</strong>继承自<strong>SetType</strong>，并且添加了<strong>hashCode()</strong>方法，该方法对于放置到<strong>Set</strong>的散列实现中的对象来说是必需的。</p>
</li>
<li><p><strong>TreeType</strong>实现了<strong>Comparable</strong>接口，如果一个对象被用于任何种类的排序容器中，如<strong>SortedSet</strong>(<strong>TreeSet</strong>的其唯一实现)，那么它必须实现这个接口。注：==在<strong>compareTo()</strong>中，没有使用“简洁明了”的形式<strong>return i-i2,</strong>因为这是一个常见的编程错误，它只有在<strong>i</strong>和<strong>i2</strong>都是无符号的<strong>int</strong>(如果<strong>Java</strong>确实有<strong>unsigned</strong>关键字的话，但实际上并没有)时才能正确工作。对于<strong>Java</strong>的有符号<strong>int</strong>，他就会出错，因为<strong>int</strong>不够大，不足以表现两个有符号<strong>int</strong>的差。如：<strong>i</strong>是一个很大的正数，而j是很大的负整数，<strong>i-j</strong>就会溢出并且返回负值，这就不正确了==。</p>
</li>
<li><p><strong>fill()</strong>和<strong>test()</strong>方法都是使用泛型定义的，这是为了避免代码重复。</p>
</li>
<li><p><strong>HashSet</strong>以某种神秘的顺序保存所有的元素，<strong>LinkedhashSet</strong>按照元素插入的顺序保存元素，而<strong>TreeSet</strong>按照排序顺序维护元素(按照<strong>compareTo()</strong>的实现方式，这里维护的是降序)</p>
</li>
<li><p>对于没有重新定义<strong>hashCode()</strong>方法的<strong>SetType</strong>或<strong>TreeType</strong>，如果将它们放置到任何散列实现中都会产生重复值，这样就违反了Set的基本契约。</p>
</li>
<li><p>如果在<strong>TreeSet</strong>中使用没有实现<strong>Comparable</strong>的类型，那么你将会得到更确定的结果，在<strong>TreeSet</strong>试图将该对象当作<strong>Comparable</strong>使用时，将抛出一个异常。</p>
</li>
</ul>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><ul>
<li>SortedSet中的元素可以保证处于排序状态，这使得它可以通过在SortedSet接口中的下列方法提供附加的功能：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Set</strong>使用的<strong>Comparator</strong>;或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>Object first()</strong></td>
<td>返回容器中的第一个元素。</td>
</tr>
<tr>
<td><strong>Object last()</strong></td>
<td>返回容器中的最末一个元素</td>
</tr>
<tr>
<td><strong>SortedSet subSet(fromElement,toElement)</strong></td>
<td>生成此Set的子集，范围从<strong>fromElement</strong>(包含)到<strong>toElement</strong>(不包含)</td>
</tr>
<tr>
<td><strong>SortedSet headSet(toElement)</strong></td>
<td>生成此<strong>Set</strong>的元素，由小于<strong>toElement</strong>的元素组成</td>
</tr>
<tr>
<td><strong>SortedSet tailSet(fromElement)</strong></td>
<td>生成此<strong>Set</strong>的子集，由大于或等于<strong>fromElement</strong>的元素组成</td>
</tr>
</tbody></table>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(sortedSet,<span class="string">"one two three four five six seven eight"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">3</span>) low = it.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) high = it.next();</span><br><span class="line">            <span class="keyword">else</span> it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">        System.out.println(sortedSet.headSet(high));</span><br><span class="line">        System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">eight</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">[one, seven, six, three]</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three]</span></span><br><span class="line"><span class="comment">[one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SortedSet</strong>是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用<strong>LinkedHashSet</strong>来保存。</p>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>除并发应用，<strong>Queue在SE5中仅有的两个实现是LinkedList和PriorityQueue</strong>，两者的<strong>差异在于排序行为而不是性能</strong>。</p>
</li>
<li><p>下面是Queue实现的大部分操作的示例，包括基于并发的Queue.你可以将元素从队列的一端插入，并从另一端将它们抽取出来：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)</span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        String[] s = (<span class="string">"one two three four five six seven eight nine ten"</span>).split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了优先级队列(<strong>PriorityBlockingQueue,PriorityQueue</strong>)，<strong>Queue</strong>将精确地按照元素被置于<strong>Queue</strong>中的顺序产生它们。</p>
</li>
</ul>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><ul>
<li><p>该列表中的每个对象都包含一个字符串和一个主要的以及次要的优先级值。该列表的排序顺序也是通过实现Comparable而进行控制的。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoList</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDoList</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String td,<span class="keyword">char</span> pri, <span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.primary = pri;</span><br><span class="line">            <span class="keyword">this</span>.secondary = sec;</span><br><span class="line">            <span class="keyword">this</span>.item = td;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ToDoItem arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primary &gt; arg.primary)</span><br><span class="line">                <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (primary == arg.primary)</span><br><span class="line">                <span class="keyword">if</span> (secondary &gt; arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (secondary == arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toString(primary)+secondary+<span class="string">": "</span>+item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ToDoList toDoList = <span class="keyword">new</span> ToDoList();</span><br><span class="line">        toDoList.add(<span class="string">"Empty trash"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed bird"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Mow lawn"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Water lawn"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed cat"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!toDoList.isEmpty())</span><br><span class="line">            System.out.println(toDoList.remove());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A1: Water lawn</span></span><br><span class="line"><span class="comment">A2: Feed dog</span></span><br><span class="line"><span class="comment">B1: Feed cat</span></span><br><span class="line"><span class="comment">B7: Feed bird</span></span><br><span class="line"><span class="comment">C3: Mow lawn</span></span><br><span class="line"><span class="comment">C4: Empty trash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><ul>
<li><p>双向队列(双端队列)就像是一个队列，但是你可以在任何一端添加或移除元素。在<strong>LinkedList</strong>中包含支持双向队列的方法，但是在<strong>Java</strong>标准类库中没有任何显式的用于双向队列的接口。因此，<strong>LinkedList</strong>无法去实现这样的接口，你也无法转型到<strong>Queue</strong>那样去向上转型为<strong>Deque(双向队列/dek/)</strong>。但是，你可以使用组合来创建一个<strong>Deque</strong>类，并直接从<strong>LinkedList</strong>中暴露相关的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    ..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillTest</span><span class="params">(Deque&lt;Integer&gt; deque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            deque.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">55</span>; i++) &#123;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; di = <span class="keyword">new</span> Deque&lt;&gt;();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        System.out.println(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeFirst() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeLast() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[26, 25, 24, 23, 22, 21, 20, 50, 51, 52, 53, 54]</span></span><br><span class="line"><span class="comment">26 25 24 23 22 21 20 50 51 52 53 54 </span></span><br><span class="line"><span class="comment">54 53 52 51 50 20 21 22 23 24 25 26 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你可能不太在两端放入元素并抽取它们，因此，<strong>Deque</strong>不如<strong>Queue</strong>那样常用。</p>
</li>
</ul>
<h3 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h3><ul>
<li><p>标准的<strong>Java</strong>类库中包含了<strong>Map</strong>的几种基本实现，包括：<strong>HashMap</strong>,<strong>TreeMap</strong>,<strong>LinkedHashMap</strong>,<strong>WeakHashMap</strong>,<strong>ConcurrentHashMap</strong>,<strong>IdentityHashMap</strong>。</p>
</li>
<li><p>上面实现类都有同样的基本接口<strong>Map</strong>，但是行为特征各不相同，==这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和判定“键”等价的策略等方面==。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        pairs = <span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= pairs.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        pairs[index++] = <span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(pairs[i][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++) &#123;</span><br><span class="line">            result.append(pairs[i][<span class="number">0</span>].toString());</span><br><span class="line">            result.append(<span class="string">" : "</span>);</span><br><span class="line">            result.append(pairs[i][<span class="number">1</span>].toString());</span><br><span class="line">            <span class="keyword">if</span> (i &lt; index - <span class="number">1</span>)</span><br><span class="line">                result.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AssociativeArray&lt;String,String&gt; map = <span class="keyword">new</span> AssociativeArray&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">"sky"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        map.put(<span class="string">"grass"</span>,<span class="string">"green"</span>);</span><br><span class="line">        map.put(<span class="string">"ocean"</span>,<span class="string">"dancing"</span>);</span><br><span class="line">        map.put(<span class="string">"tree"</span>,<span class="string">"tall"</span>);</span><br><span class="line">        map.put(<span class="string">"earth"</span>,<span class="string">"brown"</span>);</span><br><span class="line">        map.put(<span class="string">"sun"</span>,<span class="string">"warm"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">"extra"</span>,<span class="string">"object"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Too many objects!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"ocean"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Too many objects!</span></span><br><span class="line"><span class="comment">sky : blue</span></span><br><span class="line"><span class="comment">grass : green</span></span><br><span class="line"><span class="comment">ocean : dancing</span></span><br><span class="line"><span class="comment">tree : tall</span></span><br><span class="line"><span class="comment">earth : brown</span></span><br><span class="line"><span class="comment">sun : warm</span></span><br><span class="line"><span class="comment">dancing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关联数组中的基本方法是<strong>put()</strong>和<strong>get()</strong>,<strong>toString()</strong>方法被覆盖为可以打印键-值对，<strong>main()</strong>用字符串加载了一个<strong>AssociativeArray</strong>，并打印所产生的映射表，随后是获取一个值的<strong>get()</strong>。</p>
</li>
<li><p>上面中为了使用<strong>get()</strong>方法，你需要传递想要查找的<strong>key</strong>，然后它会将于之相关联的值作为结果返回，或者在找不到的情况下返回<strong>null</strong>，<strong>get()</strong>方法使用的是效率最差的方式来定位值的：从数组的头部开始，使用<strong>equals()</strong>方法依次比较键。</p>
</li>
<li><p>上面示例中的版本是说明性的，但是缺乏效率，并且由于固定的尺寸而显得很不灵活，但是在<strong>java.util</strong>中的各种<strong>Map</strong>都没有这些问题，并且可以替代到上面的示例中。</p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>性能是映射表中的一个重要问题，当在<strong>get()</strong>中使用线性搜索时，执行速度会相当地慢，而这正是<strong>HashMap</strong>提高速度的地方。<strong>HashMap</strong>使用了特殊的值，称为散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的，用以代表对象的<strong>int</strong>值，它是通过将该对象的某些信息进行转换而生成的。<strong>hashCode()</strong>是根类<strong>Object</strong>中的方法，因此所有<strong>Java</strong>对象都能产生散列码。</li>
<li>HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashMap</strong>(默认选择)</td>
<td><strong>Map</strong>基于==散列表的实现==(它取代了<strong>Hashtable</strong>)。==插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。==</td>
</tr>
<tr>
<td><strong>LinkedHashMap</strong></td>
<td>类似于<strong>HashMap</strong>，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(<strong>LRU</strong>)的次序。==只比<strong>HashMap</strong>慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。==</td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td>基于红黑树的实现。==看“键“或”键值对“时，它们会被排序(次序由<strong>Comparable</strong>或<strong>Comparator</strong>决定)。====<strong>TreeMap</strong>的特点在于，所得到的结果是经过排序的。<strong>TreeMap</strong>是唯一的带有<strong>subMap()</strong>方法的<strong>Map</strong>，他可以返回一个子树。==</td>
</tr>
<tr>
<td><strong>WeakHashMap</strong></td>
<td>弱键(<strong>weak key</strong>)映射，允许释放映射所指向的对象；==这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个”键”，则此”键“可以被垃圾收集器回收。==</td>
</tr>
<tr>
<td><strong>ConcurrentHashMap</strong></td>
<td>一种线程安全的<strong>Map</strong>，它不涉及同步加锁。</td>
</tr>
<tr>
<td><strong>IdentityHashMap</strong></td>
<td>==使用代替<strong>equals()</strong>对”键“进行比较的散列映射，专为解决特殊问题而设计的。==</td>
</tr>
</tbody></table>
<ul>
<li>散列是映射中存储元素时最常用的方式。</li>
<li>对<strong>Map</strong>中使用的键的要求与对<strong>Set</strong>中的元素的要求一样，任何键都必须具有一个<strong>equals()</strong>方法；如果键被用于散列<strong>Map</strong>，那么它必须还具有恰当的<strong>hashCode()</strong>方法，如果键被用于<strong>TreeMap</strong>，那么它还必须实现<strong>Comparable</strong>。</li>
</ul>
<h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h4><ul>
<li>使用<strong>SortedMap</strong>(==<strong>TreeMap</strong>是现阶段的唯一实现==)，==可以确保键处于排序状态==，这使得它具有额外的功能，这些功能由<strong>SortedMap</strong>接口中的以下方法提供：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Map</strong>使用的<strong>Comparator</strong>；或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>T firstKey()</strong></td>
<td>返回<strong>Map</strong>中的第一个键。</td>
</tr>
<tr>
<td><strong>T lastKey()</strong></td>
<td>返回<strong>Map</strong>中的最末一个键。</td>
</tr>
<tr>
<td><strong>SortedMap subMap(fromKey,toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，范围由<strong>fromKey</strong>(包含)到<strong>toKey</strong>(不包含)的键确定。</td>
</tr>
<tr>
<td><strong>SortedMap headMap(toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键小于<strong>toKey</strong>的所有键值对组成。</td>
</tr>
<tr>
<td><strong>SortedMap tailMap(fromKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键大于或等于<strong>fromKey</strong>的所有键值对组成。</td>
</tr>
</tbody></table>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>为了==提高速度==，<strong>LinkedHashMap</strong>==散列化所有元素==，但是在==遍历键值对==时，却又==以元素的插入顺序返回键值对==(<strong>System.out.println()</strong>会迭代遍历该映射，因此可以看到遍历的结果)。此外，可以在构造器中设定<strong>LinkedHashMap</strong>，使之采用基于访问的==最近最少使用(<strong>LRU</strong>)算法==，于是==没有被访问过的==(可被看作需要删除的)==元素就会出现在队列的前面==。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</li>
</ul>
<h3 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h3><ul>
<li><p>当你自己创建用作<strong>HashMap</strong>的键的类，==有可能会忘记在其中放置必须的方法==，而这是通常会犯的一个错误。如：一个天气预报系统，将<strong>Groundhog</strong>对象与<strong>Prediction</strong>对象练习起来。创建这两个类，使用<strong>Groundhog</strong>作为键，<strong>Prediction</strong>作为值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        number = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Groundhog&#123;"</span> +</span><br><span class="line">                <span class="string">"number="</span> + number +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow = rand.nextDouble() &gt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shadow)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of Winter!"</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog = type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map = <span class="keyword">new</span> HashMap&lt;Groundhog,Prediction&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">            System.out.println(<span class="string">"map="</span>+map);</span><br><span class="line">            Groundhog gh = ghog.newInstance(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"Looking up prediction for "</span>+gh);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(gh))</span><br><span class="line">                System.out.println(map.get(gh));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"Key not found:"</span> + gh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        detectSpring(Groundhog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#5=Early Spring, Groundhog#9=Six more weeks of Winter!, Groundhog#8=Six more weeks of Winter!, Groundhog#7=Early Spring, Groundhog#1=Six more weeks of Winter!, Groundhog#3=Early Spring, Groundhog#6=Early Spring, Groundhog#0=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#4=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Key not found:Groundhog#3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<strong>Groundhog</strong>被给予一个标识数字，于是可以在<strong>HashMap</strong>中这样查找<strong>Prediction</strong>,“给我与<strong>Groundhog#3</strong>相关的<strong>Prediction</strong>”。<strong>Prediction</strong>类包含一个<strong>boolean</strong>值和一个<strong>toString()</strong>方法。<strong>boolean</strong>值使用<strong>java.util.random()</strong>来初始化；而<strong>toString()</strong>方法则解释结果。<strong>detectSpring()</strong>方法使用反射机制来实例化及使用<strong>Groundhog</strong>类或任何从<strong>Groundhog</strong>派生出来的类。如果我们为解决当前问题从<strong>Groundhog</strong>继承创建了一个新类型的时候，<strong>detectSpring()</strong>方法使用的这个技巧就变得很有用了。</p>
</li>
<li><p>首先会使用<strong>Groundhog</strong>和与之相关联的<strong>prediction</strong>填充<strong>HashMap</strong>，然后打印<strong>HashMap</strong>，以便可以观察它是否被填入了一些内容。然后使用标识数字为3的<strong>Groundhog</strong>作为键，查找与之对应的预报内容。</p>
</li>
<li><p>但是它不工作，它无法找到数字3这个键，问题出在<strong>Groundhog</strong>自动的继承自基类<strong>Object</strong>，所以这里使用<strong>Object</strong>的<strong>hashCode()</strong>方法生成散列码，而==它默认是使用对象的地址计算散列码。==</p>
</li>
<li><p>也许你会认为，==只需要恰当的<strong>hashCode()</strong>方法的覆盖版本即可。但是它仍然无法正常运行，除非你同时覆盖<strong>equals()</strong>方法，==它也是<strong>Object</strong>的一部分。<strong>HashMap</strong>使用<strong>equals()</strong>判断当前的键是否与表中存在的键相同。</p>
</li>
<li><p>正确的<strong>equals()</strong>方法必须满足下面==5个条件==：</p>
<ol>
<li>==自反性。对任意x,x.equals(x)一定返回true。==</li>
<li>==对称性。对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。==</li>
<li>==传递性。对任意x,y,z,如果有x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。==</li>
<li>==一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。==</li>
<li>==对任何不是null的x，x.equals(null)一定返回false。==</li>
</ol>
</li>
<li><p>默认的<strong>Object.equals()</strong>只是==比较对象的地址==，所以一个<strong>Groundhog(3)</strong>并不等于另一个<strong>Groundhog(3)</strong>。因此，==<u>如果要使自己的类作为<strong>HashMap</strong>的键，必须同时重载<strong>hashCode()</strong>和<strong>equals()</strong></u>==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog2</span> <span class="keyword">extends</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Groundhog2 &amp;&amp;</span><br><span class="line">                (number == ((Groundhog2)obj).number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringDetector.detectSpring(Groundhog2.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#0=Six more weeks of Winter!, Groundhog#1=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#3=Early Spring, Groundhog#4=Six more weeks of Winter!, Groundhog#5=Early Spring, Groundhog#6=Early Spring, Groundhog#7=Early Spring, Groundhog#8=Six more weeks of Winter!, Groundhog#9=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Early Spring</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管<strong>equals()</strong>方法只是检查其参数是否为<strong>Groundhog2</strong>的实例，但是<strong>instanceof</strong>悄悄地检查了此对象是否为<strong>null</strong>，因为如果<strong>instanceof</strong>左边的参数为<strong>null</strong>，它会返回<strong>false</strong>。如果<strong>equals()</strong>的参数不为<strong>null</strong>且类型正确，则基于每个对象中实际的<strong>number</strong>数值进行比较。</p>
</li>
<li><p>当在HashSet中使用自己的类作为键时，必须注意这个问题。</p>
</li>
</ul>
<h4 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h4><ul>
<li>上面说明了，如果不为你的键覆盖<strong>hashCode()</strong>和<strong>equals()</strong>，那么使用散列的数据结构(<strong>HashSet</strong>,<strong>HashMap</strong>,<strong>LinkedHashSet</strong>或<strong>LinkedHashMap</strong>)就无法正确处理你的键。</li>
<li>使用散列的目的在于：想要使用一个对象来查找另一个对象。</li>
<li>不过使用<strong>TreeMap</strong>或者你实现的<strong>Map</strong>也可以达到此目的。</li>
</ul>
<h4 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h4><ul>
<li>==散列的价值在于速度：散列使得查询得以快速进行==。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用<strong>Collections.binarySearch()</strong>进行查询。</li>
<li>散列则更近一步，它将键保存在某处，以便能很快找到，存储一组元素最快的数据结构是数组，所以使用它来表示键的信息，但是因为数组不能调整容量，因此会出现问题，我们希望在<strong>Map</strong>中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办？</li>
<li>解决方案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在<strong>Object</strong>中的，且可能由你的类覆盖的<strong>hashCode()</strong>方法(在计算机科学的术语中称为散列函数)生成。</li>
<li>查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突(如果值的数量是固定的，那么就有可能)，那可就有一个完美的散列函数，但是这种情况只是特例。通常，冲突由外部链接处理：==数组并不能直接保存值，而是保存值的<strong>list</strong>。==然后对<strong>list</strong>中的值使用<strong>equals()</strong>方法进行线性查询，这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个<strong>list</strong>，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是<strong>HashMap</strong>会如此之快的原因。</li>
</ul>
<h4 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h4><ul>
<li><p>设计<strong>hashCode()</strong>时最重要的因素就是：无论何时，对同一个对象调用<strong>hashCode()</strong>都应该生成同样的值。如果在将一个对象用<strong>put()</strong>添加进<strong>HashMap</strong>时产生一个<strong>hashCode()</strong>值，而用<strong>get()</strong>取出时却产生另一个<strong>hashCode()</strong>值，那么就无法重新取得该对象了。</p>
</li>
<li><p>此外，也不应该使<strong>hashCode()</strong>依赖于具有唯一性的对象信息，尤其是使用<strong>this</strong>的值，这只能产生糟糕的<strong>hashCode()</strong>。因为这样做无法生成一个新的键，使之与<strong>put()</strong>中原始的键值对中的键相同。</p>
</li>
<li><p><strong>String</strong>有个特点：==如果程序中有多个<strong>String</strong>对象，都包含相同的字符串序列，那么这些<strong>String</strong>对象都映射到同一块内存区域。==所以<strong>new String(“hello”)</strong>生成的两个实例，虽然是相互独立的，但是对它们使用<strong>hashCode()</strong>应该生成同样的结果。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] hellos = <span class="string">"Hello Hello"</span>.split(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(hellos[<span class="number">0</span>].hashCode());</span><br><span class="line">        System.out.println(hellos[<span class="number">1</span>].hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对<strong>String</strong>而言，<strong>hashCode()</strong>明显是基于<strong>String</strong>的内容的。</p>
</li>
<li><p>要想使<strong>hashCode()</strong>实用，它必须基于对象的内容生成散列码。(散列码不必是独一无二的，但是通过<strong>hashCode()</strong>和<strong>equals()</strong>，必须能够完全确定对象的身份)</p>
</li>
<li><p>因为在生成桶的下标前，<strong>hashCode()</strong>还需要做进一步的处理，所以散列码的生成范围并不重要，只要是<strong>int</strong>即可。</p>
</li>
<li><p>好的<strong>hashCode()</strong>应该产生分布均匀的散列码。如果散列码都集中在一块，那么<strong>HashMap</strong>或者<strong>HashSet</strong>在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p>
</li>
</ul>
<h3 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h3><ul>
<li><strong>Hashtable</strong>,<strong>Vector</strong>和<strong>Stack</strong>的“<strong>特征</strong>”是，它们是过去遗留下来的类，目的是为了支持老的程序(最好不要在新的程序中使用它们)</li>
<li>容器之间的区别通常归结为由什么在背后“支持”它们。也就是说，==所使用的接口是由什么样的数据结构实现的。==</li>
</ul>
<h4 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h4><ul>
<li>对于背后有数组支撑的<strong>List</strong>和<strong>ArrayList</strong>，无论列表的大小如何，访问都很快速和一致，而对于<strong>LinkedList</strong>，访问时间对于较大的列表将明显增加。显然，如果你需要执行大量的随机访问，链表不会是一种好的选择。</li>
<li>当在列表中间插入新的元素。对于<strong>ArrayList</strong>，当列表变大时，其开销将变得很高昂，但是对于<strong>LinkedList</strong>，相对来说比较低廉，并且不随列表尺寸而发生变化。这是因为<strong>ArrayList</strong>在插入时，必须创建空间并将它的所有引用向前移动，这会随<strong>ArrayList</strong>的尺寸增加而产生高昂的代价。<strong>LinkedList</strong>只需链接新的元素，而不必修改列表中剩余的元素。</li>
<li><strong>LinkedList</strong>对<strong>List</strong>的端点会进行特殊处理，这使得在将<strong>LinkedList</strong>用作<strong>Queue</strong>时，速度可以得到提高。但是，如果你在列表的中间增加或移除元素，其中会包含随机访问的代价，这在不同的<strong>List</strong>实现中变化很大。</li>
<li>在<strong>LinkedList</strong>中的插入和移除代价相当低廉，并且不随列表尺寸发生变化，但是对于<strong>ArrayList</strong>，插入操作代价特别高昂，并且其代价将随列表尺寸的增加而增加。</li>
<li>对于随机访问的<strong>get()</strong>和<strong>set()</strong>操作，背后有数组支撑的<strong>List</strong>只比<strong>ArrayList</strong>稍快一点，但是对于<strong>LinkedList</strong>，同样的操作会变得异常的高昂。因为它本身就不是针对随机访问操作而设计的。</li>
<li>==最佳的做法可能是将<strong>ArrayList</strong>作为默认首选==，只有你需要使用额外的功能，或者当程序的性能因为经常从表中进行插入和删除而变差的时候，才去选择<strong>LinkedList</strong>。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支撑的<strong>List</strong>(就像<strong>Arrays.asList()</strong>产生的列表)，也可以选择真正的数组。</li>
<li><strong>CopyOnWriteArrayList</strong>是<strong>List</strong>的特殊实现，专门用于并发编程。</li>
</ul>
<h4 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h4><ul>
<li><strong>HashSet</strong>的性能基本上总是比<strong>TreeSet</strong>好，特别是在添加和查询元素时，<strong>TreeSet</strong>存在的唯一原因是它可以维持元素的排序状态；所以，只有当需要一个排好序的<strong>Set</strong>时，才用<strong>TreeSet</strong>。因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，所以，用<strong>TreeSet</strong>迭代通常比用<strong>HashSet</strong>要快。</li>
<li>对于插入操作，<strong>LinkedHashSet</strong>比<strong>HashSet</strong>的代价更高；这是由维护链表所带来额外开销造成的。</li>
</ul>
<h4 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h4><ul>
<li>除了<strong>IdentityHashMap</strong>,所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。</li>
<li><strong>Hashtable</strong>的性能大体上与<strong>HashMap</strong>相当。因为<strong>HashMap</strong>是用来替代<strong>Hashtable</strong>的，因此它们使用了相同的底层存储和查找机制。</li>
<li><strong>TreeMap</strong>通常比<strong>HashMap</strong>要慢。与使用<strong>TreeSet</strong>一样，<strong>TreeMap</strong>是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。</li>
<li>当使用<strong>Map</strong>时，你的第一选择应该是<strong>HashMap</strong>,只有在你要求<strong>Map</strong>始终保持有序时，才需要使用<strong>TreeMap</strong>。</li>
<li><strong>LinkedHashMap</strong>在插入时比<strong>HashMap</strong>慢一点，因为它维护散列数据结构的同时还要维护链表(以保持插入顺序)。正是由于这个列表，使得其迭代速度更快。</li>
<li><strong>IdentityHashMap</strong>则具有完全不同的性能，==因为它使用的是<strong>==</strong>而不是<strong>equals()</strong>来比较元素。==</li>
</ul>
<h5 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h5><ul>
<li>我们可以通过手工调整<strong>HashMap</strong>来提高其性能，从而满足我们特定应用的需求。为了在调整<strong>HashMap</strong>时理解性能问题，下面术语必要了解以下：<ul>
<li>==<strong>容量</strong>==：表中的桶位数。</li>
<li>==<strong>初始容量</strong>==：表在创建时所拥有的桶位数。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定初始容量的构造器。</li>
<li>==<strong>尺寸</strong>==：表中当前存储的项数。</li>
<li>==<strong>负载因子</strong>==：尺寸/容量。==空表的负载因子是0==，==而半满表的负载因子是0.5，以此类推==。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的(但是会减慢使用迭代器进行遍历的过程)。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量(桶位数),实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中(这被称为再散列)。<strong>HashMap</strong>使用的默认负载因子是==0.75==(只有当表达到3/4满时，才进行再散列)，这个因子在时间和空间代价之间达到了平衡。</li>
</ul>
</li>
<li>如果你知道将要在<strong>HashMap</strong>中存储多少项，那么==创建一个具有恰当大小的初始容量将可以避免自动在散列的开销==。</li>
</ul>
<h4 id="Collection或Map的同步控制"><a href="#Collection或Map的同步控制" class="headerlink" title="Collection或Map的同步控制"></a>Collection或Map的同步控制</h4><ul>
<li><p>Collections类有办法能够自动同步整个容器。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; tSet = Collections.synchronizedSet(<span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; mm = Collections.synchronizedMap(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面直接将新生成的容器传递给了适当的“同步”方法；这样做就不会有任何机会暴露出不同步的版本。</p>
</li>
</ul>
<h5 id="快速报错"><a href="#快速报错" class="headerlink" title="快速报错"></a>快速报错</h5><ul>
<li><p><strong>Java</strong>容器有一个==保护机制==，==能够防止多个进程同时修改同一个容器的内容。如果在你迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或者修改此容器内的某个对象==，那么就会出现问题。Java容器类类库采用==快速报错(<strong>fail-fast</strong>)机制==。它会探查容器上的任何除了你的进程所进行的操作外的所有变化，一旦它发现其它进程修改了容器，就会立即抛出==<strong>ConcurrentModificationException</strong>==异常。</p>
</li>
<li><p>“快速报错”机制的工作原理：只需要创建一个迭代器，然后向迭代器所指向的<strong>Collection</strong>添加点什么，如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFast</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        c.add(<span class="string">"An Object"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = it.next();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>程序运行时发生了异常，因为在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。此例中，应该在添加完所有的元素之后，再获取迭代器。</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>,<strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>都使用了可以避免<strong>ConcurrentModificationException</strong>的技术。</p>
</li>
</ul>
<h3 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h3><ul>
<li><strong>java.lang.ref</strong>类库包含了一组类，这些类为==垃圾回收提供了更大的灵活性==。==当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。==有三个继承自抽象类<strong>Reference</strong>的类：<strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>。当垃圾回收器正在考察的对象只能通过某个<strong>Reference</strong>对象才“==可获得==”时，上述这些不同的派生类==为垃圾回收器提供了不同级别的间接性指示==。</li>
<li>对象是可获得的(reachable)，是指此对象可在程序中的某处找到。这意味着你在栈中有一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对象含有另一个引用指向正在讨论的对象；也可能有更多的中间链接。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序将无法使用到它，所以将其回收是安全的。</li>
<li>如果想继续持有对某个对象的引用，希望后续还能够访问到该对象，但是也希望能够允许垃圾回收器释放它，这时就应该使用<strong>Reference</strong>对象。这样，你可以继续使用该对象，而在内存消耗殆尽的时候又允许释放该对象。</li>
<li>以<strong>Reference</strong>对象作为你和普通引用之间的媒介(代理)，另外，一定不能有普通的引用指向那个对象，这样就能达到上述目的。(普通的引用指没有经<strong>Reference</strong>对象包装过的引用)。如果垃圾回收器发现某个对象通过普通引用可获得的，该对象就不会被释放。</li>
<li><strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>由强到弱排列，对应不同的级别的“可获得性”。<strong>Softreference</strong>用以实现内存敏感的告诉缓存。<strong>WeakReference</strong>是为实现“规范映射”而设计的，它不妨碍垃圾回收器回收映射的“键”(或“值”)。“规范映射”中的实例可以在程序的多处被同时使用，以节省存储空间。<strong>PhantomReference</strong>用以调度回收前的清理工作，它比Java终止机制更灵活。</li>
<li>使用<strong>SoftReference</strong>和<strong>WeakReference</strong>时，可以选择是否要将它们放入<strong>ReferenceQueue</strong>(用作“回收前清理工作”的工具)。而<strong>PhantomReference</strong>只能依赖于<strong>ReferenceQueue</strong>。</li>
</ul>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><ul>
<li><p>容器类中有一种特殊的<strong>Map</strong>，即<strong>WeakHashMap</strong>,它被用来保存<strong>WeakReference</strong>。在这种映射中，每个值只保存一份实例以节省存储空间。当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它(而不是重新在创建)。映射可将值作为其初始化中的一部分，不过通常是在需要的时候才生成“值”。</p>
</li>
<li><p>==这是一种节约存储空间的技术，因为<strong>WeakHashMap</strong>允许垃圾回收器自动清理键和值。允许清理元素的触发条件是，不再需要此键了。==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        ident = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Element</span><br><span class="line">                &amp;&amp; ident.equals(((Element) o).ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span> + getClass().getSimpleName() + <span class="string">" "</span> + ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            Key[] keys = <span class="keyword">new</span> Key[size];</span><br><span class="line">            WeakHashMap&lt;Key,Value&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Key k = <span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">                Value v = <span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    keys[i] = k;</span><br><span class="line">                    map.put(k,v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行此程序，会看到垃圾回收器每隔三个键就跳过一个，因为指向那个键的普通引用被存入了<strong>keys</strong>数组，所以那些对象不能被垃圾回收器回收。</p>
</li>
</ul>
<h3 id="Java-1-0-1-1的容器"><a href="#Java-1-0-1-1的容器" class="headerlink" title="Java 1.0/1.1的容器"></a>Java 1.0/1.1的容器</h3><h4 id="Vector和Enumeration"><a href="#Vector和Enumeration" class="headerlink" title="Vector和Enumeration"></a>Vector和Enumeration</h4><ul>
<li>在<strong>Java 1.0/1.1</strong>中，<strong>Vector</strong>是==唯一可以自我扩展的序列==。基本上，可以将其看作是<strong>ArrayList</strong>。但是具有有长有难记的方法名，在订正过的<strong>Java</strong>容器类类库中，<strong>Vector</strong>被改造过，可将其归类为<strong>Collection</strong>和<strong>List</strong>。</li>
<li><strong>Java 1.0/1.1</strong>版的迭代器发明了一个新的名字—<strong>枚举</strong>，取代了为人熟知的术语(<strong>迭代</strong>器)。此<strong>Enumeration</strong>接口比<strong>Iterator</strong>小，只有两个名字很长的方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasMoreElements()</td>
<td>如果此枚举包含更多的元素，该方法就返回true</td>
</tr>
<tr>
<td>Object nextElement()</td>
<td>该方法返回此枚举中的下一个元素(如果还有的话)，否则抛出异常。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Enumeration</strong>只是接口而不是实现，所以有时新的类库仍然使用了旧的<strong>Enumeration</strong>。虽然在你的代码中应该尽量使用<strong>Iterator</strong>，但也得有准备，类库可能会返回给你一个<strong>Enumeration</strong>。</li>
</ul>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul>
<li><strong>Java 1.0/1.1</strong>的<strong>Stack</strong>很奇怪，竟然不是用<strong>Vector</strong>来构建<strong>Stack</strong>，而是继承<strong>Vector</strong>。所以它拥有<strong>Vector</strong>所有的特点和行为，再加上一些额外的<strong>Stack</strong>行为。(很难理解设计者是否意识到这样做特别有用处，或者只是一个幼稚的设计，但是你永远都不应该使用它)</li>
</ul>
<h4 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h4><ul>
<li>如果想要高效地存储大量“开/关”信息，<strong>BitSet</strong>是很好的选择。不过它的效率仅是对空间而言；如果想要高效的访问时间，<strong>BitSet</strong>比本地数组稍慢一点。</li>
<li><strong>BitSet</strong>的最小容量是<strong>long</strong>：<strong>64</strong>位。如果要存储的内容比较小，那么<strong>BitSet</strong>就浪费了一些空间。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/容器/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>容器</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第二章/">
      java编程思想第二章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1 id="java编程思想总结"><a href="#java编程思想总结" class="headerlink" title="java编程思想总结"></a>java编程思想总结</h1><h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章:一切都是对象"></a>第二章:一切都是对象</h2><h3 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1. 用引用操作对象"></a>1. 用引用操作对象</h3><ul>
<li><h5 id="在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference"><a href="#在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference" class="headerlink" title="在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)"></a>在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)</h5></li>
<li><p>你拥有一个引用,并不一定需要一个对象与他关联.(String s;)</p>
</li>
</ul>
<h3 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2. 必须由你创建所有对象"></a>2. 必须由你创建所有对象</h3><ul>
<li>一旦创建一个引用,就希望他能与一个新的对象产生关联,通常用==new==来实现这一目的,new的意思是给我一个新对象</li>
</ul>
<h3 id="3-存储到什么地方"><a href="#3-存储到什么地方" class="headerlink" title="3.存储到什么地方"></a>3.存储到什么地方</h3><ul>
<li>寄存器:这是最快的存储区,位于不同于其他存储区的位置——-处理器内部,但是寄存器数量极其有限,所以寄存器根据需求进行分配,不能直接控制.</li>
<li>堆栈:位于通用RAM(随机访问存储器),通过堆栈指针可以从处理器哪里获得直接支持,堆栈指针若向下移动,则分配新内存,若向上移动,则释放哪些内存,这是一种快速有效的存储方式,仅次于寄存器,创建程序时,java必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针,java对象的引用存储在堆栈,但是java对象并不存储于其中.</li>
<li>堆:一种通用的内存池(位于ram区)用于存放java对象,不同于堆栈的好处是:编译器不需要知道存储的数据在堆里能存活多长时间,因此,在堆里分配存储有很大的灵活性,当我们在new一个对象的时候,会自动地在堆里进行存储分配,当然,为这种灵活性必须付出代价,用堆进行存储分配和清理可能会比用堆栈进行存储分配需要更多时间.</li>
<li>常量存储:常量值通常直接存放在程序代码内部,这样做是安全的,因为他们永远不会被改变.</li>
<li>非RAM存储:如果数据完全存活于程序之外,那么他可以不受程序的任何控制,在程序没有运行时也可以存在,两个最基本的例子就是”流对象”,”持久化对象”,在”流对象”中,对象转换成字节流,通常被发送给另一台机器,在”持久化对象”中,对象被存放在磁盘上.</li>
</ul>
<h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><ul>
<li><p>在程序中经常用到一系列类型,他们需要被特殊对待,可以把他们想象成”基本”类型,之所以被特殊对待,是因为==<strong>new将对象存储在”堆”里</strong>==,故用new创建一个对象,特别是小的简单的变量,不是很有效,对于这些类型,我们不用new来创建变量,而是创建一个并非是引用的”自动”变量,这个变量直接存储”值”并置放于堆栈中,效率更高.</p>
</li>
<li><p>java要确定每种基本类型所占存储空间的大小,他们的大小不像其他语言那样随机器硬件架构的变化而变化,正是这种原因使得java程序更具有可移植性.</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">大小</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
<th align="left">包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16 bit</td>
<td align="left">Unicode 0</td>
<td align="left">Unicode 0</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">8 bit</td>
<td align="left">-128</td>
<td align="left">127</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16 bit</td>
<td align="left">$-2^{15}$</td>
<td align="left">$2^{15}-1$</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">32 bit</td>
<td align="left">$-2^{31}$</td>
<td align="left">$2^{31}-1$</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64 bit</td>
<td align="left">$-2^{63}$</td>
<td align="left">$2^{63}-1$</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Void</td>
</tr>
</tbody></table>
</li>
<li><p>高精度数字</p>
<ul>
<li>java提供了用于高精度计算的类:<strong>BigInteger</strong>(整数)和<strong>BigDecimal</strong>(小数)(用于精确的货币计算)</li>
</ul>
</li>
</ul>
<h3 id="5-永远不需要销毁对象"><a href="#5-永远不需要销毁对象" class="headerlink" title="5.永远不需要销毁对象"></a>5.永远不需要销毁对象</h3><ul>
<li><p>作用域(scope)</p>
<ul>
<li>作用域决定了在其内部定义的变量名的可见性和生命周期,作用域由花括号的位置决定.</li>
</ul>
</li>
<li><p>对象的作用域</p>
<ul>
<li>java有一个垃圾回收器,用于监视用new创建的所有对象,并辨别那些不会在被引用的对象,随后,释放这些对象的内存空间,以便供其他新的对象使用.</li>
</ul>
</li>
<li><p>默认成员类型</p>
<ul>
<li><p>若类的某个成员是基本数据类型,即使没有初始化,java也会确保它获得一个默认值,前提必须是作为<strong>成员变量</strong>使用.</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>f</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’(null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常运行输出0</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果作为局部变量,会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2019/11/17/java编程思想第二章/1559358469727-1573995008036.png" alt="1559358469727"></p>
<h3 id="6-static"><a href="#6-static" class="headerlink" title="6.static"></a>6.static</h3><ol>
<li>优势<ul>
<li>只想为某特定域分配单一存储空间,而不去考虑究竟要创建多少对象,甚至根本不用创建对象.</li>
<li>希望某个方法不与包含他的类的任何对象关联在一起,也就是说,即使没有创建对象,也能够调用这个方法.</li>
</ul>
</li>
</ol>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/读书笔记/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>读书笔记</a>
        
          <a href="/tags/面向对象/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>面向对象</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/20/Spring-Cloud快速入门/">
      Spring Cloud快速入门
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-20</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><ul>
<li>Spring Cloud是一系列框架的有序集合。它利用<a href="https://baike.baidu.com/item/Spring%20Boot/20249767" target="_blank" rel="noopener">Spring Boot</a>的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。(<a href="https://baike.baidu.com/item/spring%20cloud/20269825?fr=aladdin" target="_blank" rel="noopener">引自百度百科</a>)</li>
</ul>
<h2 id="Spring-Cloud与单体架构"><a href="#Spring-Cloud与单体架构" class="headerlink" title="Spring Cloud与单体架构"></a>Spring Cloud与单体架构</h2><h4 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h4><ul>
<li>在微服务的概念形成之前，绝大多数的Web的应用都是使用单体建构进行构建的，在单体架构中，应用程序作为单个可部署的软件制品交付，所有的UI，业务，数据库访问逻辑都被打包在一个应用程序制品中并部署在一个应用程序服务器上面。</li>
</ul>
<p><img src="/2019/07/20/Spring-Cloud快速入门/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190721112755.jpg" alt="微信图片_20190721112755"></p>
<ul>
<li><p>单体架构存在的问题：</p>
<ul>
<li>随着业务的发展，开发变得越来越复杂，</li>
<li>每当各个团队修改代码的时候，整个应用程序都需要<code>重新构建，重新测试及重新部署等。</code></li>
<li>一旦一个模块出现问题，整个系统就有可能…….</li>
</ul>
<p><img src="/2019/07/20/Spring-Cloud快速入门/20180522084756_mmmla.jpeg" alt="20180522084756_mmmla"></p>
</li>
</ul>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>![](Spring-Cloud快速入门/spring cloud架构图.png)</p>
<ul>
<li>微服务技术，是对技术上和组织上扩大大型单体应用程序所面临的诸多挑战的直接回应。</li>
</ul>
<p><img src="/2019/07/20/Spring-Cloud快速入门/%E4%BD%A0%E8%BF%87%E6%9D%A5%E5%91%80-1563680562356.webp" alt="你过来呀"></p>
<ul>
<li>微服务架构是一个小的，松耦合的分布式服务。</li>
<li>微服务允许将一个大型的应用分解为具有严格职责定义的便于管理的组件。</li>
<li>微服务通过将大型的代码分解为小型的精准定义的部分，已解决大型代码库中传统的复杂问题。</li>
<li>微服务的一大核心就是：分解和分离应用程序的功能，使他们完全彼此独立。如下</li>
</ul>
<p><img src="/2019/07/20/Spring-Cloud快速入门/cloud.jpg" alt="cloud"></p>
<h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li>各个服务的开发，测试，部署等都相互独立，开发之间不需要依赖其他服务。</li>
<li>构建在微服务之上的应用程序能够使用多种编程语言和技术进行构建。</li>
<li>一个微服务可以跨多个应用程序复用。</li>
<li>微服务利用其小，独立和分布式的性质，使组织拥有明确责任领域的小型开发团队。</li>
</ul>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul>
<li>微服务的拆分是基于业务的，不是我们想怎么拆就怎么拆，给团队协作，沟通带来了挑战。</li>
<li>由于各个服务之间是互相独立的，数据也是独立的，当调用多个服务接口来进行操作时，如何保证各个服务之间的数据一致性。</li>
</ul>
<h2 id="主流微服务框架简单对比"><a href="#主流微服务框架简单对比" class="headerlink" title="主流微服务框架简单对比"></a>主流微服务框架简单对比</h2><table>
<thead>
<tr>
<th>RPC框架</th>
<th>dubbo</th>
<th>motan</th>
<th>thrift</th>
<th>grpc</th>
<th>spring cloud</th>
</tr>
</thead>
<tbody><tr>
<td>支持语言</td>
<td>java</td>
<td>java</td>
<td>跨语言</td>
<td>跨语言</td>
<td>java</td>
</tr>
<tr>
<td>服务治理</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>多注册中心</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>序列化方式</td>
<td>hessian2/lite/json/kryo</td>
<td>hessian2/json</td>
<td>thrift/json</td>
<td>protobuf</td>
<td>java/kryo</td>
</tr>
<tr>
<td>跨语言通讯</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="微服务首要考虑因素"><a href="#微服务首要考虑因素" class="headerlink" title="微服务首要考虑因素"></a>微服务首要考虑因素</h2><p><img src="/2019/07/20/Spring-Cloud快速入门/1563696525028.png" alt="1563696525028"></p>
<h4 id="大小适当"><a href="#大小适当" class="headerlink" title="大小适当"></a>大小适当</h4><ul>
<li>如何确保正确的划分微服务的大小，可以避免微服务承担太多的职责，适当的大小允许快速的更改应用程序，降低整个应用程序中断的总体风险。</li>
</ul>
<h4 id="位置透明"><a href="#位置透明" class="headerlink" title="位置透明"></a>位置透明</h4><ul>
<li>在微服务应用中，多个服务实例可以快速的启动和关闭时，如何管理服务调用的物理细节。</li>
</ul>
<h4 id="有弹性"><a href="#有弹性" class="headerlink" title="有弹性"></a>有弹性</h4><ul>
<li>如何通过绕过失败的服务，确保采取“快速失败”的方法来保护微服务消费者和应用程序的整体完整性。</li>
</ul>
<h4 id="可重复"><a href="#可重复" class="headerlink" title="可重复"></a>可重复</h4><ul>
<li>如何确保提供的每个新服务实例与生产环境中的所有其他服务实例具有相同的配置和代码库。</li>
</ul>
<h4 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h4><ul>
<li>如何使用异步处理和事件来最小化服务之间的直接依赖关系，并确保可以优雅地扩展代码库。</li>
</ul>
<h2 id="微服务模式"><a href="#微服务模式" class="headerlink" title="微服务模式"></a>微服务模式</h2><h4 id="核心微服务开发模式"><a href="#核心微服务开发模式" class="headerlink" title="核心微服务开发模式"></a>核心微服务开发模式</h4><ul>
<li>核心微服务开发模式解决了构建微服务的基础问题。</li>
</ul>
<h4 id="微服务路由模式"><a href="#微服务路由模式" class="headerlink" title="微服务路由模式"></a>微服务路由模式</h4><ul>
<li>路由模式负责处理处理希望微服务的客户端应用程序，使客户端应用程序发现服务的位置并路由到服务。</li>
</ul>
<h4 id="微服务客户端弹性模式"><a href="#微服务客户端弹性模式" class="headerlink" title="微服务客户端弹性模式"></a>微服务客户端弹性模式</h4><ul>
<li>因为微服务架构是高度分布的，所以必须对如何防止单个服务中的问题级联暴露给服务的消费者十分敏感。常用的有4种客户端弹性模式：客户端负载均衡，断路器模式，后备模式和舱壁模式。</li>
</ul>
<h4 id="微服务安全模式"><a href="#微服务安全模式" class="headerlink" title="微服务安全模式"></a>微服务安全模式</h4><ul>
<li>常用的3种基本的安全模式：验证，授权和凭据管理和传播</li>
</ul>
<h4 id="微服务日志记录和跟踪模式"><a href="#微服务日志记录和跟踪模式" class="headerlink" title="微服务日志记录和跟踪模式"></a>微服务日志记录和跟踪模式</h4><ul>
<li>微服务的优点是单体应用程序被分解为可以彼此独立部署的小的功能部件，而它的缺点是调试和跟踪应用程序和服务中发生的事情要困难的多。</li>
<li>常用的3种核心日志记录和跟踪模式：日志关联，日志聚合和微服务跟踪。</li>
</ul>
<h4 id="微服务构建和部署模式"><a href="#微服务构建和部署模式" class="headerlink" title="微服务构建和部署模式"></a>微服务构建和部署模式</h4><ul>
<li>微服务架构的核心原则之一是，微服务的每个实例都应该和其他所有实例相同。</li>
</ul>
<h2 id="Spring-Cloud各模块入门"><a href="#Spring-Cloud各模块入门" class="headerlink" title="Spring Cloud各模块入门"></a>Spring Cloud各模块入门</h2><h4 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h4>
      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Spring-Cloud/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>Spring Cloud</a>
        
          <a href="/tags/微服务/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>微服务</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/16/Java并发补充/">
      Java并发补充
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-16</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul>
<li><p>线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行，他的主要特点为：<strong>线程复用，控制最大并发数，管理线程</strong>。</p>
</li>
<li><p><strong>线程复用</strong></p>
<ul>
<li>每一个Thread的类都有一个start()方法，当调用start()启动线程时Java虚拟机会调用该类的run()方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。<strong>我们可以继承重写Thread类，在其start()方法中添加不断循环调用传递过来的Runnable对象</strong>。这就是线程池的实现原理。<strong>循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的</strong>。</li>
</ul>
</li>
<li><p><strong>线程池的组成</strong></p>
<ul>
<li>一般的线程池主要分为4个组成部分<ul>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程：线程池中的线程。</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行。</li>
<li>任务队列：用于存放处理的任务，提供一种缓冲机制。</li>
</ul>
</li>
<li>Java中的线程池1是通过Executor实现的。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563331336349.png" alt="1563331336349"></p>
<ul>
<li><code>ThreadPoolExecutor</code>中的构造方法<ul>
<li><code>corePoolSize</code>：指定了线程池中的线程数量。</li>
<li><code>maximumPoolSize</code>:指定了线程池中的最大线程数量。</li>
<li><code>keepAliveTime</code>：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li>
<li><code>utnit</code>:keepAliveTime的单位。</li>
<li><code>workQueue</code>:任务队列，被提交但尚未被执行的任务。</li>
<li><code>threadFactory</code>:线程工厂，用于创建线程，一般使用默认值。</li>
<li><code>handler</code>:拒绝策略，当任务太多来不及处理，如何拒绝任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="keyword">this</span>(corePoolSize,maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拒绝策略</strong></p>
<ul>
<li>线程池中的线程已经用完，无法继续为新任务服务，同时，等待队列也已经排满，再也塞不下新的任务，这时我们就需要拒绝策略机制合理的处理这个问题。</li>
<li>JDK内置的拒绝策略如下：<ul>
<li><code>AbortPolicy</code>:直接抛出异常，阻止系统正常运行。</li>
<li><code>CallerRunsPolicy</code>:只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li><code>DiscardOldestPolicy</code>:丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li><code>DiscardPolicy</code>:该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，这是最好的一种方案。</li>
<li>上述内置拒绝策略实现了<code>RejectedExecutionHandler</code>接口，若以上策略仍无法满足实际需要，完全可以自己扩展<code>RejectedExecutionHandler</code>接口。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池工作过程</strong></p>
<ol>
<li>线程池刚创建时，里面没有一个线程，任务队列是作为参数传递进来的，不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用execute()方法添加一个任务时，线程池会做以下判断：<ol>
<li>如果正在运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行这个队列。</li>
<li>如果正在运行的线程数大于或等于<code>corePoolSize</code>,那么将这个任务放入队列。</li>
<li>如果这时队列满了，而且正在运行的线程数小于<code>maximumPoolSize</code>，那么还要创建非核心线程立即运行这个任务。</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>,那么线程池会抛出异常<code>RejectExecutionException</code>。</li>
</ol>
</li>
<li>当一个线程完成任务时，他会从队列中取出下一个任务来执行。</li>
<li>当一个线程无事可做时，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li>
</ol>
</li>
</ul>
<h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><ul>
<li><p>在阻塞队列中，线程阻塞分为两种情况。</p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336228088.png" alt="1563336228088"></p>
<ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336249697.png" alt="1563336249697"></p>
</li>
</ul>
<h4 id="阻塞队列主要方法"><a href="#阻塞队列主要方法" class="headerlink" title="阻塞队列主要方法"></a>阻塞队列主要方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：抛出一个异常。</li>
<li>特殊值：返回一个特殊值(null或false，视情况而定)。</li>
<li>阻塞：在成功操作之前，一直阻塞线程。</li>
<li>超时：放弃前只在最大的时间内阻塞。</li>
</ul>
<ul>
<li><p><strong>插入操作</strong></p>
<ul>
<li><code>public abstract boolean add(E paramE)</code>:将指定元素插入到此队列中(如果立即可行且不会违反容量限制)，成功时返回true,如果当前没有可用的空间，则抛出<code>IllegalStateException</code>.如果该元素是NULL，则会抛出<code>NullPointerException</code>异常。</li>
<li><code>public abstract boolean offer(E paramE)</code>:将指定元素插入此队列中(如果立即可行且不会违反容量限制)，成功时返回<code>true</code>，如果当前没有可用的空间，则返回<code>false</code>。</li>
<li><code>public abstract void put(E paramE) throws InterruptedException</code>:将指定元素插入到此队列中，将等待可用的空间(如果有必要)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> checkNotNull(paramE);</span><br><span class="line"> ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;</span><br><span class="line"> localReentrantLock.lockInterruptibly();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length)</span><br><span class="line">     <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">     enqueue(paramE);</span><br><span class="line">         localReentrantLock.unlock();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 		localReentrantLock.unlock();</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>offer(E o,long timeout,TimeUnit unit)</code>:可以设定等待时间，如果在指定的时间内，还不能往队列中加入<code>BlockingQueue</code>,则返回失败。</li>
</ul>
</li>
<li><p><strong>获取数据操作</strong></p>
<ul>
<li><code>poll(time)</code>取出<code>BlockingQueue</code>里面排在首位的对象，若不能立即取出，则可以等待time参数规定的时间，取不到时返回<code>null</code>。</li>
<li><code>poll(long timeout,TimeUnit unit)</code>:从<code>BlockingQueue</code>取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，返回失败。</li>
<li><code>take()</code>:取出<code>BlockingQueue</code>里排在首位的对象，若<code>BlockingQueue</code>为空，阻断进入等待状态直到<code>BlockintQueue</code>有新的数据被加入。</li>
<li><code>drainTo()</code>:一次性从<code>BlockingQueue</code>获取所有可用的数据对象(还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率，不需要多次分批加锁或释放锁。</li>
</ul>
</li>
</ul>
<h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul>
<li><code>ArrayBlockingQueue</code>:由数组结构组成的有界阻塞队列(公平，非公平)。<ul>
<li>用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序，<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平的访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素，通常情况下为了保证公平性会降低吞吐量，我们可以使用代码创建一个公平的阻塞队列<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true)；</code>。</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code>:由链表结构组成的有界阻塞队列(两个独立锁提高并发)。<ul>
<li>基于链表的阻塞队列，同<code>ArrayListBlockQueue</code>类似，此队列按照先进先出(FIFO)的原则对元素进行排序，而<code>LinkedBlockingQueue</code>之所以能高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<code>LinkedBlockingQueue会默认一个类似无限大小地容量(Integer.MAX_VALUE)</code>。</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code>:支持优先级排序的无界阻塞队列(compareTo排序实现优先)。<ul>
<li>是一个支持优先队列的无界队列，默认情况下元素采取自然顺序升序排列，可以自定义实现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序，需要注意的是不能保证同优先级元素的顺序。</li>
</ul>
</li>
<li><code>DelayQueue</code>:使用优先级队列实现的无界阻塞队列(缓存失效，定时任务)。<ul>
<li><strong>是一个支持延迟获取元素的无界阻塞队列</strong>，队列使用<code>PriorityQueue</code>来实现，队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素，我们可以将<code>DelayQueue</code>运用到如下场景<ul>
<li>缓存系统的设计，可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行。比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
</li>
</ul>
</li>
<li><code>SynchronousQueue</code>:不存储元素的阻塞队列(不存储数据，可用于传递数据)。<ul>
<li><strong>是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素</strong>。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li>
</ul>
</li>
<li><code>LinkedTransferQueue</code>:由链表结构组成的无界阻塞队列。<ul>
<li>是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列，相对于其他阻塞队列，LinkedTransferQueue多了<code>tryTransfer()和transfer()</code>方法</li>
<li><strong>transfer()方法</strong>：如果当前有消费者正在等待接收元素(消费者使用take()方法或者带时间限制的poll()方法时)，<strong>transfer()方法可以把生产者传入的元素立即transfer给消费者.如果没有消费者在等待接收元素，transfer()方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</strong></li>
<li><strong>tryTransfer()方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者，如果没有消费者等待接收元素，则返回false。和<code>transfer()</code>的区别是<code>tryTransfer()</code>无论消费者是否接收，方法立即返回，而<code>transfer()</code>是必须等到消费者消费了才返回。</li>
<li>对于带有时间限制的<code>tryTransfer(E e,long timeout,TimeUnit unit)</code>方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>
</ul>
</li>
<li><code>LinkedBlockingDeque</code>:由链表结构组成的双向阻塞队列。<ul>
<li>是一个由链表组成的<strong>双向阻塞队列</strong>。<strong>所谓的双向队列指的是你可以从队列的两端插入和移除元素</strong>。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst(),addLast(),offerFirst(),offerLast(),peekFirst(),peekLast()</code>等方法，以First结尾的方法，表示插入，获取或移除双端队列的第一个元素，以Last结尾的方法，表示插入，获取和移除双端队列的最后一个元素。另外插入方法add()等同于addLast(),移除方法remove()等同于removeFirst()。但是take()方法却等同于takeFirst()。</li>
<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀，另外双向队列可以用在“工作窃取”模式中。</li>
</ul>
</li>
</ul>
<h2 id="CyclicBarrier-CountDownLatch和Semaphore的用法"><a href="#CyclicBarrier-CountDownLatch和Semaphore的用法" class="headerlink" title="CyclicBarrier,CountDownLatch和Semaphore的用法"></a>CyclicBarrier,CountDownLatch和Semaphore的用法</h2><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h4><ul>
<li><code>CountDownLatch</code>位于java.util.concurrent包下，使用它可以实现类似计数器的功能。如有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以利用CountDownLatch来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"等待2个子线程执行完毕"</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)"></a>CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</h4><ul>
<li><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code>可以被重用，暂且把这个状态叫做barrier,当调用<code>await()</code>之后，线程就处于barrier。CyclicBarrier中最重要的方法就是<code>await()</code>,它有两个重载版本：</p>
<ol>
<li><code>public int await()</code>:用来挂起当前线程，直至所有线程都到达<strong>barrier状态</strong>再同时执行后续任务。</li>
<li><code>pubilc int await(long timeout,TimeUnit unit)</code>:让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><ul>
<li><p><strong>Semaphore可以控制同时访问的线程个数</strong>，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。</p>
</li>
<li><p>Semaphore常用的方法：</p>
<ol>
<li><code>public void acquire()</code>:用来获取一个许可，若无许可能够获取，则会一直等待，直到获得许可。</li>
<li><code>public void acquire(int permits)</code>:获取permits许可。</li>
<li><code>public void release()</code>:释放许可(在释放许可之前，必须先获得许可)。</li>
<li><code>public void release(int permits)</code>:释放permits个许可。</li>
</ol>
</li>
<li><p>上述4个方法都会被阻塞，如果想立即得到执行结果，可以使用下述方法。</p>
<ol>
<li><code>public boolean tryAcquire()</code>:尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li><code>public boolean tryAcquire(long timeout,TimeUnit unit)</code>:尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。</li>
<li><code>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)</code>:尝试获取permits个许可，若在指定的时间内获取成功，则返回true，否则返回false。</li>
<li><code>public boolean tryAcquire(int permits)</code>:尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li>还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完</span></span><br><span class="line"><span class="comment"> 了，其他工人才能继续使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，<strong>CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</strong></li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
<h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul>
<li><strong><em>newCachedThreadPool</em></strong><ul>
<li>创建一个可根据需要创建新线程的线程池，但是在以前已经构造的线程可用时将重用它们，对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能，调用<strong>execute</strong>将重用以前构造的线程(如果线程可用)，如果现有线程没有可用的，则创建一个新的线程并添加到线程池中，终止并从缓存中移除那些已有60秒未被使用的线程，因此，长时间保持空闲的线程池不会使用任何资源。</li>
</ul>
</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>创建一个可重用固定线程数的线程池，以共享的无界队列来运行这些线程，在任意点，在大多数nThreads线程会处于处理任务的活动状态，如果在所有线程处于活动时提交附加任务，则在有可用线程之前，附加1任务将在队列中等待，如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个线程将代替它执行后续的任务(如果需要),在某个线程被显式地关闭之前，池中的线程将一直存在。</li>
</ul>
</li>
<li><strong>newScheduledThreadPool</strong><ul>
<li>创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。</li>
</ul>
</li>
<li><strong>newSingleThreadExecutor</strong><ul>
<li><strong>Executors.newSingleThreadExecutor()</strong>返回一个线程池(只有一个线程),这个线程池可以在线程死后(或发生异常)重新启动一个线程来代替原有的线程继续执行下去。</li>
</ul>
</li>
</ul>
<h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p><img src="/2019/07/16/Java并发补充/1563288982967.png" alt="1563288982967"></p>
<ul>
<li><strong>线程等待(wait)</strong><ul>
<li>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁，因此，wait()方法一般用在同步方法或同步代码块中。</li>
</ul>
</li>
<li><strong>线程睡眠(sleep)</strong><ul>
<li>sleep导致当前线程休眠，与wait不同的是sleep不会释放当前占用的锁，sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态。</li>
</ul>
</li>
<li><strong>线程让步(yield)</strong><ul>
<li>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片，一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li>
</ul>
</li>
<li><strong>线程中断(interrupt)</strong><ul>
<li>调用interrupt()方法并不会中断一个正在运行的线程，就是说处于Running状态的线程并不会因为被中止而被终止，仅仅改变了内部维护的中断标识位而已。</li>
<li>若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出<strong>InterruptedException</strong>,从而使线程提前结束TIMED-WATING状态。</li>
<li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</li>
</ul>
</li>
<li><strong>Join等待其他线程终止</strong><ul>
<li>join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待CPU的执行。</li>
</ul>
</li>
<li><strong>线程唤醒(notify)</strong><ul>
<li>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与该对象上主动同步的其他所有线程进行竞争，类似的方法还有notifyAll(),唤醒在此监视器上等待的所有线程。</li>
</ul>
</li>
<li><strong>其他常用方法</strong><ul>
<li><code>isAlive()</code>:判断一个线程是否存活。</li>
<li><code>activeCount()</code>:程序中活跃的线程数。</li>
<li><code>enumerate()</code>:枚举程序中的线程。</li>
<li><code>currentThread()</code>:得到当前线程。</li>
<li><code>isDaemon()</code>:一个线程是否为守护线程。</li>
<li><code>setDaemon()</code>:设置一个线程为守护线程。</li>
<li><code>setName()</code>:为线程设置名称。</li>
<li><code>setPriority()</code>:设置一个线程的优先级。</li>
<li><code>getPriority()</code>:获得一个线程的优先级。</li>
</ul>
</li>
</ul>
<h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><ul>
<li><strong>同步锁</strong><ul>
<li>当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种问题的出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据，Java中可已使用synchronized关键字来取得一个对象的同步锁。</li>
</ul>
</li>
<li><strong>死锁</strong><ul>
<li>就是多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。</li>
</ul>
</li>
</ul>
<h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><ul>
<li>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</li>
</ul>
<h4 id="变量可见性"><a href="#变量可见性" class="headerlink" title="变量可见性"></a>变量可见性</h4><ul>
<li>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</li>
</ul>
<h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul>
<li>volatile禁止了指令重排。</li>
</ul>
<h4 id="比Synchronized更轻量级的同步锁"><a href="#比Synchronized更轻量级的同步锁" class="headerlink" title="比Synchronized更轻量级的同步锁"></a>比Synchronized更轻量级的同步锁</h4><ul>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比Synchronized更轻量级的同步机制，volatile适合于这种场景：“<strong>一个变量被多个线程共享，线程直接给这个变量赋值</strong>”。</li>
<li>当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读写变量都从内存中读，跳过CPU cache这一步。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563354774642.png" alt="1563354774642"></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<ol>
<li>对变量的些操作不依赖于当前值(如i++)，或者说是单纯的1变量赋值(boolean flag = true)</li>
<li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用<code>volatile</code>。</li>
</ol>
</li>
</ul>
<h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><ul>
<li>进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性JVM解决了可见性和有序性的问题，而锁解决了原子性的问题，在理想的情况下我们希望做到“同步”和“互斥”，有以下的实现方式.</li>
</ul>
<h4 id="将数据抽象为一个类，并将数据的操作作为这个类的方法"><a href="#将数据抽象为一个类，并将数据的操作作为这个类的方法" class="headerlink" title="将数据抽象为一个类，并将数据的操作作为这个类的方法"></a>将数据抽象为一个类，并将数据的操作作为这个类的方法</h4><ul>
<li>将数据抽象为一个类，并将对这个数据的操作作为这个类的方法，这样可以很容易做到同步，只要在方法上加上<code>synchronized</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data= data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.dec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(add).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable对象作为一个类的内部类"><a href="#Runnable对象作为一个类的内部类" class="headerlink" title="Runnable对象作为一个类的内部类"></a>Runnable对象作为一个类的内部类</h4><ul>
<li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><ul>
<li>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</li>
</ul>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ol>
<li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</li>
<li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li>
<li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null</code>;</li>
</ol>
<p><img src="/2019/07/16/Java并发补充/1563357402171.png" alt="1563357402171"></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>最常用于解决数据库连接，Session管理等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">     Session s = (Session) threadSession.get(); </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">             s = getSessionFactory().openSession(); </span><br><span class="line">             threadSession.set(s); </span><br><span class="line">             &#125; </span><br><span class="line">    	 &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">     		<span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>都是用来协调多线程对共享对象，变量的访问。</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁。</li>
<li>都保证了可见性和互斥性。</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的<br>不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻<br>塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言<br>实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等</li>
</ol>
<h2 id="Volatile和Synchronized的区别"><a href="#Volatile和Synchronized的区别" class="headerlink" title="Volatile和Synchronized的区别"></a>Volatile和Synchronized的区别</h2><ol>
<li>volatile不会进行加锁操作。</li>
<li>volatile变量作用类似于同步变量读写操作。</li>
<li>volatile不如Synchronized安全。</li>
<li>volatile无法同时保证内存可见性和原子性。</li>
</ol>
<h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul>
<li>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li>
</ul>
<h4 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h4><ul>
<li>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</li>
<li>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</li>
</ul>
<h4 id="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><a href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成" class="headerlink" title="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"></a>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</h4><ul>
<li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358149513.png" alt="1563358149513"></p>
<h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul>
<li>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</li>
</ul>
<h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><ul>
<li>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</li>
</ul>
<h4 id="JVM的线程调度实现-抢占式调度"><a href="#JVM的线程调度实现-抢占式调度" class="headerlink" title="JVM的线程调度实现(抢占式调度)"></a>JVM的线程调度实现(抢占式调度)</h4><ul>
<li>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</li>
</ul>
<h4 id="线程让出cpu的情况"><a href="#线程让出cpu的情况" class="headerlink" title="线程让出cpu的情况"></a>线程让出cpu的情况</h4><ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。</li>
</ol>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><ul>
<li><strong>先来先服务调度算法(FCDS)</strong><ul>
<li>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</li>
</ul>
</li>
<li><strong>短作业(进程)优先调度算法</strong><ul>
<li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</li>
</ul>
</li>
</ul>
<h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><ul>
<li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</li>
<li><strong>非抢占式优先权算法</strong><ul>
<li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
</li>
<li><strong>抢占式优先权调度算法</strong><ul>
<li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
<li><strong>高响应比优先调度算法</strong><ul>
<li>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</li>
</ul>
</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358860683.png" alt="1563358860683"></p>
<h4 id="基于时间片的轮询调度算法"><a href="#基于时间片的轮询调度算法" class="headerlink" title="基于时间片的轮询调度算法"></a>基于时间片的轮询调度算法</h4><ul>
<li><strong>时间片轮转法</strong><ul>
<li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</li>
</ul>
</li>
<li><strong>多级反馈队列调度算法</strong><ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li>
</ol>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h4 id="概念特性"><a href="#概念特性" class="headerlink" title="概念特性"></a>概念特性</h4><ul>
<li>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</li>
<li>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</li>
</ul>
<h4 id="原子包java-util-concurrent-atomic-锁自旋"><a href="#原子包java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包java.util.concurrent.atomic(锁自旋)"></a>原子包java.util.concurrent.atomic(锁自旋)</h4><ul>
<li>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">        <span class="keyword">return</span> current; </span><br><span class="line"> 	&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul>
<li>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li>
<li>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li>
<li>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</li>
</ul>
<h2 id="什么是AQS-抽象的队列同步器"><a href="#什么是AQS-抽象的队列同步器" class="headerlink" title="什么是AQS(抽象的队列同步器)"></a>什么是AQS(抽象的队列同步器)</h2><ul>
<li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563360810227.png" alt="1563360810227"></p>
<ul>
<li>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br><strong>getState()，setState()，compareAndSetState()</strong>。</li>
<li>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li>
</ol>
</li>
</ul>
<h4 id="AQS资源共享方式"><a href="#AQS资源共享方式" class="headerlink" title="AQS资源共享方式"></a>AQS资源共享方式</h4><ul>
<li><strong>Exclusive独占资源-ReentrantLock</strong><ul>
<li>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</li>
</ul>
</li>
<li><strong>Share 共享资源-Semaphore/CountDownLatch</strong><ul>
<li>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</li>
</ul>
</li>
</ul>
<h4 id="同步器的实现ABS核心-state资源状态计数"><a href="#同步器的实现ABS核心-state资源状态计数" class="headerlink" title="同步器的实现ABS核心(state资源状态计数)"></a>同步器的实现ABS核心(state资源状态计数)</h4><ul>
<li>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</li>
</ul>
<h4 id="ReentrantReadWriteLock实现独占和共享两种方式"><a href="#ReentrantReadWriteLock实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock实现独占和共享两种方式"></a>ReentrantReadWriteLock实现独占和共享两种方式</h4><ul>
<li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java-并发/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>-java -并发</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/15/Collection总结/">
      Collection总结
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-15</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="/2019/07/15/Collection总结/%E9%9B%86%E5%90%88%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="集合架构图"></p>
<h2 id="图中大体概述"><a href="#图中大体概述" class="headerlink" title="图中大体概述"></a>图中大体概述</h2><ul>
<li>Iterator:可以通过迭代器遍历集合中的数据</li>
<li>Collection:是集合list,set,Queue的最基本的接口</li>
<li>Map：是映射表的基础接口</li>
</ul>
<h4 id="List接口详解"><a href="#List接口详解" class="headerlink" title="List接口详解"></a>List接口详解</h4><ul>
<li><p>List作为有序的Collection的代表，共有三个实现类，分别为<strong>ArrayList</strong>,<strong>LinkedList</strong>,<strong>Vector</strong>。</p>
</li>
<li><p><strong>ArrayList</strong></p>
<ul>
<li><p>内部是通过数组实现的，它允许对元素进行快速随机访问，缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中，当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制，移动，代价比较高，因此，它适合于随机查找与遍历，不适合插入和删除。</p>
<p><img src="/2019/07/15/Collection总结/1563183452932.png" alt="1563183452932"></p>
</li>
</ul>
</li>
<li><p><strong>LinkList</strong></p>
<ul>
<li><p>内部是双链表结构存储数据，适合数据的插入与删除，随机访问和遍历速度比较慢，此外，还提供了List接口中没有定义的方法，专门用于操作表头和表位元素，可以当作堆栈，队列和双向队列使用。</p>
<p><img src="/2019/07/15/Collection总结/1563183654460.png" alt="1563183654460"></p>
</li>
</ul>
</li>
<li><p><strong>Vector</strong></p>
<ul>
<li>与ArrayList一样，也是通过数组结构实现的，不同于它的是Vector支持线程的同步，避免多线程同时而引起的不一致性，但实现同步需要很高的花费，因此，效率不及ArrayList。</li>
</ul>
</li>
<li><p><strong>List简单总结</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层结构</th>
<th>优缺点</th>
<th>线程安全性</th>
<th>扩容</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>数组</td>
<td>查询快 ，插入/删除慢</td>
<td>不安全</td>
<td>当前容量*1.5+1</td>
</tr>
<tr>
<td>LinkList</td>
<td>双链表</td>
<td>插入/删除快，查找慢</td>
<td>不安全</td>
<td>———–</td>
</tr>
<tr>
<td>Vector</td>
<td>数组</td>
<td>查询快，插入/删除慢</td>
<td>安全</td>
<td>默认一倍扩容</td>
</tr>
</tbody></table>
<h4 id="Set集合详解"><a href="#Set集合详解" class="headerlink" title="Set集合详解"></a>Set集合详解</h4><ul>
<li><p>Set重视元素的唯一性，用于存储无序(存和取的顺序不一定相同)元素，值不能重复，根据对象的hashCode值进行判断的，如果想要让两个对象视为相等的，就必须覆盖Object的hashCode和equals方法。它的主要实现类：<strong>HashSet</strong>，<strong>TreeSet</strong>，<strong>LinkHashSet</strong>。</p>
</li>
<li><p><strong>HashSet</strong></p>
<ul>
<li>HashSet存储元素的顺序不是按照存入时的顺序，而是按照哈希值来存取数据的，元素的哈希值是通过元素的hashcode方法来获取的，HashSet首先会判断两个元素的哈希值，如果哈希值一样，再比较equals，如果equals相等就视为同一个元素，否则就不是同一个元素。</li>
<li>哈希值相同equals为false的元素的存储问题，当出现这种情况是会在相同的哈希值下顺延，也就是哈希一样的存一列，HashSet通过hashCode值来确定元素在内存中的位置，一个hashCode位置上可以存放多个元素。</li>
</ul>
</li>
<li><p><strong>TreeSet</strong></p>
<ul>
<li>TreeSet是使用二叉树对新add()的对象按照指定的顺序排序(升序，降序)，每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。</li>
<li>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序。</li>
<li>比较次对象与指定对象的顺序，如果该对象小于，等于或大于指定对象，则分别返回负整数，零或正整数。</li>
</ul>
</li>
<li><p><strong>LinkHashSet</strong></p>
<ul>
<li><p>LinkHashSet继承HashSet和LinkedHashMap来实现的，LinkedHashSet底层使用LinkHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层结构</th>
<th>优缺点</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>HashMap</td>
<td>存取快，排列无序，不可重复,可为null</td>
<td>不安全</td>
</tr>
<tr>
<td>TreeSet</td>
<td>二叉树</td>
<td>排列有序，不可重复</td>
<td>安全</td>
</tr>
<tr>
<td>LinkHashSet</td>
<td>Hash表+双向链表</td>
<td>排列有序，不可重复</td>
<td>不安全</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="Map集合详解"><a href="#Map集合详解" class="headerlink" title="Map集合详解"></a>Map集合详解</h4><ul>
<li><p><strong>HashMap</strong></p>
<ul>
<li>HashMap(1.7)是数组和链表的结合体，数组每个元素存的是链表的头结点，往hashmap里面放键值对的时候先得到key的hashcode，然后重新计算hashcode，然后与length-1按位与，计算数组下标1，如果该下标对应的链表为空，则直接把键值对作为链表头结点，如果不为空，则1遍历链表看是否有key值相同，有就把value替换，没有就把该对对象作为链表的第一个节点，原有的节点为它的后续节点。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/Inked1.7_LI.jpg" alt="Inked1.7_LI"></p>
<ul>
<li><p>HashMap(1.8)是数组+链表+红黑树，当链表长度&gt;=8时转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入，删除，查找等算法。</p>
<p><img src="/2019/07/15/Collection总结/1563193744210.png" alt="1563193744210"></p>
</li>
<li><p>HashMap扩容</p>
<ul>
<li>初始容量16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。</li>
<li>扩容机制：使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有的Entry数的元素拷贝到新的Entry数组中，Java1.7重新计算每个元素在数组中的位置，Java1.8中不是从新计算，而是使用的是2次幂的扩展，所以，元素的位置要么是在原来的位置，要么是在原位置再移动2次幂的位置在扩展HashMap的时候，不需要像1.7的实现那样重新计算hash，只需要看看原来的hash值新增加的那个bit是1还是0就行了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</li>
</ul>
</li>
<li><p>HashMap为什么线程不安全(hash碰撞和扩容导致)</p>
<ul>
<li>HashMap底层是一个Entry数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。加入A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</li>
<li>删除键值对的代码如上：当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写回到该数组位置去，其实写回的时候可能其他的线程已经把这个位置给修改过了，就会覆盖其他线程的修改当多个线程同时检测到总数量超过门限制的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有一个线程生成新的数组被赋给table变量，其他线程的均会丢失，而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</li>
<li>想要实现线程安全，那么就要调用collections类的静态方法<strong>synchronizeMap()</strong>实现</li>
</ul>
</li>
<li><p><strong>HashTable</strong></p>
<ul>
<li>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，<br>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，<br>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全<br>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</li>
</ul>
</li>
<li><p><strong>TreeMap</strong></p>
<ul>
<li>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，<br>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用 TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的<br>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</li>
</ul>
</li>
<li><p><strong>LinkedHashMap</strong></p>
<ul>
<li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历<br>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
</ul>
</li>
<li><p><strong>ConcurrentHashMap</strong></p>
<ul>
<li><p>Segment</p>
<ul>
<li>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一<br>些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的<br>意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个<br>segment。</li>
</ul>
</li>
<li><p>线程安全</p>
<ul>
<li>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承<br>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每<br>个 Segment 是线程安全的，也就实现了全局的线程安全。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/1563194323007.png" alt="1563194323007"></p>
</li>
<li><p>并行度</p>
<ul>
<li>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，<br>也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支<br>持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时<br>候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实<br>每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</li>
</ul>
</li>
<li><p>Java8实现</p>
<ul>
<li>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</li>
</ul>
<p><img src="/2019/07/15/Collection总结/1563194333363.png" alt="1563194333363"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>底层</th>
<th>优缺点</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td>
<td>key/value都可为null，查询快，递增排序</td>
<td>不安全</td>
</tr>
<tr>
<td>HashTable</td>
<td>散列表</td>
<td>key和Value都不可为null，递减排序</td>
<td>安全</td>
</tr>
<tr>
<td>TreeMap</td>
<td>红黑树</td>
<td>递增排序</td>
<td>不安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>1.8之前数组+链表/1.8之后数组+链表+红黑树</td>
<td>递增排序</td>
<td>安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>链表+哈希</td>
<td>存取一致</td>
<td>不安全</td>
</tr>
</tbody></table>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li><strong>Iterator和ListIterator的区别</strong><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li>
</ul>
</li>
<li><strong>快速失败(fail-fast)和安全失败(fail-safe)的区别</strong><ul>
<li>Iterator的安全失败是基于对底层集合做拷贝，因此，不受原集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下的所有类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全1失败的迭代器永远不会抛出这样的异常。</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/集合/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>集合</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/14/JVM-五-GC分析/">
      JVM(五)GC分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-14</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="Java-GC分析"><a href="#Java-GC分析" class="headerlink" title="Java GC分析"></a>Java GC分析</h2><h4 id="什么是Java-GC"><a href="#什么是Java-GC" class="headerlink" title="什么是Java GC"></a>什么是Java GC</h4><ul>
<li>Java GC(Garbage Collection,垃圾收集,垃圾回收)机制,是Java与C++/C的主要区别之一,作为Java开发者,不需要专门编写内存回收和垃圾清理代码,对内存泄露和溢出问题,这是因为在Java虚拟机中,存在自动内存管理和垃圾收集机制,该机制对JVM中的内存进行标记,并确定那些内存需要回收,根据一定的回收策略,自动的回收内存,永不停息的保证JVM中的内存空间,防止出现内存泄漏和溢出问题，Java GC机制已经日益完善，几乎可以自动的为我们做绝大多数事情，但是，如果开发大型的软件开发，就必须要研究Java GC机制。</li>
<li>简单总结下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。</li>
</ul>
<h4 id="如何获取Java-GC日志"><a href="#如何获取Java-GC日志" class="headerlink" title="如何获取Java GC日志"></a>如何获取Java GC日志</h4><ul>
<li><p><strong>命令获取Java GC日志</strong></p>
<ul>
<li>Java自动的工具行命令，jstat可以动态的监控JVM内存的使用，统计垃圾回收的各项信息。</li>
<li>如：<code>jstat -gc</code>统计垃圾回收堆的行为</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc.png" alt="gc"></p>
<ul>
<li>也可以设置时间打印(图中每100ms打印一次，共打印200次)</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gctime.png" alt="gctime"></p>
</li>
<li><p><strong>GC参数</strong></p>
<ul>
<li>JVM的GC日志的主要参数包括如下：<ul>
<li><code>-XX:+PrintGC</code>输出GC日志</li>
<li><code>-XX:+PrintGCDetails</code>输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX:+PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如2019-7-14T17:17:17.177+0800)</li>
<li><code>-XX:PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</li>
</ul>
</li>
<li>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</li>
</ul>
</li>
<li><p><strong>Tomcat配置示例</strong></p>
<ul>
<li>在Tomcat的启动参数中添加JVM的相关参数，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"><span class="string">-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"><span class="string">-Djava.awt.headless=true </span></span><br><span class="line"><span class="string">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"><span class="string">-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"><span class="string">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数概况<ul>
<li><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</li>
<li><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是<br>Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young<br>genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio<br>设置成比较大的值（比如65536)来做到。</li>
<li><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</li>
<li><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li>
<li><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code><br>设置gc日志的格式。</li>
<li><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔。</li>
<li><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代。</li>
</ul>
</li>
</ul>
<h4 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h4><ul>
<li>Young GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">18.093</span>+<span class="number">0800</span>: <span class="number">25.395</span>: [GC [PSYoungGen: <span class="number">274931</span>K-&gt;<span class="number">10738</span>K(<span class="number">274944</span>K)] <span class="number">371093</span>K-&gt;<span class="number">147186</span>K(<span class="number">450048</span>K), <span class="number">0.0668480</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.08</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li>Full GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">19.160</span>+<span class="number">0800</span>: <span class="number">25.462</span>: [Full GC [PSYoungGen: <span class="number">10738</span>K-&gt;<span class="number">0</span>K(<span class="number">274944</span>K)] [ParOldGen: <span class="number">136447</span>K-&gt;<span class="number">140379</span>K(<span class="number">302592</span>K)] <span class="number">147186</span>K-&gt;<span class="number">140379</span>K(<span class="number">577536</span>K) [PSPermGen: <span class="number">85411</span>K-&gt;<span class="number">85376</span>K(<span class="number">171008</span>K)], <span class="number">0.6763541</span> secs] [Times: user=<span class="number">1.75</span> sys=<span class="number">0.02</span>, real=<span class="number">0.68</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young<br>gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。</p>
</li>
<li><p>通过两张图非常明显看出GC日志构成：</p>
<ul>
<li>Young GC日志：</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/%E5%89%8D%E5%8D%8A%E6%AE%B5%E5%88%86%E6%9E%90.jpg" alt="前半段分析"></p>
<ul>
<li>Full GC日志：</li>
</ul>
</li>
</ul>
<p>![full GC_LI](JVM-五-GC分析/full GC_LI.jpg)</p>
</li>
</ul>
<h4 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h4><ul>
<li><p><strong>GChisto</strong></p>
<ul>
<li>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</li>
<li>配置好本地的jdk环境后，双击GChisto.jar，在弹出的输入框点击add选择gc.log日志。<br><img src="/2019/07/14/JVM-五-GC分析/gc1.jpg" alt="gc1"></li>
<li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc2.jpg" alt="gc2"></p>
<ul>
<li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p>
</li>
<li><p>GC Timeline：显示整个时间线上的垃圾收集<img src="/2019/07/14/JVM-五-GC分析/gc3.jpg" alt="gc3"></p>
</li>
<li><p>这款工具已经不再维护了。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/13/JVM-四-JVM优化/">
      JVM(四)JVM优化
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-13</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="常用的JVM优化工具介绍"><a href="#常用的JVM优化工具介绍" class="headerlink" title="常用的JVM优化工具介绍"></a>常用的JVM优化工具介绍</h2><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>​    JVM Process Status Tool,显式指定系统内所有的HotSpot虚拟机进程.</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jps [options] [hostid]</code></p>
</li>
<li><p><strong>option参数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l:输出主类全名或jar路径</span><br><span class="line">-q:只输出LVMID</span><br><span class="line">-m:输出JVM启动时传递给main()的参数</span><br><span class="line">-v:输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>演示</strong></p>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jps%E6%BC%94%E7%A4%BA.png" alt="jps演示"></p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>​    jstat(JVM statisics Monitoring)是用于监视虚拟机运行时状态信息的命令,可以显示出虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jstat [option] LVMID [interval] [count]</code></p>
</li>
<li><p><strong>参数</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option]:操作参数</span><br><span class="line"><span class="function"> LVMID:本地虚拟机进程<span class="title">ID</span></span></span><br><span class="line"><span class="function">[<span class="title">interval</span>]:连续输出的时间间隔</span></span><br><span class="line"><span class="function">[<span class="title">count</span>]:连续输出的次数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>option参数讲解</strong></p>
<ol>
<li>class:监视类加载,卸载数量,总空间以及耗费的时间</li>
</ol>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jstatclass.png" alt="jstatclass"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Loader:加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes:class</span>字节大小</span></span><br><span class="line"><span class="function"><span class="title">Unloaded</span>:未加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes</span>:未加载<span class="title">class</span>的字节大小</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:加载时间</span></span><br></pre></td></tr></table></figure>

<pre><code>2. compiler:输出JIT编译过的方法数量耗时等</code></pre><p><img src="/2019/07/13/JVM-四-JVM优化/compiler.png" alt="compiler"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compiled:编译数量</span></span><br><span class="line"><span class="function"><span class="title">Failed</span>:编译失败数量</span></span><br><span class="line"><span class="function"><span class="title">Invalid</span>:无效数量</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:编译耗时</span></span><br><span class="line"><span class="function"><span class="title">FailedType</span>:失败类型</span></span><br><span class="line"><span class="function"><span class="title">FailedMethod</span>:失败方法的全限定名</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>gc:垃圾回收堆的行为统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gc.png" alt="gc"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">PC 当前perm的容量 (KB)</span><br><span class="line">PU perm的使用 (KB)</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11660 5000 100</span><br><span class="line"><span class="meta">#</span> 每隔5000ms输出11660的gc情况,一共输出100次</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>gccapacity:与gc相同,不过还会输出Java堆各区域使用到的最大,最小空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccapacity.png" alt="gccapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>gcutil:同gc,不过输出的是已使用空间占总空间的百分比</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcutil.png" alt="gcutil"></p>
<ol start="6">
<li>gccause:垃圾收集统计概述,附加最近两次垃圾回收事件到的原因</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccause.png" alt="gccause"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LGCC:最近垃圾回收的原因</span></span><br><span class="line"><span class="function"><span class="title">GCC</span>:当前垃圾回收的原因</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>gcnew:统计新生代1的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnew.png" alt="gcnew"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>gcnewcapacity:新生代与其相应的内存空间的统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnewcapacity.png" alt="gcnewcapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NGC:当前年轻代的容量 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0CMX</span>:最大的<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0C</span>:当前<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">ECMX</span>:最大<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">EC</span>:当前<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>gcold:统计旧生代的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcold.png" alt="gcold"></p>
<ol start="10">
<li>gcoldcapacity:统计旧生代的大小和空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcoldcapacity.png" alt="gcoldcapacity"></p>
<ol start="11">
<li>printcompilation:hotspot编译方法统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/Snipaste_2019-07-13_16-55-48.png" alt="Snipaste_2019-07-13_16-55-48"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line"><span class="built_in">Type</span>：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure>

<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump : 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat : to <span class="built_in">print</span> permanent generation statistics</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<ol>
<li><p>dump常用格式</p>
<p><code>-dump::live,format=b,file=&lt;filename&gt; pid</code></p>
<p>dump堆到文件,format指定输出格式,live指是活着的对象,file指文件名</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/dump.png" alt="dump"></p>
<ol start="2">
<li>finalizerinfo:打印等待回收对象的信息</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/info.png" alt="info"></p>
<p>​    可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行的finalizer方法的对象</p>
<ol start="3">
<li><p>heap:打印heap的概要信息,GC使用的算法,heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">finalizerinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Number</span> <span class="title">of</span> <span class="title">objects</span> <span class="title">pending</span> <span class="title">for</span> <span class="title">finalization</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">heap</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">using</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">object</span> <span class="title">allocation</span>.</span></span><br><span class="line"><span class="function"><span class="title">Parallel</span> <span class="title">GC</span> <span class="title">with</span> 4 <span class="title">thread</span>(<span class="title">s</span>)	//<span class="title">GC</span>方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Configuration</span>:		//堆内存初始化配置</span></span><br><span class="line"><span class="function">   <span class="title">MinHeapFreeRatio</span>         = 0</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapFreeRatio</span>         = 100</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapSize</span>              = 734003200 (700.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewSize</span>                  = 44564480 (42.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxNewSize</span>               = 244318208 (233.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">OldSize</span>                  = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewRatio</span>                 = 2</span></span><br><span class="line"><span class="function">   <span class="title">SurvivorRatio</span>            = 8</span></span><br><span class="line"><span class="function">   <span class="title">MetaspaceSize</span>            = 21807104 (20.796875<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">CompressedClassSpaceSize</span> = 1073741824 (1024.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxMetaspaceSize</span>         = 17592186044415 <span class="title">MB</span></span></span><br><span class="line"><span class="function">   <span class="title">G1HeapRegionSize</span>         = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Usage</span>:			//堆内存使用情况</span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Young</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function"><span class="title">Eden</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 34078720 (32.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 19266416 (18.373886108398438<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 14812304 (14.126113891601562<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   56.5350341796875% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">From</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 4417480 (4.212837219238281<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 825400 (0.7871627807617188<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   84.25674438476562% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.0% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Old</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 90128 (0.0859527587890625<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 89563120 (85.41404724121094<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.10052954244334796% <span class="title">used</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5507 <span class="title">interned</span> <span class="title">Strings</span> <span class="title">occupying</span> 497712 <span class="title">bytes</span>.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>histo:打印堆的对象统计,包括对象数,内存大小等等</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/histo.png" alt="histo"></p>
<h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>​    jhat命令是与jmap搭配使用,用来分析jmap生成的dump,jhat内置了一个微型的HTTP/HTML服务器,生成dump的分析结果后,可以在浏览器中查看,在此需要注意,一般不会直接在服务器上进行分析,因为jhat是一个耗时并且耗费硬件资源的过程,一般把服务器生成的dump文件复制到本地或其他机器上进行分析.</p>
<ul>
<li><p>命令格式</p>
<p><code>jhat [dumpfile]</code></p>
</li>
<li><p>参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line"></span><br><span class="line">-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line"></span><br><span class="line">-port port-number 设置 jhat HTTP server 的端口号. 默认值 <span class="number">7000</span>.&gt;</span><br><span class="line"></span><br><span class="line">-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line"></span><br><span class="line">-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as <span class="keyword">not</span> being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line"></span><br><span class="line">-debug int 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line"></span><br><span class="line">-version 启动后只显示版本信息就退出&gt;</span><br><span class="line"></span><br><span class="line">-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<p>​    第一步:导出堆</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">dump:live</span>,<span class="title">file</span>=<span class="title">a.map</span> 11660</span></span><br><span class="line"><span class="function"><span class="title">Dumping</span> <span class="title">heap</span> <span class="title">to</span> <span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">a.map</span> ...</span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">dump</span> <span class="title">file</span> <span class="title">created</span></span></span><br></pre></td></tr></table></figure>

<p>​    第二步:分析堆文件</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jhat</span> <span class="title">a.map</span></span></span><br><span class="line"><span class="function"><span class="title">Reading</span> <span class="title">from</span> <span class="title">a.map</span>...</span></span><br><span class="line"><span class="function"><span class="title">Dump</span> <span class="title">file</span> <span class="title">created</span> <span class="title">Sat</span> <span class="title">Jul</span> 13 18:51:20 <span class="title">CST</span> 2019</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">read</span>, <span class="title">resolving</span>...</span></span><br><span class="line"><span class="function"><span class="title">Resolving</span> 2299776 <span class="title">objects</span>...</span></span><br><span class="line"><span class="function"><span class="title">Chasing</span> <span class="title">references</span>, <span class="title">expect</span> 459 <span class="title">dots</span>.............................</span></span><br><span class="line"><span class="function"><span class="title">Eliminating</span> <span class="title">duplicate</span> <span class="title">references</span>.........................</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">resolved</span>.</span></span><br><span class="line"><span class="function"><span class="title">Started</span> <span class="title">HTTP</span> <span class="title">server</span> <span class="title">on</span> <span class="title">port</span> 7000</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>.</span></span><br></pre></td></tr></table></figure>

<p>​    第三步:查看HTML</p>
<p><img src="/2019/07/13/JVM-四-JVM优化/1563015344059.png" alt="1563015344059"></p>
</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>​    jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native<br>stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java<br>stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。    </p>
<ul>
<li><p>命令格式</p>
<p><code>jstack [option] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jstack</span> -<span class="title">l</span> 11660|<span class="title">more</span></span></span><br><span class="line"><span class="function">2019-07-13 18:58:09</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">OpenJDK</span> 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (25.152-<span class="title">b11</span> <span class="title">mixed</span> <span class="title">mode</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 216" #550 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7ba000</span> <span class="title">nid</span>=0<span class="title">x1d5c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005dbef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.getTask</span>(<span class="title">ThreadPoolExecutor.java</span>:1066)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.runWorker</span>(<span class="title">ThreadPoolExecutor.java</span>:1127)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor</span>$<span class="title">Worker.run</span>(<span class="title">ThreadPoolExecutor.java</span>:617)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">Thread.java</span>:745)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">Locked</span> <span class="title">ownable</span> <span class="title">synchronizers</span>:</span></span><br><span class="line"><span class="function">        - <span class="title">None</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 215" #549 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7c0000</span> <span class="title">nid</span>=0<span class="title">x3b44</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005daef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">-- <span class="title">More</span>  --</span></span><br></pre></td></tr></table></figure>

<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>​    jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
</li>
<li><p>命令格式</p>
<p><code>jinfo [option] [args] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">System</span> <span class="title">Properties</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">java.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">preload.project.path</span> = <span class="title">D</span>:/<span class="title">code</span>/<span class="title">IdeaProjects</span>/<span class="title">JVM</span></span></span><br><span class="line"><span class="function"><span class="title">sun.java.launcher</span> = <span class="title">SUN_STANDARD</span></span></span><br><span class="line"><span class="function"><span class="title">idea.config.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span></span></span><br><span class="line"><span class="function"><span class="title">sun.management.compiler</span> = <span class="title">HotSpot</span> 64-<span class="title">Bit</span> <span class="title">Tiered</span> <span class="title">Compilers</span></span></span><br><span class="line"><span class="function"><span class="title">sun.nio.ch.bugLevel</span> =</span></span><br><span class="line"><span class="function"><span class="title">idea.paths.selector</span> = <span class="title">IntelliJIdea2017</span>.3</span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.client.alive.path</span> = "<span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">AppData</span>\<span class="title">Local</span>\<span class="title">Temp</span>\<span class="title">kotlin</span>-<span class="title">idea</span>-4516842704025065651-<span class="title">is</span>-<span class="title">running</span>"</span></span><br><span class="line"><span class="function"><span class="title">os.name</span> = <span class="title">Windows</span> 10</span></span><br><span class="line"><span class="function"><span class="title">sun.boot.class.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">resources.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">rt.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">sunrsasign.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jsse.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jce.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">charsets.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jfr.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">classes</span></span></span><br><span class="line"><span class="function"><span class="title">sun.desktop</span> = <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">idea.plugins.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span>\<span class="title">plugins</span></span></span><br><span class="line"><span class="function"><span class="title">java.vm.specification.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">java.runtime.version</span> = 1.8.0<span class="title">_102</span>-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">io.netty.serviceThreadPrefix</span> = <span class="title">Netty</span></span></span><br><span class="line"><span class="function"><span class="title">user.name</span> = 严茂</span></span><br><span class="line"><span class="function"><span class="title">kotlin.incremental.compilation</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">idea.home.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">JetBrains</span>\<span class="title">IntelliJ</span> <span class="title">IDEA</span> 2017.3.4</span></span><br><span class="line"><span class="function"><span class="title">user.language</span> = <span class="title">zh</span></span></span><br><span class="line"><span class="function"><span class="title">jdt.compiler.useSingleThread</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">sun.boot.library.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">bin</span></span></span><br><span class="line"><span class="function"><span class="title">java.version</span> = 1.8.0<span class="title">_102</span></span></span><br><span class="line"><span class="function"><span class="title">user.timezone</span> = <span class="title">Asia</span>/<span class="title">Shanghai</span></span></span><br><span class="line"><span class="function"><span class="title">java.net.preferIPv4Stack</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.enabled</span> =</span></span><br><span class="line"><span class="function"><span class="title">sun.arch.data.model</span> = 64</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/12/JVM-三-GC算法-垃圾收集器/">
      JVM(三)GC算法-垃圾收集器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-12</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    垃圾收集通常被称之为”<strong>GC</strong>“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生成,随线程的销毁而销毁,栈帧随着方法的进入和退出做入栈和出栈操作,实现了自动的内存清理,因此,内存垃圾回收主要集中在java堆和方法区中,在程序运行期间,这部分的内存的分配和使用1都是动态的.</p>
<h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活一般有两种方式.</p>
<ul>
<li><p><strong>引用计数</strong>:每个对象有一个计数属性,新增一个引用时计数加1,引用释放时计数减1,计数为0时可以回收,此方法简单,无法解决对象相互循环引用的问题.</p>
</li>
<li><p><strong>可达性分析</strong>:从GC Roots开始向下搜寻,搜寻所走过的路径称之为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明对象是不可用的,不可达对象.</p>
</li>
<li><p>在Java中,GC Roots包括:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性实体引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li>
</ul>
</li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    <strong>标记-清除</strong>算法分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象,之所以说它是最基础的收集算法,是因为后续的收集算法都是基于这种思路并对其缺点进行改善而得到的.</p>
<p>​    它主要有两个缺点:<strong>一是效率问题</strong>,标记和清除过程的效率都不高,<strong>二是空间问题</strong>,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致,当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作.</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​    GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>​    “<strong>分代收集</strong>”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    如果说收集算法是内存回收的方法论,垃圾收集器就是内存回收的具体实现</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>​    串行收集器是最稳定,效率最高的收集器,可能会产生较长的停顿,只使用一个线程去回收,新生代,老年代使用串行回收;新生代复制算法,老年代标记-压缩;垃圾收集的过程中会服务暂停.</p>
<p>参数控制:<code>-XX:+UseSerialGC</code>串行收集器</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="串行收集器"></p>
<p>​    ParNew收集器ParNew收集器就是Serial收集器的多线程版本,新生代并行,老年代串行;新生代复制算法,老年代标记-压缩.</p>
<p>参数控制:</p>
<ul>
<li><p><code>-XX:+UseParNewGC</code>ParNew收集器</p>
</li>
<li><p><code>-XX:ParallelGCThreads</code>限制线程数量</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt="串行收集器2"></p>
</li>
</ul>
<h4 id="Paralle收集器"><a href="#Paralle收集器" class="headerlink" title="Paralle收集器"></a>Paralle收集器</h4><p>​    Parallel   Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>​    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>​    从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>​        其中初始标记、重新标记这两个步骤仍然需要“Stop  The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>​    由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p>​    <strong>优点</strong>: 并发收集、低停顿<br>​    <strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制:</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）    </p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/CMS.jpg" alt="CMS"></p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>​    G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：</p>
<ul>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ul>
<p>​        上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/G1.jpg" alt="G1"></p>
<p>​    G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent  Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young  GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE2.png" alt="图2"></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE3.png" alt="图3"></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%A4%8D%E5%88%B6%E6%B8%85%E9%99%A4.jpg" alt="复制清除"></p>
<h4 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h4><table>
<thead>
<tr>
<th></th>
<th>新生代GC策略</th>
<th>老年代GC策略</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>组合1</td>
<td>Serial</td>
<td>Serial Old</td>
<td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
</tr>
<tr>
<td>组合2</td>
<td>Serial</td>
<td>CMS+Serial Old</td>
<td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td>
</tr>
<tr>
<td>组合3</td>
<td>ParNew</td>
<td>CMS</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 <code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td>
</tr>
<tr>
<td>组合4</td>
<td>ParNew</td>
<td>Serial Old</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td>
</tr>
<tr>
<td>组合5</td>
<td>Parallel Scavenge</td>
<td>Serial Old</td>
<td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td>组合6</td>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td align="left">Parallel Old是Serial Old的并行版本</td>
</tr>
<tr>
<td>组合7</td>
<td>G1GC</td>
<td>G1GC</td>
<td align="left"><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code> #暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code> #暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小； <code>-XX:SurvivorRatio=6</code> #幸存区比例</td>
</tr>
</tbody></table>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/11/JVM-二-java类的加载机制/">
      JVM(二)java类的加载机制
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-11</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h3 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1. 什么是类加载"></a>1. 什么是类加载</h3><ul>
<li>类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个<strong>java.lang.Class</strong>对象,用来封装类在方法区内的数据结构,类的加载的最终是位于堆中的<strong>Class对象</strong>,Class对象封装了类在方法区的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口.</li>
<li>类加载器并不需要等到某个类被初次主动使用时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件异常问题,类加载器必须在程序首次主动使用该类时才报告错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误.</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p>
<ul>
<li>加载.class文件的方式<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip,jar等文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
</li>
</ul>
<h3 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类的加载过程"></h3><ul>
<li>一个java类的完整生命周期会经历<strong>加载,连接,初始化,使用和卸载</strong>五个阶段,其中,加载,验证,准备和初始化这四个阶段发生的顺序是确定的,但解析阶段则不一定,在某些情况下可以在初始化阶段之后开始,这是为了支持Java的运行时绑定.此外还需要注意这里的几个阶段是按顺序开始的,而不是按顺序进行或完成,因为这些阶段通常都是互相交叉混合进行的,通常在一个阶段执行的过程中调用或激活另一个阶段.</li>
<li><strong>加载</strong><ul>
<li>查找并加载类的二进制数据是类加载过程的第一个阶段,在加载阶段,虚拟机需要完成以下三件事.<ul>
<li>通过一个类的全限定类名来获取其定义的二进制字节流.</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象,作为对方法区中这些数据的访问入口.</li>
</ul>
</li>
<li>相对于类加载的其他阶段而言,加载阶段是可控性最强的阶段,因此开发者即可以使用系统提供的类加载器来完成加载,也可以自定义自己的类加载器来完成加载.</li>
<li>加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象,这样便可以通过该对象访问方法区中的这些数据.</li>
</ul>
</li>
<li><strong>连接</strong><ul>
<li><strong>验证:确保被加载的类的正确性.</strong><ul>
<li>验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全,验证阶段大致会完成4个阶段的检验动作.<ul>
<li><strong>文件格式验证</strong>:验证字节流是否符合Class文件格式的规范,如:是否以<code>0xCAFEBABE</code>开头,主次版本号是否在当前虚拟机的处理范围之内,常量池中的常量是否有不被支持的阶段.</li>
<li><strong>元数据验证</strong>:对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求;如:这个类是否有父类,除了<code>java.lang.Object</code>之外的.</li>
<li><strong>字节码验证</strong>:通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的.</li>
<li><strong>符号引用验证</strong>:确保解析动作能正确执行.</li>
</ul>
</li>
<li>验证阶段是非常重要的,但不是必须的,它对程序运行期没有影响,如果所引用的类经过反复验证,那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间.</li>
</ul>
</li>
<li><strong>准备:为类的静态变量分配内存,并将其初始化为默认值</strong><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配,对于该阶段的注意事项.<ul>
<li>这时进行内存分配的仅包括类变量(static),而不包括实例变量,实例变量会在对象实例化时随着对象一块分配在Java堆中.</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如:0,0L,null,false等等),而不是被在Java代码中被显式地赋予的值.</li>
<li>如果类字节地字段属性表中存在<code>ConstantValue</code>属性,即同时被final和static修饰,那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值.</li>
</ul>
</li>
</ul>
</li>
<li><strong>解析:把类中的符号引用转换为直接引用</strong><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用进行,符号引用就是一组符号来描述目标,可以是任何字面量.</li>
<li>直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄.</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>初始化,为类的静态变量赋予正确的初始值,JVM负责对类进行初始化,主要对类变量进行初始化,在Java中对类变量进行初始值设定有两种方式.<ul>
<li>声明类变量是指定初始化</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</li>
<li>JVM初始化步骤<ul>
<li>加入这个类还没有被加载和连接,则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被1初始化,则先加载其直接父类</li>
<li>假如类中有初始化语句,则系统依次执行这些初始化语句</li>
</ul>
</li>
<li>类初始化时机:只有当对类的主动使用的时候才会导致类的初始化,类的主动使用包括以下六种<ul>
<li>创建类的实例,也就是new的方法</li>
<li>访问某个类或接口的静态变量,或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化某个类的子类,则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类,直接使用java.exe命令来运行某个主类.</li>
</ul>
</li>
</ul>
</li>
<li><strong>结束生命周期</strong><ul>
<li>在这几种情况下,Java虚拟机将结束生命周期<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>先看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">     System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到,没有获取到ExtClassLoader的父Loader,原因是Bootstrap Loadder是用C写的,找不到一个确定的返回父Loader的方法,于是就返回null.</p>
<ul>
<li>类加载器的层次关系图</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="类加载器"></p>
<ul>
<li><strong>启动类加载器</strong>:负责加载存放在<code>JDK/jre/lib</code>下,或被<code>-Xbootclasspath</code>参数指定的路径中的,并且能被虚拟机识别的类库,启动类加载器是无法被Java程序直接引用的.</li>
<li><strong>扩展类加载器</strong>:该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,他负责加载<code>JDK/jre/lib/ext</code>目录中,或者由<code>java.ext.dirs</code>系统变量指定的路径中的所由类库,开发者可以直接使用扩展类加载器.</li>
<li><strong>应用程序类加载器</strong>:该类加载器由<code>sun.misc.Launcher#AppClassLoader</code>来实现,它负责加载用户类路径所指定的类,开发者可以直接使用该类加载器,如果程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器.</li>
</ul>
<h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><ul>
<li><strong>全盘负责</strong>:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Classs也将由该类加载器负责载入,除非显式使用另外一个类加载器来载入.</li>
<li><strong>父类委派</strong>:先让父类加载器试图加载该类,只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类.</li>
<li><strong>缓存机制</strong>:缓存价值将会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,只有缓存区不存在,系统才会读取该类对应的二进制数据,并将其转换为Class对象,存入缓存区,这就是为什么修改Class后,必须重启JVM,程序的修改才会生效.</li>
</ul>
<h3 id="4-类的加载"><a href="#4-类的加载" class="headerlink" title="4. 类的加载"></a>4. 类的加载</h3><ul>
<li>类的加载有三种方式<ul>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2", false, loader); </span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块执行了);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>:将类的.class文件加载到JVM中之外1,还会对类进行解释,执行类中的static块.</li>
<li><code>ClassLoader.loadClass()</code>:只干一件事,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newlnstance才会去执行static块</li>
<li><code>Class.forName(name,initialize,loader)带参函数也可以控制是否加载static块,并且只有调用newInstance()方法采用调用构造函数,创建类的对象</code>.</li>
</ul>
<h3 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h3><ul>
<li>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>双亲委派机制<ul>
<li>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li>
</ul>
</li>
<li>双亲委派模型意义<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
</li>
</ul>
<h3 id="6-自定义类加载器"><a href="#6-自定义类加载器" class="headerlink" title="6. 自定义类加载器"></a>6. 自定义类加载器</h3><ul>
<li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输<br>Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classData = loadClassData(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.ym.jvm.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意<ul>
<li>这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的.</li>
<li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式.</li>
<li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载.</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        <div class="prev-next">
          
          <p class="current">
            1 / 2
          </p>
          
            <a class="next" rel="next" href="/categories/java/page/2/">
              <section class="post next">
                &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
              </section>
            </a>
          
        </div>
      </div>

    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(18)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 19px; color: #777">java编程思想</a> <a href="/tags/jvm/" style="font-size: 21.5px; color: #666">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 19px; color: #777">多线程</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16.5px; color: #888">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="" target="_blank" class="codename">Hello World</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
