<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Tag: jvm | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/14/JVM-五-GC分析/">
      JVM(五)GC分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-14</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="Java-GC分析"><a href="#Java-GC分析" class="headerlink" title="Java GC分析"></a>Java GC分析</h2><h4 id="什么是Java-GC"><a href="#什么是Java-GC" class="headerlink" title="什么是Java GC"></a>什么是Java GC</h4><ul>
<li>Java GC(Garbage Collection,垃圾收集,垃圾回收)机制,是Java与C++/C的主要区别之一,作为Java开发者,不需要专门编写内存回收和垃圾清理代码,对内存泄露和溢出问题,这是因为在Java虚拟机中,存在自动内存管理和垃圾收集机制,该机制对JVM中的内存进行标记,并确定那些内存需要回收,根据一定的回收策略,自动的回收内存,永不停息的保证JVM中的内存空间,防止出现内存泄漏和溢出问题，Java GC机制已经日益完善，几乎可以自动的为我们做绝大多数事情，但是，如果开发大型的软件开发，就必须要研究Java GC机制。</li>
<li>简单总结下，Java GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。</li>
</ul>
<h4 id="如何获取Java-GC日志"><a href="#如何获取Java-GC日志" class="headerlink" title="如何获取Java GC日志"></a>如何获取Java GC日志</h4><ul>
<li><p><strong>命令获取Java GC日志</strong></p>
<ul>
<li>Java自动的工具行命令，jstat可以动态的监控JVM内存的使用，统计垃圾回收的各项信息。</li>
<li>如：<code>jstat -gc</code>统计垃圾回收堆的行为</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc.png" alt="gc"></p>
<ul>
<li>也可以设置时间打印(图中每100ms打印一次，共打印200次)</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gctime.png" alt="gctime"></p>
</li>
<li><p><strong>GC参数</strong></p>
<ul>
<li>JVM的GC日志的主要参数包括如下：<ul>
<li><code>-XX:+PrintGC</code>输出GC日志</li>
<li><code>-XX:+PrintGCDetails</code>输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>输出GC的时间戳(以基准时间的形式)</li>
<li><code>-XX:+PrintGCDateStamps</code>输出GC的时间戳(以日期的形式，如2019-7-14T17:17:17.177+0800)</li>
<li><code>-XX:PrintHeapAtGC</code>在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code>日志文件的输出路径</li>
</ul>
</li>
<li>在生产环境中，根据需要配置相应的参数来监控JVM运行情况</li>
</ul>
</li>
<li><p><strong>Tomcat配置示例</strong></p>
<ul>
<li>在Tomcat的启动参数中添加JVM的相关参数，如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4</span></span><br><span class="line"><span class="string">-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log </span></span><br><span class="line"><span class="string">-Djava.awt.headless=true </span></span><br><span class="line"><span class="string">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span></span><br><span class="line"><span class="string">-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</span></span><br><span class="line"><span class="string">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数概况<ul>
<li><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</li>
<li><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是<br>Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young<br>genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio<br>设置成比较大的值（比如65536)来做到。</li>
<li><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</li>
<li><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</li>
<li><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code><br>设置gc日志的格式。</li>
<li><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔。</li>
<li><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代。</li>
</ul>
</li>
</ul>
<h4 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h4><ul>
<li>Young GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">18.093</span>+<span class="number">0800</span>: <span class="number">25.395</span>: [GC [PSYoungGen: <span class="number">274931</span>K-&gt;<span class="number">10738</span>K(<span class="number">274944</span>K)] <span class="number">371093</span>K-&gt;<span class="number">147186</span>K(<span class="number">450048</span>K), <span class="number">0.0668480</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.08</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li>Full GC回收日志</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">7</span>-<span class="number">014</span>T17:<span class="number">37</span>:<span class="number">19.160</span>+<span class="number">0800</span>: <span class="number">25.462</span>: [Full GC [PSYoungGen: <span class="number">10738</span>K-&gt;<span class="number">0</span>K(<span class="number">274944</span>K)] [ParOldGen: <span class="number">136447</span>K-&gt;<span class="number">140379</span>K(<span class="number">302592</span>K)] <span class="number">147186</span>K-&gt;<span class="number">140379</span>K(<span class="number">577536</span>K) [PSPermGen: <span class="number">85411</span>K-&gt;<span class="number">85376</span>K(<span class="number">171008</span>K)], <span class="number">0.6763541</span> secs] [Times: user=<span class="number">1.75</span> sys=<span class="number">0.02</span>, real=<span class="number">0.68</span> secs]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young<br>gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数。</p>
</li>
<li><p>通过两张图非常明显看出GC日志构成：</p>
<ul>
<li>Young GC日志：</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/%E5%89%8D%E5%8D%8A%E6%AE%B5%E5%88%86%E6%9E%90.jpg" alt="前半段分析"></p>
<ul>
<li>Full GC日志：</li>
</ul>
</li>
</ul>
<p>![full GC_LI](JVM-五-GC分析/full GC_LI.jpg)</p>
</li>
</ul>
<h4 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h4><ul>
<li><p><strong>GChisto</strong></p>
<ul>
<li>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</li>
<li>配置好本地的jdk环境后，双击GChisto.jar，在弹出的输入框点击add选择gc.log日志。<br><img src="/2019/07/14/JVM-五-GC分析/gc1.jpg" alt="gc1"></li>
<li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li>
</ul>
<p><img src="/2019/07/14/JVM-五-GC分析/gc2.jpg" alt="gc2"></p>
<ul>
<li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p>
</li>
<li><p>GC Timeline：显示整个时间线上的垃圾收集<img src="/2019/07/14/JVM-五-GC分析/gc3.jpg" alt="gc3"></p>
</li>
<li><p>这款工具已经不再维护了。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/13/JVM-四-JVM优化/">
      JVM(四)JVM优化
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-13</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="常用的JVM优化工具介绍"><a href="#常用的JVM优化工具介绍" class="headerlink" title="常用的JVM优化工具介绍"></a>常用的JVM优化工具介绍</h2><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>​    JVM Process Status Tool,显式指定系统内所有的HotSpot虚拟机进程.</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jps [options] [hostid]</code></p>
</li>
<li><p><strong>option参数</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l:输出主类全名或jar路径</span><br><span class="line">-q:只输出LVMID</span><br><span class="line">-m:输出JVM启动时传递给main()的参数</span><br><span class="line">-v:输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>演示</strong></p>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jps%E6%BC%94%E7%A4%BA.png" alt="jps演示"></p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>​    jstat(JVM statisics Monitoring)是用于监视虚拟机运行时状态信息的命令,可以显示出虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据</p>
<ul>
<li><p><strong>命令格式</strong></p>
<p><code>jstat [option] LVMID [interval] [count]</code></p>
</li>
<li><p><strong>参数</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[option]:操作参数</span><br><span class="line"><span class="function"> LVMID:本地虚拟机进程<span class="title">ID</span></span></span><br><span class="line"><span class="function">[<span class="title">interval</span>]:连续输出的时间间隔</span></span><br><span class="line"><span class="function">[<span class="title">count</span>]:连续输出的次数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>option参数讲解</strong></p>
<ol>
<li>class:监视类加载,卸载数量,总空间以及耗费的时间</li>
</ol>
</li>
</ul>
<p><img src="/2019/07/13/JVM-四-JVM优化/jstatclass.png" alt="jstatclass"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Loader:加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes:class</span>字节大小</span></span><br><span class="line"><span class="function"><span class="title">Unloaded</span>:未加载<span class="title">class</span>的数量</span></span><br><span class="line"><span class="function"><span class="title">Bytes</span>:未加载<span class="title">class</span>的字节大小</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:加载时间</span></span><br></pre></td></tr></table></figure>

<pre><code>2. compiler:输出JIT编译过的方法数量耗时等</code></pre><p><img src="/2019/07/13/JVM-四-JVM优化/compiler.png" alt="compiler"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compiled:编译数量</span></span><br><span class="line"><span class="function"><span class="title">Failed</span>:编译失败数量</span></span><br><span class="line"><span class="function"><span class="title">Invalid</span>:无效数量</span></span><br><span class="line"><span class="function"><span class="title">Time</span>:编译耗时</span></span><br><span class="line"><span class="function"><span class="title">FailedType</span>:失败类型</span></span><br><span class="line"><span class="function"><span class="title">FailedMethod</span>:失败方法的全限定名</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>gc:垃圾回收堆的行为统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gc.png" alt="gc"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S0C : survivor0区的总容量</span><br><span class="line">S1C : survivor1区的总容量</span><br><span class="line">S0U : survivor0区已使用的容量</span><br><span class="line">S1C : survivor1区已使用的容量</span><br><span class="line">EC : Eden区的总容量</span><br><span class="line">EU : Eden区已使用的容量</span><br><span class="line">OC : Old区的总容量</span><br><span class="line">OU : Old区已使用的容量</span><br><span class="line">PC 当前perm的容量 (KB)</span><br><span class="line">PU perm的使用 (KB)</span><br><span class="line">YGC : 新生代垃圾回收次数</span><br><span class="line">YGCT : 新生代垃圾回收时间</span><br><span class="line">FGC : 老年代垃圾回收次数</span><br><span class="line">FGCT : 老年代垃圾回收时间</span><br><span class="line">GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 11660 5000 100</span><br><span class="line"><span class="meta">#</span> 每隔5000ms输出11660的gc情况,一共输出100次</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>gccapacity:与gc相同,不过还会输出Java堆各区域使用到的最大,最小空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccapacity.png" alt="gccapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NGCMN : 新生代占用的最小空间</span><br><span class="line">NGCMX : 新生代占用的最大空间</span><br><span class="line">OGCMN : 老年代占用的最小空间</span><br><span class="line">OGCMX : 老年代占用的最大空间</span><br><span class="line">OGC：当前年老代的容量 (KB)</span><br><span class="line">OC：当前年老代的空间 (KB)</span><br><span class="line">PGCMN : perm占用的最小空间</span><br><span class="line">PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>gcutil:同gc,不过输出的是已使用空间占总空间的百分比</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcutil.png" alt="gcutil"></p>
<ol start="6">
<li>gccause:垃圾收集统计概述,附加最近两次垃圾回收事件到的原因</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gccause.png" alt="gccause"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LGCC:最近垃圾回收的原因</span></span><br><span class="line"><span class="function"><span class="title">GCC</span>:当前垃圾回收的原因</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>gcnew:统计新生代1的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnew.png" alt="gcnew"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TT：Tenuring threshold(提升阈值)</span><br><span class="line">MTT：最大的tenuring threshold</span><br><span class="line">DSS：survivor区域大小 (KB)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>gcnewcapacity:新生代与其相应的内存空间的统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcnewcapacity.png" alt="gcnewcapacity"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NGC:当前年轻代的容量 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0CMX</span>:最大的<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">S0C</span>:当前<span class="title">S0</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">ECMX</span>:最大<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br><span class="line"><span class="function"><span class="title">EC</span>:当前<span class="title">eden</span>空间 (<span class="title">KB</span>)</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>gcold:统计旧生代的行为</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcold.png" alt="gcold"></p>
<ol start="10">
<li>gcoldcapacity:统计旧生代的大小和空间</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/gcoldcapacity.png" alt="gcoldcapacity"></p>
<ol start="11">
<li>printcompilation:hotspot编译方法统计</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/Snipaste_2019-07-13_16-55-48.png" alt="Snipaste_2019-07-13_16-55-48"></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Compiled：被执行的编译任务的数量</span><br><span class="line">Size：方法字节码的字节数</span><br><span class="line"><span class="built_in">Type</span>：编译类型</span><br><span class="line">Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</span><br></pre></td></tr></table></figure>

<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul>
<li><p>命令格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dump : 生成堆转储快照</span><br><span class="line">finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">heap : 显示Java堆详细信息</span><br><span class="line">histo : 显示堆中对象的统计信息</span><br><span class="line">permstat : to <span class="built_in">print</span> permanent generation statistics</span><br><span class="line">F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<ol>
<li><p>dump常用格式</p>
<p><code>-dump::live,format=b,file=&lt;filename&gt; pid</code></p>
<p>dump堆到文件,format指定输出格式,live指是活着的对象,file指文件名</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/dump.png" alt="dump"></p>
<ol start="2">
<li>finalizerinfo:打印等待回收对象的信息</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/info.png" alt="info"></p>
<p>​    可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行的finalizer方法的对象</p>
<ol start="3">
<li><p>heap:打印heap的概要信息,GC使用的算法,heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">finalizerinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Number</span> <span class="title">of</span> <span class="title">objects</span> <span class="title">pending</span> <span class="title">for</span> <span class="title">finalization</span>: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">heap</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">using</span> <span class="title">thread</span>-<span class="title">local</span> <span class="title">object</span> <span class="title">allocation</span>.</span></span><br><span class="line"><span class="function"><span class="title">Parallel</span> <span class="title">GC</span> <span class="title">with</span> 4 <span class="title">thread</span>(<span class="title">s</span>)	//<span class="title">GC</span>方式</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Configuration</span>:		//堆内存初始化配置</span></span><br><span class="line"><span class="function">   <span class="title">MinHeapFreeRatio</span>         = 0</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapFreeRatio</span>         = 100</span></span><br><span class="line"><span class="function">   <span class="title">MaxHeapSize</span>              = 734003200 (700.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewSize</span>                  = 44564480 (42.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxNewSize</span>               = 244318208 (233.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">OldSize</span>                  = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">NewRatio</span>                 = 2</span></span><br><span class="line"><span class="function">   <span class="title">SurvivorRatio</span>            = 8</span></span><br><span class="line"><span class="function">   <span class="title">MetaspaceSize</span>            = 21807104 (20.796875<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">CompressedClassSpaceSize</span> = 1073741824 (1024.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">MaxMetaspaceSize</span>         = 17592186044415 <span class="title">MB</span></span></span><br><span class="line"><span class="function">   <span class="title">G1HeapRegionSize</span>         = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">Usage</span>:			//堆内存使用情况</span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Young</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function"><span class="title">Eden</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 34078720 (32.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 19266416 (18.373886108398438<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 14812304 (14.126113891601562<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   56.5350341796875% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">From</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 4417480 (4.212837219238281<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 825400 (0.7871627807617188<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   84.25674438476562% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">To</span> <span class="title">Space</span>:</span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 0 (0.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 5242880 (5.0<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.0% <span class="title">used</span></span></span><br><span class="line"><span class="function"><span class="title">PS</span> <span class="title">Old</span> <span class="title">Generation</span></span></span><br><span class="line"><span class="function">   <span class="title">capacity</span> = 89653248 (85.5<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">used</span>     = 90128 (0.0859527587890625<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   <span class="title">free</span>     = 89563120 (85.41404724121094<span class="title">MB</span>)</span></span><br><span class="line"><span class="function">   0.10052954244334796% <span class="title">used</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5507 <span class="title">interned</span> <span class="title">Strings</span> <span class="title">occupying</span> 497712 <span class="title">bytes</span>.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>histo:打印堆的对象统计,包括对象数,内存大小等等</p>
</li>
</ol>
<p><img src="/2019/07/13/JVM-四-JVM优化/histo.png" alt="histo"></p>
<h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>​    jhat命令是与jmap搭配使用,用来分析jmap生成的dump,jhat内置了一个微型的HTTP/HTML服务器,生成dump的分析结果后,可以在浏览器中查看,在此需要注意,一般不会直接在服务器上进行分析,因为jhat是一个耗时并且耗费硬件资源的过程,一般把服务器生成的dump文件复制到本地或其他机器上进行分析.</p>
<ul>
<li><p>命令格式</p>
<p><code>jhat [dumpfile]</code></p>
</li>
<li><p>参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line"></span><br><span class="line">-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line"></span><br><span class="line">-port port-number 设置 jhat HTTP server 的端口号. 默认值 <span class="number">7000</span>.&gt;</span><br><span class="line"></span><br><span class="line">-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line"></span><br><span class="line">-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as <span class="keyword">not</span> being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line"></span><br><span class="line">-debug int 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line"></span><br><span class="line">-version 启动后只显示版本信息就退出&gt;</span><br><span class="line"></span><br><span class="line">-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<p>​    第一步:导出堆</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jmap</span> -<span class="title">dump:live</span>,<span class="title">file</span>=<span class="title">a.map</span> 11660</span></span><br><span class="line"><span class="function"><span class="title">Dumping</span> <span class="title">heap</span> <span class="title">to</span> <span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">a.map</span> ...</span></span><br><span class="line"><span class="function"><span class="title">Heap</span> <span class="title">dump</span> <span class="title">file</span> <span class="title">created</span></span></span><br></pre></td></tr></table></figure>

<p>​    第二步:分析堆文件</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jhat</span> <span class="title">a.map</span></span></span><br><span class="line"><span class="function"><span class="title">Reading</span> <span class="title">from</span> <span class="title">a.map</span>...</span></span><br><span class="line"><span class="function"><span class="title">Dump</span> <span class="title">file</span> <span class="title">created</span> <span class="title">Sat</span> <span class="title">Jul</span> 13 18:51:20 <span class="title">CST</span> 2019</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">read</span>, <span class="title">resolving</span>...</span></span><br><span class="line"><span class="function"><span class="title">Resolving</span> 2299776 <span class="title">objects</span>...</span></span><br><span class="line"><span class="function"><span class="title">Chasing</span> <span class="title">references</span>, <span class="title">expect</span> 459 <span class="title">dots</span>.............................</span></span><br><span class="line"><span class="function"><span class="title">Eliminating</span> <span class="title">duplicate</span> <span class="title">references</span>.........................</span></span><br><span class="line"><span class="function"><span class="title">Snapshot</span> <span class="title">resolved</span>.</span></span><br><span class="line"><span class="function"><span class="title">Started</span> <span class="title">HTTP</span> <span class="title">server</span> <span class="title">on</span> <span class="title">port</span> 7000</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>.</span></span><br></pre></td></tr></table></figure>

<p>​    第三步:查看HTML</p>
<p><img src="/2019/07/13/JVM-四-JVM优化/1563015344059.png" alt="1563015344059"></p>
</li>
</ul>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>​    jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。<br>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native<br>stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java<br>stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。    </p>
<ul>
<li><p>命令格式</p>
<p><code>jstack [option] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jstack</span> -<span class="title">l</span> 11660|<span class="title">more</span></span></span><br><span class="line"><span class="function">2019-07-13 18:58:09</span></span><br><span class="line"><span class="function"><span class="title">Full</span> <span class="title">thread</span> <span class="title">dump</span> <span class="title">OpenJDK</span> 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> (25.152-<span class="title">b11</span> <span class="title">mixed</span> <span class="title">mode</span>):</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 216" #550 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7ba000</span> <span class="title">nid</span>=0<span class="title">x1d5c</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005dbef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.getTask</span>(<span class="title">ThreadPoolExecutor.java</span>:1066)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor.runWorker</span>(<span class="title">ThreadPoolExecutor.java</span>:1127)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.ThreadPoolExecutor</span>$<span class="title">Worker.run</span>(<span class="title">ThreadPoolExecutor.java</span>:617)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.lang.Thread.run</span>(<span class="title">Thread.java</span>:745)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="title">Locked</span> <span class="title">ownable</span> <span class="title">synchronizers</span>:</span></span><br><span class="line"><span class="function">        - <span class="title">None</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"<span class="title">ApplicationImpl</span> <span class="title">pooled</span> <span class="title">thread</span> 215" #549 <span class="title">daemon</span> <span class="title">prio</span>=4 <span class="title">os_prio</span>=-1 <span class="title">tid</span>=0<span class="title">x000000001e7c0000</span> <span class="title">nid</span>=0<span class="title">x3b44</span> <span class="title">waiting</span> <span class="title">on</span> <span class="title">condition</span> [0<span class="title">x000000005daef000</span>]</span></span><br><span class="line"><span class="function">   <span class="title">java.lang.Thread.State</span>: <span class="title">TIMED_WAITING</span> (<span class="title">parking</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">sun.misc.Unsafe.park</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line"><span class="function">        - <span class="title">parking</span> <span class="title">to</span> <span class="title">wait</span> <span class="title">for</span>  &lt;0<span class="title">x0000000094cc54b8</span>&gt; (<span class="title">a</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack</span>)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.locks.LockSupport.parkNanos</span>(<span class="title">LockSupport.java</span>:215)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.awaitFulfill</span>(<span class="title">SynchronousQueue.java</span>:460)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue</span>$<span class="title">TransferStack.transfer</span>(<span class="title">SynchronousQueue.java</span>:362)</span></span><br><span class="line"><span class="function">        <span class="title">at</span> <span class="title">java.util.concurrent.SynchronousQueue.poll</span>(<span class="title">SynchronousQueue.java</span>:941)</span></span><br><span class="line"><span class="function">-- <span class="title">More</span>  --</span></span><br></pre></td></tr></table></figure>

<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>​    jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
</li>
<li><p>命令格式</p>
<p><code>jinfo [option] [args] LVMID</code></p>
</li>
<li><p>option参数</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-flag : 输出指定args参数的值</span><br><span class="line">-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示</p>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\严茂&gt;<span class="title">jinfo</span> 13788</span></span><br><span class="line"><span class="function"><span class="title">Attaching</span> <span class="title">to</span> <span class="title">process</span> <span class="title">ID</span> 13788, <span class="title">please</span> <span class="title">wait</span>...</span></span><br><span class="line"><span class="function"><span class="title">Debugger</span> <span class="title">attached</span> <span class="title">successfully</span>.</span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">compiler</span> <span class="title">detected</span>.</span></span><br><span class="line"><span class="function"><span class="title">JVM</span> <span class="title">version</span> <span class="title">is</span> 25.102-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">System</span> <span class="title">Properties</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">java.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">preload.project.path</span> = <span class="title">D</span>:/<span class="title">code</span>/<span class="title">IdeaProjects</span>/<span class="title">JVM</span></span></span><br><span class="line"><span class="function"><span class="title">sun.java.launcher</span> = <span class="title">SUN_STANDARD</span></span></span><br><span class="line"><span class="function"><span class="title">idea.config.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span></span></span><br><span class="line"><span class="function"><span class="title">sun.management.compiler</span> = <span class="title">HotSpot</span> 64-<span class="title">Bit</span> <span class="title">Tiered</span> <span class="title">Compilers</span></span></span><br><span class="line"><span class="function"><span class="title">sun.nio.ch.bugLevel</span> =</span></span><br><span class="line"><span class="function"><span class="title">idea.paths.selector</span> = <span class="title">IntelliJIdea2017</span>.3</span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.client.alive.path</span> = "<span class="title">C</span>:\<span class="title">Users</span>\严茂\<span class="title">AppData</span>\<span class="title">Local</span>\<span class="title">Temp</span>\<span class="title">kotlin</span>-<span class="title">idea</span>-4516842704025065651-<span class="title">is</span>-<span class="title">running</span>"</span></span><br><span class="line"><span class="function"><span class="title">os.name</span> = <span class="title">Windows</span> 10</span></span><br><span class="line"><span class="function"><span class="title">sun.boot.class.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">resources.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">rt.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">sunrsasign.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jsse.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jce.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">charsets.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">lib</span>\<span class="title">jfr.jar</span>;<span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">classes</span></span></span><br><span class="line"><span class="function"><span class="title">sun.desktop</span> = <span class="title">windows</span></span></span><br><span class="line"><span class="function"><span class="title">idea.plugins.path</span> = <span class="title">C</span>:\<span class="title">Users</span>\严茂\.<span class="title">IntelliJIdea2017</span>.3\<span class="title">config</span>\<span class="title">plugins</span></span></span><br><span class="line"><span class="function"><span class="title">java.vm.specification.vendor</span> = <span class="title">Oracle</span> <span class="title">Corporation</span></span></span><br><span class="line"><span class="function"><span class="title">java.runtime.version</span> = 1.8.0<span class="title">_102</span>-<span class="title">b14</span></span></span><br><span class="line"><span class="function"><span class="title">io.netty.serviceThreadPrefix</span> = <span class="title">Netty</span></span></span><br><span class="line"><span class="function"><span class="title">user.name</span> = 严茂</span></span><br><span class="line"><span class="function"><span class="title">kotlin.incremental.compilation</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">idea.home.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">JetBrains</span>\<span class="title">IntelliJ</span> <span class="title">IDEA</span> 2017.3.4</span></span><br><span class="line"><span class="function"><span class="title">user.language</span> = <span class="title">zh</span></span></span><br><span class="line"><span class="function"><span class="title">jdt.compiler.useSingleThread</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">sun.boot.library.path</span> = <span class="title">C</span>:\<span class="title">Program</span> <span class="title">Files</span>\<span class="title">Java</span>\<span class="title">jdk1</span>.8.0<span class="title">_102</span>\<span class="title">jre</span>\<span class="title">bin</span></span></span><br><span class="line"><span class="function"><span class="title">java.version</span> = 1.8.0<span class="title">_102</span></span></span><br><span class="line"><span class="function"><span class="title">user.timezone</span> = <span class="title">Asia</span>/<span class="title">Shanghai</span></span></span><br><span class="line"><span class="function"><span class="title">java.net.preferIPv4Stack</span> = <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">kotlin.daemon.enabled</span> =</span></span><br><span class="line"><span class="function"><span class="title">sun.arch.data.model</span> = 64</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/12/JVM-三-GC算法-垃圾收集器/">
      JVM(三)GC算法-垃圾收集器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-12</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    垃圾收集通常被称之为”<strong>GC</strong>“,在jvm内,程序计数器,虚拟机栈,本地地方法栈都是随线程的生成而生成,随线程的销毁而销毁,栈帧随着方法的进入和退出做入栈和出栈操作,实现了自动的内存清理,因此,内存垃圾回收主要集中在java堆和方法区中,在程序运行期间,这部分的内存的分配和使用1都是动态的.</p>
<h2 id="对象存活的判断"><a href="#对象存活的判断" class="headerlink" title="对象存活的判断"></a>对象存活的判断</h2><p>判断对象是否存活一般有两种方式.</p>
<ul>
<li><p><strong>引用计数</strong>:每个对象有一个计数属性,新增一个引用时计数加1,引用释放时计数减1,计数为0时可以回收,此方法简单,无法解决对象相互循环引用的问题.</p>
</li>
<li><p><strong>可达性分析</strong>:从GC Roots开始向下搜寻,搜寻所走过的路径称之为引用链,当一个对象到GC Roots没有任何引用链相连时,则证明对象是不可用的,不可达对象.</p>
</li>
<li><p>在Java中,GC Roots包括:</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性实体引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2></li>
</ul>
</li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>​    <strong>标记-清除</strong>算法分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象,在标记完成后统一回收掉所有被标记的对象,之所以说它是最基础的收集算法,是因为后续的收集算法都是基于这种思路并对其缺点进行改善而得到的.</p>
<p>​    它主要有两个缺点:<strong>一是效率问题</strong>,标记和清除过程的效率都不高,<strong>二是空间问题</strong>,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致,当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另外一次垃圾收集动作.</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​    GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>​    “<strong>分代收集</strong>”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>​    如果说收集算法是内存回收的方法论,垃圾收集器就是内存回收的具体实现</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>​    串行收集器是最稳定,效率最高的收集器,可能会产生较长的停顿,只使用一个线程去回收,新生代,老年代使用串行回收;新生代复制算法,老年代标记-压缩;垃圾收集的过程中会服务暂停.</p>
<p>参数控制:<code>-XX:+UseSerialGC</code>串行收集器</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="串行收集器"></p>
<p>​    ParNew收集器ParNew收集器就是Serial收集器的多线程版本,新生代并行,老年代串行;新生代复制算法,老年代标记-压缩.</p>
<p>参数控制:</p>
<ul>
<li><p><code>-XX:+UseParNewGC</code>ParNew收集器</p>
</li>
<li><p><code>-XX:ParallelGCThreads</code>限制线程数量</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt="串行收集器2"></p>
</li>
</ul>
<h4 id="Paralle收集器"><a href="#Paralle收集器" class="headerlink" title="Paralle收集器"></a>Paralle收集器</h4><p>​    Parallel   Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>​    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>​    CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>​    从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>​        其中初始标记、重新标记这两个步骤仍然需要“Stop  The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots  Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>​    由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p>​    <strong>优点</strong>: 并发收集、低停顿<br>​    <strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制:</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）    </p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/CMS.jpg" alt="CMS"></p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>​    G1是目前技术发展的最前沿成果之一,与CMS收集器相比G1收集器有以下特点：</p>
<ul>
<li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
</li>
<li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
</li>
</ul>
<p>​        上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/G1.jpg" alt="G1"></p>
<p>​    G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p>
<p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p>
<p>3、Concurrent  Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young  GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE2.png" alt="图2"></p>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p>
<p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%9B%BE3.png" alt="图3"></p>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<p><img src="/2019/07/12/JVM-三-GC算法-垃圾收集器/%E5%A4%8D%E5%88%B6%E6%B8%85%E9%99%A4.jpg" alt="复制清除"></p>
<h4 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h4><table>
<thead>
<tr>
<th></th>
<th>新生代GC策略</th>
<th>老年代GC策略</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>组合1</td>
<td>Serial</td>
<td>Serial Old</td>
<td align="left">Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
</tr>
<tr>
<td>组合2</td>
<td>Serial</td>
<td>CMS+Serial Old</td>
<td align="left">CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td>
</tr>
<tr>
<td>组合3</td>
<td>ParNew</td>
<td>CMS</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项 <code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td>
</tr>
<tr>
<td>组合4</td>
<td>ParNew</td>
<td>Serial Old</td>
<td align="left">使用 <code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td>
</tr>
<tr>
<td>组合5</td>
<td>Parallel Scavenge</td>
<td>Serial Old</td>
<td align="left">Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr>
<td>组合6</td>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td align="left">Parallel Old是Serial Old的并行版本</td>
</tr>
<tr>
<td>组合7</td>
<td>G1GC</td>
<td>G1GC</td>
<td align="left"><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code> #暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code> #暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小； <code>-XX:SurvivorRatio=6</code> #幸存区比例</td>
</tr>
</tbody></table>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/11/JVM-二-java类的加载机制/">
      JVM(二)java类的加载机制
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-11</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h3 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1. 什么是类加载"></a>1. 什么是类加载</h3><ul>
<li>类加载指的是将类的.class文件中的二进制数据读入到内存中,将其放在运行时数据区的方法区内,然后在堆区创建一个<strong>java.lang.Class</strong>对象,用来封装类在方法区内的数据结构,类的加载的最终是位于堆中的<strong>Class对象</strong>,Class对象封装了类在方法区的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口.</li>
<li>类加载器并不需要等到某个类被初次主动使用时再加载它,JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件异常问题,类加载器必须在程序首次主动使用该类时才报告错误,如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误.</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD.jpg" alt="类加载"></p>
<ul>
<li>加载.class文件的方式<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip,jar等文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
</li>
</ul>
<h3 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类的加载过程"></h3><ul>
<li>一个java类的完整生命周期会经历<strong>加载,连接,初始化,使用和卸载</strong>五个阶段,其中,加载,验证,准备和初始化这四个阶段发生的顺序是确定的,但解析阶段则不一定,在某些情况下可以在初始化阶段之后开始,这是为了支持Java的运行时绑定.此外还需要注意这里的几个阶段是按顺序开始的,而不是按顺序进行或完成,因为这些阶段通常都是互相交叉混合进行的,通常在一个阶段执行的过程中调用或激活另一个阶段.</li>
<li><strong>加载</strong><ul>
<li>查找并加载类的二进制数据是类加载过程的第一个阶段,在加载阶段,虚拟机需要完成以下三件事.<ul>
<li>通过一个类的全限定类名来获取其定义的二进制字节流.</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象,作为对方法区中这些数据的访问入口.</li>
</ul>
</li>
<li>相对于类加载的其他阶段而言,加载阶段是可控性最强的阶段,因此开发者即可以使用系统提供的类加载器来完成加载,也可以自定义自己的类加载器来完成加载.</li>
<li>加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中,而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象,这样便可以通过该对象访问方法区中的这些数据.</li>
</ul>
</li>
<li><strong>连接</strong><ul>
<li><strong>验证:确保被加载的类的正确性.</strong><ul>
<li>验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全,验证阶段大致会完成4个阶段的检验动作.<ul>
<li><strong>文件格式验证</strong>:验证字节流是否符合Class文件格式的规范,如:是否以<code>0xCAFEBABE</code>开头,主次版本号是否在当前虚拟机的处理范围之内,常量池中的常量是否有不被支持的阶段.</li>
<li><strong>元数据验证</strong>:对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言规范的要求;如:这个类是否有父类,除了<code>java.lang.Object</code>之外的.</li>
<li><strong>字节码验证</strong>:通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的.</li>
<li><strong>符号引用验证</strong>:确保解析动作能正确执行.</li>
</ul>
</li>
<li>验证阶段是非常重要的,但不是必须的,它对程序运行期没有影响,如果所引用的类经过反复验证,那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施,以缩短虚拟机类加载的时间.</li>
</ul>
</li>
<li><strong>准备:为类的静态变量分配内存,并将其初始化为默认值</strong><ul>
<li>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配,对于该阶段的注意事项.<ul>
<li>这时进行内存分配的仅包括类变量(static),而不包括实例变量,实例变量会在对象实例化时随着对象一块分配在Java堆中.</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如:0,0L,null,false等等),而不是被在Java代码中被显式地赋予的值.</li>
<li>如果类字节地字段属性表中存在<code>ConstantValue</code>属性,即同时被final和static修饰,那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值.</li>
</ul>
</li>
</ul>
</li>
<li><strong>解析:把类中的符号引用转换为直接引用</strong><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符7类符号引用进行,符号引用就是一组符号来描述目标,可以是任何字面量.</li>
<li>直接引用就是直接指向目标的指针,相对偏移量或一个间接定位到目标的句柄.</li>
</ul>
</li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>初始化,为类的静态变量赋予正确的初始值,JVM负责对类进行初始化,主要对类变量进行初始化,在Java中对类变量进行初始值设定有两种方式.<ul>
<li>声明类变量是指定初始化</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
</li>
<li>JVM初始化步骤<ul>
<li>加入这个类还没有被加载和连接,则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被1初始化,则先加载其直接父类</li>
<li>假如类中有初始化语句,则系统依次执行这些初始化语句</li>
</ul>
</li>
<li>类初始化时机:只有当对类的主动使用的时候才会导致类的初始化,类的主动使用包括以下六种<ul>
<li>创建类的实例,也就是new的方法</li>
<li>访问某个类或接口的静态变量,或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化某个类的子类,则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类,直接使用java.exe命令来运行某个主类.</li>
</ul>
</li>
</ul>
</li>
<li><strong>结束生命周期</strong><ul>
<li>在这几种情况下,Java虚拟机将结束生命周期<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>先看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">     System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4554617</span>c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>可以看到,没有获取到ExtClassLoader的父Loader,原因是Bootstrap Loadder是用C写的,找不到一个确定的返回父Loader的方法,于是就返回null.</p>
<ul>
<li>类加载器的层次关系图</li>
</ul>
<p><img src="/2019/07/11/JVM-二-java类的加载机制/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="类加载器"></p>
<ul>
<li><strong>启动类加载器</strong>:负责加载存放在<code>JDK/jre/lib</code>下,或被<code>-Xbootclasspath</code>参数指定的路径中的,并且能被虚拟机识别的类库,启动类加载器是无法被Java程序直接引用的.</li>
<li><strong>扩展类加载器</strong>:该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现,他负责加载<code>JDK/jre/lib/ext</code>目录中,或者由<code>java.ext.dirs</code>系统变量指定的路径中的所由类库,开发者可以直接使用扩展类加载器.</li>
<li><strong>应用程序类加载器</strong>:该类加载器由<code>sun.misc.Launcher#AppClassLoader</code>来实现,它负责加载用户类路径所指定的类,开发者可以直接使用该类加载器,如果程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器.</li>
</ul>
<h4 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h4><ul>
<li><strong>全盘负责</strong>:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Classs也将由该类加载器负责载入,除非显式使用另外一个类加载器来载入.</li>
<li><strong>父类委派</strong>:先让父类加载器试图加载该类,只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类.</li>
<li><strong>缓存机制</strong>:缓存价值将会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,只有缓存区不存在,系统才会读取该类对应的二进制数据,并将其转换为Class对象,存入缓存区,这就是为什么修改Class后,必须重启JVM,程序的修改才会生效.</li>
</ul>
<h3 id="4-类的加载"><a href="#4-类的加载" class="headerlink" title="4. 类的加载"></a>4. 类的加载</h3><ul>
<li>类的加载有三种方式<ul>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line">                <span class="comment">//Class.forName("Test2", false, loader); </span></span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块执行了);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>:将类的.class文件加载到JVM中之外1,还会对类进行解释,执行类中的static块.</li>
<li><code>ClassLoader.loadClass()</code>:只干一件事,就是将.class文件加载到jvm中,不会执行static中的内容,只有在newlnstance才会去执行static块</li>
<li><code>Class.forName(name,initialize,loader)带参函数也可以控制是否加载static块,并且只有调用newInstance()方法采用调用构造函数,创建类的对象</code>.</li>
</ul>
<h3 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h3><ul>
<li>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li>
<li>双亲委派机制<ul>
<li>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li>
</ul>
</li>
<li>双亲委派模型意义<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
</li>
</ul>
<h3 id="6-自定义类加载器"><a href="#6-自定义类加载器" class="headerlink" title="6. 自定义类加载器"></a>6. 自定义类加载器</h3><ul>
<li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输<br>Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 <code>ClassLoader</code>类，从上面对 <code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classData = loadClassData(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.ym.jvm.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意<ul>
<li>这里传递的文件名需要是类的全限定性名称，即 <code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的.</li>
<li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式.</li>
<li>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把 <code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 <code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载.</li>
</ul>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/07/11/JVM-一-内存结构/">
      JVM(一)内存结构
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-11</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1562826662961.jpg" alt="jvm内存结构"></p>
<p>​    JVM内存结构主要有三大块:<strong>堆内存</strong>,<strong>方法区</strong>和<strong>栈</strong></p>
<p>​    <strong>堆内存</strong>是JVM内存中最大的一块区域,由年轻代和老年代组成,而年轻代由可分为三部分,EdenSpace,FromSpace,ToSpace,默认情况下三者比例为8:1:1的比例.</p>
<p>​    <strong>方法区</strong>存储类信息,常量,静态变量等数据,是线程共享的区域.</p>
<p>​    <strong>栈</strong>又可以分为java虚拟机栈和本地方法栈主要用于方法的执行</p>
<h3 id="2-JVM内存区域分配"><a href="#2-JVM内存区域分配" class="headerlink" title="2.JVM内存区域分配"></a>2.JVM内存区域分配</h3><p><img src="/2019/07/11/JVM-一-内存结构/jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1562827418260.jpg" alt="jvm内存分配"></p>
<ul>
<li>图中控制参数说明<ul>
<li>-Xmx:设置堆内存的最大值</li>
<li>-Xms:设置堆内存的最小值</li>
<li>-XX:MaxNewSize:设置新生代内存的最大值</li>
<li>-XX:NewSize:设置新生代内存的最小值</li>
<li>-XX:MaxPermSize:设置永久代内存的最大值</li>
<li>-XX:PermSize:设置永久代内存的最小值</li>
<li>-Xss:设置每个线程的堆栈大小</li>
</ul>
</li>
</ul>
<h3 id="3-JVM与系统之间调用关系"><a href="#3-JVM与系统之间调用关系" class="headerlink" title="3. JVM与系统之间调用关系"></a>3. JVM与系统之间调用关系</h3><p><img src="/2019/07/11/JVM-一-内存结构/JVM%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1562828203417.jpg" alt="JVM与系统调用"></p>
<ul>
<li>方法区,堆属于所有线程间所共享的,而栈,程序计数器是属于线程私有的.</li>
<li><strong>java堆</strong><ul>
<li>对于大多数应用来说,java堆是java虚拟机所管理的内存中最大的一块,java堆是所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.</li>
<li>java堆时垃圾收集器管理的主要区域,因此很多时候也被称之为”<strong>GC堆</strong>“.</li>
<li>java堆可以位于物理上不连续的内存空间中,只要逻辑上时连续的即可</li>
<li>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出<strong>OutOfMemoryError</strong>异常.</li>
</ul>
</li>
<li><strong>方法区</strong><ul>
<li>与java堆一样,是各个线程间共享的内存区域,它主要用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.</li>
<li>方法区与java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾回收.(垃圾回收在方法区出现的频率很小)</li>
<li>当方法区无法满足内存分配需求时,将抛出<strong>OutOfMemoryError</strong>异常.</li>
<li>方法区的执行都是随着线程的,原始类型的本地变量以及引用都存放在线程栈中,而引用关联的对象,都存在堆中.</li>
</ul>
</li>
<li><strong>程序计数器</strong><ul>
<li>程序计数器是一块较小的内存空间,它的作用可以看作是当前线程所执行的字节码的信号指示器,在虚拟机的概念模型中字节码解释器工作时就是通过改变这个计时器的值来选取下一条需要执行的字节码指令,分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成.</li>
<li>由于java虚拟机的多线程是通过线程切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器只会执行一条独立的程序计数器,各条线程之间的1计数器互不影响,独立存储,我们称这种内存区域为”线程私有”的内存.</li>
<li>如果线程正在执行的是一个java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址,如果正在执行的是Natvie方法,这个计数器值则为空.</li>
</ul>
</li>
<li><strong>JVM栈</strong><ul>
<li>同程序计数器,java虚拟机栈也是线程私有的,<strong>它的生命周期与线程一样,虚拟机描述的是java方法执行的内存模型</strong>,每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表,朝左栈,动态链接,方法出口等信息.<strong>每一个方法被调用直至执行完成的过程,就对应着一个栈帧在虚拟机中从入栈到出栈的过程.</strong></li>
<li>局部变量表存放了编译器可知的各种基本类型数据类型,对象引用(reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)</li>
<li>在java虚拟机规范中,对这个区域规定了两种异常状况,如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<strong>StackOverFlowError</strong>异常,如果虚拟机可以动态的扩展,当扩展时无法申请到足够的内存时会抛出<strong>OutOfMemoryError</strong>异常.</li>
</ul>
</li>
<li><strong>本地方法栈</strong><ul>
<li>本地方法栈与虚拟机栈所发挥的作用时非常相似的,区别不过时虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的Native方法服务,虚拟机规范中对本地方法栈中的方法使用的语言,使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由的实现它.</li>
<li>与虚拟机栈一样,本地方法栈区域也会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常</li>
</ul>
</li>
</ul>
<h3 id="4-使用JConsole查看java的相关信息"><a href="#4-使用JConsole查看java的相关信息" class="headerlink" title="4. 使用JConsole查看java的相关信息."></a>4. 使用JConsole查看java的相关信息.</h3><ul>
<li><p>找到%JAVA_HOME%\bin目录<img src="/2019/07/11/JVM-一-内存结构/javahome.png" alt="javahome"></p>
</li>
<li><p>执行cmd,输入jconsole命令,将会打开JConsole面板.<img src="/2019/07/11/JVM-一-内存结构/Jconsole.png" alt="Jconsole"></p>
</li>
<li><p>选择你要查看的进程点击连接,成功后如下.<img src="/2019/07/11/JVM-一-内存结构/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="控制面板"></p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/jvm/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>jvm</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Categories</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java-java编程思想-读书笔记/" href="/categories/java-java编程思想-读书笔记/"><div class='name'>java - java编程思想 - 读书笔记</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(25)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/java/java编程思想/" href="/categories/java/java编程思想/"><div class='name'>java编程思想</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/java/java编程思想/读书笔记/" href="/categories/java/java编程思想/读书笔记/"><div class='name'>读书笔记</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 22px; color: #636363">java编程思想</a> <a href="/tags/jvm/" style="font-size: 20px; color: #707070">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 18px; color: #7e7e7e">多线程</a> <a href="/tags/字符串/" style="font-size: 14px; color: #999">字符串</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/异常/" style="font-size: 14px; color: #999">异常</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/数组/" style="font-size: 14px; color: #999">数组</a> <a href="/tags/枚举/" style="font-size: 14px; color: #999">枚举</a> <a href="/tags/泛型/" style="font-size: 14px; color: #999">泛型</a> <a href="/tags/注解/" style="font-size: 14px; color: #999">注解</a> <a href="/tags/类型信息/" style="font-size: 14px; color: #999">类型信息</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16px; color: #8b8b8b">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="" target="_blank" class="codename">Hello World</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
