<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Java并发补充 | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/07/16/Java并发补充/">
        Java并发补充
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-07-16</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><ul>
<li><p>线程池做的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量超出数量的线程排队等候</strong>，等其他线程执行完毕，再从队列中取出任务来执行，他的主要特点为：<strong>线程复用，控制最大并发数，管理线程</strong>。</p>
</li>
<li><p><strong>线程复用</strong></p>
<ul>
<li>每一个Thread的类都有一个start()方法，当调用start()启动线程时Java虚拟机会调用该类的run()方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。<strong>我们可以继承重写Thread类，在其start()方法中添加不断循环调用传递过来的Runnable对象</strong>。这就是线程池的实现原理。<strong>循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的</strong>。</li>
</ul>
</li>
<li><p><strong>线程池的组成</strong></p>
<ul>
<li>一般的线程池主要分为4个组成部分<ul>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程：线程池中的线程。</li>
<li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行。</li>
<li>任务队列：用于存放处理的任务，提供一种缓冲机制。</li>
</ul>
</li>
<li>Java中的线程池1是通过Executor实现的。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563331336349.png" alt="1563331336349"></p>
<ul>
<li><code>ThreadPoolExecutor</code>中的构造方法<ul>
<li><code>corePoolSize</code>：指定了线程池中的线程数量。</li>
<li><code>maximumPoolSize</code>:指定了线程池中的最大线程数量。</li>
<li><code>keepAliveTime</code>：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</li>
<li><code>utnit</code>:keepAliveTime的单位。</li>
<li><code>workQueue</code>:任务队列，被提交但尚未被执行的任务。</li>
<li><code>threadFactory</code>:线程工厂，用于创建线程，一般使用默认值。</li>
<li><code>handler</code>:拒绝策略，当任务太多来不及处理，如何拒绝任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<span class="keyword">this</span>(corePoolSize,maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>拒绝策略</strong></p>
<ul>
<li>线程池中的线程已经用完，无法继续为新任务服务，同时，等待队列也已经排满，再也塞不下新的任务，这时我们就需要拒绝策略机制合理的处理这个问题。</li>
<li>JDK内置的拒绝策略如下：<ul>
<li><code>AbortPolicy</code>:直接抛出异常，阻止系统正常运行。</li>
<li><code>CallerRunsPolicy</code>:只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>
<li><code>DiscardOldestPolicy</code>:丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li><code>DiscardPolicy</code>:该策略默默地丢弃无法处理的任务，不予任何处理，如果允许任务丢失，这是最好的一种方案。</li>
<li>上述内置拒绝策略实现了<code>RejectedExecutionHandler</code>接口，若以上策略仍无法满足实际需要，完全可以自己扩展<code>RejectedExecutionHandler</code>接口。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程池工作过程</strong></p>
<ol>
<li>线程池刚创建时，里面没有一个线程，任务队列是作为参数传递进来的，不过，就算队列里面有任务，线程池也不会马上执行它们。</li>
<li>当调用execute()方法添加一个任务时，线程池会做以下判断：<ol>
<li>如果正在运行的线程数小于<code>corePoolSize</code>，那么马上创建线程运行这个队列。</li>
<li>如果正在运行的线程数大于或等于<code>corePoolSize</code>,那么将这个任务放入队列。</li>
<li>如果这时队列满了，而且正在运行的线程数小于<code>maximumPoolSize</code>，那么还要创建非核心线程立即运行这个任务。</li>
<li>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>,那么线程池会抛出异常<code>RejectExecutionException</code>。</li>
</ol>
</li>
<li>当一个线程完成任务时，他会从队列中取出下一个任务来执行。</li>
<li>当一个线程无事可做时，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>，那么这个线程就被停掉，所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code>的大小。</li>
</ol>
</li>
</ul>
<h2 id="Java阻塞队列原理"><a href="#Java阻塞队列原理" class="headerlink" title="Java阻塞队列原理"></a>Java阻塞队列原理</h2><ul>
<li><p>在阻塞队列中，线程阻塞分为两种情况。</p>
<ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞(挂起)，直到有数据放入队列。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336228088.png" alt="1563336228088"></p>
<ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞(挂起)，直到队列中有空的位置，线程被自动唤醒。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563336249697.png" alt="1563336249697"></p>
</li>
</ul>
<h4 id="阻塞队列主要方法"><a href="#阻塞队列主要方法" class="headerlink" title="阻塞队列主要方法"></a>阻塞队列主要方法</h4><table>
<thead>
<tr>
<th>方法类型</th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：抛出一个异常。</li>
<li>特殊值：返回一个特殊值(null或false，视情况而定)。</li>
<li>阻塞：在成功操作之前，一直阻塞线程。</li>
<li>超时：放弃前只在最大的时间内阻塞。</li>
</ul>
<ul>
<li><p><strong>插入操作</strong></p>
<ul>
<li><code>public abstract boolean add(E paramE)</code>:将指定元素插入到此队列中(如果立即可行且不会违反容量限制)，成功时返回true,如果当前没有可用的空间，则抛出<code>IllegalStateException</code>.如果该元素是NULL，则会抛出<code>NullPointerException</code>异常。</li>
<li><code>public abstract boolean offer(E paramE)</code>:将指定元素插入此队列中(如果立即可行且不会违反容量限制)，成功时返回<code>true</code>，如果当前没有可用的空间，则返回<code>false</code>。</li>
<li><code>public abstract void put(E paramE) throws InterruptedException</code>:将指定元素插入到此队列中，将等待可用的空间(如果有必要)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"> checkNotNull(paramE);</span><br><span class="line"> ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;</span><br><span class="line"> localReentrantLock.lockInterruptibly();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length)</span><br><span class="line">     <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待</span></span><br><span class="line">     enqueue(paramE);</span><br><span class="line">         localReentrantLock.unlock();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 		localReentrantLock.unlock();</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>offer(E o,long timeout,TimeUnit unit)</code>:可以设定等待时间，如果在指定的时间内，还不能往队列中加入<code>BlockingQueue</code>,则返回失败。</li>
</ul>
</li>
<li><p><strong>获取数据操作</strong></p>
<ul>
<li><code>poll(time)</code>取出<code>BlockingQueue</code>里面排在首位的对象，若不能立即取出，则可以等待time参数规定的时间，取不到时返回<code>null</code>。</li>
<li><code>poll(long timeout,TimeUnit unit)</code>:从<code>BlockingQueue</code>取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，返回失败。</li>
<li><code>take()</code>:取出<code>BlockingQueue</code>里排在首位的对象，若<code>BlockingQueue</code>为空，阻断进入等待状态直到<code>BlockintQueue</code>有新的数据被加入。</li>
<li><code>drainTo()</code>:一次性从<code>BlockingQueue</code>获取所有可用的数据对象(还可以指定获取数据的个数)，通过该方法，可以提升获取数据效率，不需要多次分批加锁或释放锁。</li>
</ul>
</li>
</ul>
<h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ul>
<li><code>ArrayBlockingQueue</code>:由数组结构组成的有界阻塞队列(公平，非公平)。<ul>
<li>用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序，<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平的访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素，通常情况下为了保证公平性会降低吞吐量，我们可以使用代码创建一个公平的阻塞队列<code>ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true)；</code>。</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code>:由链表结构组成的有界阻塞队列(两个独立锁提高并发)。<ul>
<li>基于链表的阻塞队列，同<code>ArrayListBlockQueue</code>类似，此队列按照先进先出(FIFO)的原则对元素进行排序，而<code>LinkedBlockingQueue</code>之所以能高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<code>LinkedBlockingQueue会默认一个类似无限大小地容量(Integer.MAX_VALUE)</code>。</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code>:支持优先级排序的无界阻塞队列(compareTo排序实现优先)。<ul>
<li>是一个支持优先队列的无界队列，默认情况下元素采取自然顺序升序排列，可以自定义实现<code>compareTo()</code>方法来指定元素进行排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序，需要注意的是不能保证同优先级元素的顺序。</li>
</ul>
</li>
<li><code>DelayQueue</code>:使用优先级队列实现的无界阻塞队列(缓存失效，定时任务)。<ul>
<li><strong>是一个支持延迟获取元素的无界阻塞队列</strong>，队列使用<code>PriorityQueue</code>来实现，队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素，我们可以将<code>DelayQueue</code>运用到如下场景<ul>
<li>缓存系统的设计，可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>,一旦能从<code>DelayQueue</code>中获取元素时，表示缓存有效期到了。</li>
<li>定时任务调度：使用<code>DelayQueue</code>保存当天将会执行的任务和执行时间，一旦从<code>DelayQueue</code>中获取到任务就开始执行。比如<code>TimerQueue</code>就是使用<code>DelayQueue</code>实现的。</li>
</ul>
</li>
</ul>
</li>
<li><code>SynchronousQueue</code>:不存储元素的阻塞队列(不存储数据，可用于传递数据)。<ul>
<li><strong>是一个不存储元素的阻塞队列，每一个put操作必须等待一个take操作，否则不能继续添加元素</strong>。<code>SynchronousQueue</code>可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合于传递性场景，比如在一个线程中使用的数据，传递给另一个线程使用，<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</li>
</ul>
</li>
<li><code>LinkedTransferQueue</code>:由链表结构组成的无界阻塞队列。<ul>
<li>是一个由链表结构组成的无界阻塞<code>TransferQueue</code>队列，相对于其他阻塞队列，LinkedTransferQueue多了<code>tryTransfer()和transfer()</code>方法</li>
<li><strong>transfer()方法</strong>：如果当前有消费者正在等待接收元素(消费者使用take()方法或者带时间限制的poll()方法时)，<strong>transfer()方法可以把生产者传入的元素立即transfer给消费者.如果没有消费者在等待接收元素，transfer()方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</strong></li>
<li><strong>tryTransfer()方法</strong>。则是用来试探下生产者传入的元素是否能直接传给消费者，如果没有消费者等待接收元素，则返回false。和<code>transfer()</code>的区别是<code>tryTransfer()</code>无论消费者是否接收，方法立即返回，而<code>transfer()</code>是必须等到消费者消费了才返回。</li>
<li>对于带有时间限制的<code>tryTransfer(E e,long timeout,TimeUnit unit)</code>方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没有消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>
</ul>
</li>
<li><code>LinkedBlockingDeque</code>:由链表结构组成的双向阻塞队列。<ul>
<li>是一个由链表组成的<strong>双向阻塞队列</strong>。<strong>所谓的双向队列指的是你可以从队列的两端插入和移除元素</strong>。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了<code>addFirst(),addLast(),offerFirst(),offerLast(),peekFirst(),peekLast()</code>等方法，以First结尾的方法，表示插入，获取或移除双端队列的第一个元素，以Last结尾的方法，表示插入，获取和移除双端队列的最后一个元素。另外插入方法add()等同于addLast(),移除方法remove()等同于removeFirst()。但是take()方法却等同于takeFirst()。</li>
<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀，另外双向队列可以用在“工作窃取”模式中。</li>
</ul>
</li>
</ul>
<h2 id="CyclicBarrier-CountDownLatch和Semaphore的用法"><a href="#CyclicBarrier-CountDownLatch和Semaphore的用法" class="headerlink" title="CyclicBarrier,CountDownLatch和Semaphore的用法"></a>CyclicBarrier,CountDownLatch和Semaphore的用法</h2><h4 id="CountDownLatch-线程计数器"><a href="#CountDownLatch-线程计数器" class="headerlink" title="CountDownLatch(线程计数器)"></a>CountDownLatch(线程计数器)</h4><ul>
<li><code>CountDownLatch</code>位于java.util.concurrent包下，使用它可以实现类似计数器的功能。如有一个任务A，它要等待其他4个任务执行完毕后才能执行，此时就可以利用CountDownLatch来实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(<span class="string">"等待2个子线程执行完毕"</span>);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"2个子线程已经执行完毕"</span>);</span><br><span class="line">        System.out.println(<span class="string">"继续执行主线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><a href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行" class="headerlink" title="CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)"></a>CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</h4><ul>
<li><p>通过它可以实现让一组线程等待至某个状态之后再全部同时执行，叫做回环是因为当所有等待线程都被释放以后，<code>CyclicBarrier</code>可以被重用，暂且把这个状态叫做barrier,当调用<code>await()</code>之后，线程就处于barrier。CyclicBarrier中最重要的方法就是<code>await()</code>,它有两个重载版本：</p>
<ol>
<li><code>public int await()</code>:用来挂起当前线程，直至所有线程都到达<strong>barrier状态</strong>再同时执行后续任务。</li>
<li><code>pubilc int await(long timeout,TimeUnit unit)</code>:让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"所有线程写入完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Semaphore-信号量-控制同时访问的线程个数"><a href="#Semaphore-信号量-控制同时访问的线程个数" class="headerlink" title="Semaphore(信号量-控制同时访问的线程个数)"></a>Semaphore(信号量-控制同时访问的线程个数)</h4><ul>
<li><p><strong>Semaphore可以控制同时访问的线程个数</strong>，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。</p>
</li>
<li><p>Semaphore常用的方法：</p>
<ol>
<li><code>public void acquire()</code>:用来获取一个许可，若无许可能够获取，则会一直等待，直到获得许可。</li>
<li><code>public void acquire(int permits)</code>:获取permits许可。</li>
<li><code>public void release()</code>:释放许可(在释放许可之前，必须先获得许可)。</li>
<li><code>public void release(int permits)</code>:释放permits个许可。</li>
</ol>
</li>
<li><p>上述4个方法都会被阻塞，如果想立即得到执行结果，可以使用下述方法。</p>
<ol>
<li><code>public boolean tryAcquire()</code>:尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li><code>public boolean tryAcquire(long timeout,TimeUnit unit)</code>:尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。</li>
<li><code>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)</code>:尝试获取permits个许可，若在指定的时间内获取成功，则返回true，否则返回false。</li>
<li><code>public boolean tryAcquire(int permits)</code>:尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。</li>
<li>还可以通过<code>availablePermits()</code>方法得到可用的许可数目。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完</span></span><br><span class="line"><span class="comment"> 了，其他工人才能继续使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，<strong>CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</strong></li>
<li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
<h2 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h2><ul>
<li><strong><em>newCachedThreadPool</em></strong><ul>
<li>创建一个可根据需要创建新线程的线程池，但是在以前已经构造的线程可用时将重用它们，对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能，调用<strong>execute</strong>将重用以前构造的线程(如果线程可用)，如果现有线程没有可用的，则创建一个新的线程并添加到线程池中，终止并从缓存中移除那些已有60秒未被使用的线程，因此，长时间保持空闲的线程池不会使用任何资源。</li>
</ul>
</li>
<li><strong>newFixedThreadPool</strong><ul>
<li>创建一个可重用固定线程数的线程池，以共享的无界队列来运行这些线程，在任意点，在大多数nThreads线程会处于处理任务的活动状态，如果在所有线程处于活动时提交附加任务，则在有可用线程之前，附加1任务将在队列中等待，如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个线程将代替它执行后续的任务(如果需要),在某个线程被显式地关闭之前，池中的线程将一直存在。</li>
</ul>
</li>
<li><strong>newScheduledThreadPool</strong><ul>
<li>创建一个线程池，它可安排在给定延迟后运行命令或定期地执行。</li>
</ul>
</li>
<li><strong>newSingleThreadExecutor</strong><ul>
<li><strong>Executors.newSingleThreadExecutor()</strong>返回一个线程池(只有一个线程),这个线程池可以在线程死后(或发生异常)重新启动一个线程来代替原有的线程继续执行下去。</li>
</ul>
</li>
</ul>
<h2 id="线程基本方法"><a href="#线程基本方法" class="headerlink" title="线程基本方法"></a>线程基本方法</h2><p><img src="/2019/07/16/Java并发补充/1563288982967.png" alt="1563288982967"></p>
<ul>
<li><strong>线程等待(wait)</strong><ul>
<li>调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁，因此，wait()方法一般用在同步方法或同步代码块中。</li>
</ul>
</li>
<li><strong>线程睡眠(sleep)</strong><ul>
<li>sleep导致当前线程休眠，与wait不同的是sleep不会释放当前占用的锁，sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态。</li>
</ul>
</li>
<li><strong>线程让步(yield)</strong><ul>
<li>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片，一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li>
</ul>
</li>
<li><strong>线程中断(interrupt)</strong><ul>
<li>调用interrupt()方法并不会中断一个正在运行的线程，就是说处于Running状态的线程并不会因为被中止而被终止，仅仅改变了内部维护的中断标识位而已。</li>
<li>若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出<strong>InterruptedException</strong>,从而使线程提前结束TIMED-WATING状态。</li>
<li>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</li>
<li>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</li>
</ul>
</li>
<li><strong>Join等待其他线程终止</strong><ul>
<li>join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再有阻塞状态变为就绪状态，等待CPU的执行。</li>
</ul>
</li>
<li><strong>线程唤醒(notify)</strong><ul>
<li>Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与该对象上主动同步的其他所有线程进行竞争，类似的方法还有notifyAll(),唤醒在此监视器上等待的所有线程。</li>
</ul>
</li>
<li><strong>其他常用方法</strong><ul>
<li><code>isAlive()</code>:判断一个线程是否存活。</li>
<li><code>activeCount()</code>:程序中活跃的线程数。</li>
<li><code>enumerate()</code>:枚举程序中的线程。</li>
<li><code>currentThread()</code>:得到当前线程。</li>
<li><code>isDaemon()</code>:一个线程是否为守护线程。</li>
<li><code>setDaemon()</code>:设置一个线程为守护线程。</li>
<li><code>setName()</code>:为线程设置名称。</li>
<li><code>setPriority()</code>:设置一个线程的优先级。</li>
<li><code>getPriority()</code>:获得一个线程的优先级。</li>
</ul>
</li>
</ul>
<h2 id="同步锁与死锁"><a href="#同步锁与死锁" class="headerlink" title="同步锁与死锁"></a>同步锁与死锁</h2><ul>
<li><strong>同步锁</strong><ul>
<li>当多个线程同时访问同一个数据时，很容易出现问题，为了避免这种问题的出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据，Java中可已使用synchronized关键字来取得一个对象的同步锁。</li>
</ul>
</li>
<li><strong>死锁</strong><ul>
<li>就是多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。</li>
</ul>
</li>
</ul>
<h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><ul>
<li>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</li>
</ul>
<h4 id="变量可见性"><a href="#变量可见性" class="headerlink" title="变量可见性"></a>变量可见性</h4><ul>
<li>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</li>
</ul>
<h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><ul>
<li>volatile禁止了指令重排。</li>
</ul>
<h4 id="比Synchronized更轻量级的同步锁"><a href="#比Synchronized更轻量级的同步锁" class="headerlink" title="比Synchronized更轻量级的同步锁"></a>比Synchronized更轻量级的同步锁</h4><ul>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比Synchronized更轻量级的同步机制，volatile适合于这种场景：“<strong>一个变量被多个线程共享，线程直接给这个变量赋值</strong>”。</li>
<li>当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读写变量都从内存中读，跳过CPU cache这一步。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563354774642.png" alt="1563354774642"></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：<ol>
<li>对变量的些操作不依赖于当前值(如i++)，或者说是单纯的1变量赋值(boolean flag = true)</li>
<li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用<code>volatile</code>。</li>
</ol>
</li>
</ul>
<h2 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h2><ul>
<li>进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性JVM解决了可见性和有序性的问题，而锁解决了原子性的问题，在理想的情况下我们希望做到“同步”和“互斥”，有以下的实现方式.</li>
</ul>
<h4 id="将数据抽象为一个类，并将数据的操作作为这个类的方法"><a href="#将数据抽象为一个类，并将数据的操作作为这个类的方法" class="headerlink" title="将数据抽象为一个类，并将数据的操作作为这个类的方法"></a>将数据抽象为一个类，并将数据的操作作为这个类的方法</h4><ul>
<li>将数据抽象为一个类，并将对这个数据的操作作为这个类的方法，这样可以很容易做到同步，只要在方法上加上<code>synchronized</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data= data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    MyData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.dec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(add).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Runnable对象作为一个类的内部类"><a href="#Runnable对象作为一个类的内部类" class="headerlink" title="Runnable对象作为一个类的内部类"></a>Runnable对象作为一个类的内部类</h4><ul>
<li>将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"j 为："</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    data.dec();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal作用-线程本地存储"><a href="#ThreadLocal作用-线程本地存储" class="headerlink" title="ThreadLocal作用(线程本地存储)"></a>ThreadLocal作用(线程本地存储)</h2><ul>
<li>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</li>
</ul>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ol>
<li>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</li>
<li>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</li>
<li>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义<code>ThreadLocal.ThreadLocalMap threadLocals = null</code>;</li>
</ol>
<p><img src="/2019/07/16/Java并发补充/1563357402171.png" alt="1563357402171"></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>最常用于解决数据库连接，Session管理等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123; </span><br><span class="line">     Session s = (Session) threadSession.get(); </span><br><span class="line">     <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123; </span><br><span class="line">             s = getSessionFactory().openSession(); </span><br><span class="line">             threadSession.set(s); </span><br><span class="line">             &#125; </span><br><span class="line">    	 &#125; <span class="keyword">catch</span> (HibernateException ex) &#123; </span><br><span class="line">     		<span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol>
<li>都是用来协调多线程对共享对象，变量的访问。</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁。</li>
<li>都保证了可见性和互斥性。</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol>
<li>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的<br>不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻<br>塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言<br>实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等</li>
</ol>
<h2 id="Volatile和Synchronized的区别"><a href="#Volatile和Synchronized的区别" class="headerlink" title="Volatile和Synchronized的区别"></a>Volatile和Synchronized的区别</h2><ol>
<li>volatile不会进行加锁操作。</li>
<li>volatile变量作用类似于同步变量读写操作。</li>
<li>volatile不如Synchronized安全。</li>
<li>volatile无法同时保证内存可见性和原子性。</li>
</ol>
<h2 id="ConcurrentHashMap并发"><a href="#ConcurrentHashMap并发" class="headerlink" title="ConcurrentHashMap并发"></a>ConcurrentHashMap并发</h2><h4 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h4><ul>
<li>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li>
</ul>
<h4 id="ConcurrentHashMap分段锁"><a href="#ConcurrentHashMap分段锁" class="headerlink" title="ConcurrentHashMap分段锁"></a>ConcurrentHashMap分段锁</h4><ul>
<li>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</li>
<li>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</li>
</ul>
<h4 id="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><a href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成" class="headerlink" title="ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"></a>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</h4><ul>
<li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358149513.png" alt="1563358149513"></p>
<h2 id="Java中用到的线程调度"><a href="#Java中用到的线程调度" class="headerlink" title="Java中用到的线程调度"></a>Java中用到的线程调度</h2><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><ul>
<li>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</li>
</ul>
<h4 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h4><ul>
<li>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</li>
</ul>
<h4 id="JVM的线程调度实现-抢占式调度"><a href="#JVM的线程调度实现-抢占式调度" class="headerlink" title="JVM的线程调度实现(抢占式调度)"></a>JVM的线程调度实现(抢占式调度)</h4><ul>
<li>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</li>
</ul>
<h4 id="线程让出cpu的情况"><a href="#线程让出cpu的情况" class="headerlink" title="线程让出cpu的情况"></a>线程让出cpu的情况</h4><ol>
<li>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</li>
<li>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</li>
<li>当前运行线程结束，即运行完 run()方法里面的任务。</li>
</ol>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><ul>
<li><strong>先来先服务调度算法(FCDS)</strong><ul>
<li>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</li>
</ul>
</li>
<li><strong>短作业(进程)优先调度算法</strong><ul>
<li>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</li>
</ul>
</li>
</ul>
<h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4><ul>
<li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</li>
<li><strong>非抢占式优先权算法</strong><ul>
<li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
</li>
<li><strong>抢占式优先权调度算法</strong><ul>
<li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
<li><strong>高响应比优先调度算法</strong><ul>
<li>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</li>
</ul>
</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563358860683.png" alt="1563358860683"></p>
<h4 id="基于时间片的轮询调度算法"><a href="#基于时间片的轮询调度算法" class="headerlink" title="基于时间片的轮询调度算法"></a>基于时间片的轮询调度算法</h4><ul>
<li><strong>时间片轮转法</strong><ul>
<li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</li>
</ul>
</li>
<li><strong>多级反馈队列调度算法</strong><ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</li>
</ol>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h4 id="概念特性"><a href="#概念特性" class="headerlink" title="概念特性"></a>概念特性</h4><ul>
<li>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</li>
<li>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</li>
</ul>
<h4 id="原子包java-util-concurrent-atomic-锁自旋"><a href="#原子包java-util-concurrent-atomic-锁自旋" class="headerlink" title="原子包java.util.concurrent.atomic(锁自旋)"></a>原子包java.util.concurrent.atomic(锁自旋)</h4><ul>
<li>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">return</span> value; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line">        <span class="keyword">int</span> current = get(); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) </span><br><span class="line">        <span class="keyword">return</span> current; </span><br><span class="line"> 	&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><ul>
<li>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</li>
<li>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li>
<li>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</li>
</ul>
<h2 id="什么是AQS-抽象的队列同步器"><a href="#什么是AQS-抽象的队列同步器" class="headerlink" title="什么是AQS(抽象的队列同步器)"></a>什么是AQS(抽象的队列同步器)</h2><ul>
<li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</li>
</ul>
<p><img src="/2019/07/16/Java并发补充/1563360810227.png" alt="1563360810227"></p>
<ul>
<li>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:<br><strong>getState()，setState()，compareAndSetState()</strong>。</li>
<li>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</li>
</ol>
</li>
</ul>
<h4 id="AQS资源共享方式"><a href="#AQS资源共享方式" class="headerlink" title="AQS资源共享方式"></a>AQS资源共享方式</h4><ul>
<li><strong>Exclusive独占资源-ReentrantLock</strong><ul>
<li>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</li>
</ul>
</li>
<li><strong>Share 共享资源-Semaphore/CountDownLatch</strong><ul>
<li>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</li>
</ul>
</li>
</ul>
<h4 id="同步器的实现ABS核心-state资源状态计数"><a href="#同步器的实现ABS核心-state资源状态计数" class="headerlink" title="同步器的实现ABS核心(state资源状态计数)"></a>同步器的实现ABS核心(state资源状态计数)</h4><ul>
<li>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</li>
</ul>
<h4 id="ReentrantReadWriteLock实现独占和共享两种方式"><a href="#ReentrantReadWriteLock实现独占和共享两种方式" class="headerlink" title="ReentrantReadWriteLock实现独占和共享两种方式"></a>ReentrantReadWriteLock实现独占和共享两种方式</h4><ul>
<li>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</li>
</ul>

        </div>
        
          


  <section class='meta' id="footer-meta">
    <hr>
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-07-20T22:08:17+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>last updated at Jul 20, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/java-并发/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>-java -并发</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/16/Java并发补充/&title=Java并发补充 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2019/07/16/Java并发补充/&title=Java并发补充 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/16/Java并发补充/&title=Java并发补充 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;Previous</h6>
                            <h4>
                                <a href="/2019/07/19/网络/" rel="prev" title="网络">
                                  
                                      网络
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/Http/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>Http</a> <a class="tag" href="/tags/tcp-ip/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>tcp/ip</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>Next&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/07/15/Collection总结/" rel="prev" title="Collection总结">
                                    
                                        Collection总结
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/集合/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>集合</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Java并发补充',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;TOC</div>
  
    <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池原理"><span class="toc-text">线程池原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java阻塞队列原理"><span class="toc-text">Java阻塞队列原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞队列主要方法"><span class="toc-text">阻塞队列主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中的阻塞队列"><span class="toc-text">Java中的阻塞队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier-CountDownLatch和Semaphore的用法"><span class="toc-text">CyclicBarrier,CountDownLatch和Semaphore的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch-线程计数器"><span class="toc-text">CountDownLatch(线程计数器)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier-回环栅栏，等待至barrier状态再全部同时执行"><span class="toc-text">CyclicBarrier(回环栅栏，等待至barrier状态再全部同时执行)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore-信号量-控制同时访问的线程个数"><span class="toc-text">Semaphore(信号量-控制同时访问的线程个数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建线程池的方式"><span class="toc-text">创建线程池的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程基本方法"><span class="toc-text">线程基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步锁与死锁"><span class="toc-text">同步锁与死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile作用"><span class="toc-text">Volatile作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量可见性"><span class="toc-text">变量可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止重排序"><span class="toc-text">禁止重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比Synchronized更轻量级的同步锁"><span class="toc-text">比Synchronized更轻量级的同步锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适用场景"><span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何在两个线程间共享数据"><span class="toc-text">如何在两个线程间共享数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将数据抽象为一个类，并将数据的操作作为这个类的方法"><span class="toc-text">将数据抽象为一个类，并将数据的操作作为这个类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable对象作为一个类的内部类"><span class="toc-text">Runnable对象作为一个类的内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal作用-线程本地存储"><span class="toc-text">ThreadLocal作用(线程本地存储)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap"><span class="toc-text">ThreadLocalMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized和ReentrantLock的区别"><span class="toc-text">Synchronized和ReentrantLock的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相同点"><span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不同点"><span class="toc-text">不同点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile和Synchronized的区别"><span class="toc-text">Volatile和Synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap并发"><span class="toc-text">ConcurrentHashMap并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#减小锁粒度"><span class="toc-text">减小锁粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap分段锁"><span class="toc-text">ConcurrentHashMap分段锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成"><span class="toc-text">ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中用到的线程调度"><span class="toc-text">Java中用到的线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#抢占式调度"><span class="toc-text">抢占式调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协同式调度"><span class="toc-text">协同式调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM的线程调度实现-抢占式调度"><span class="toc-text">JVM的线程调度实现(抢占式调度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程让出cpu的情况"><span class="toc-text">线程让出cpu的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程调度算法"><span class="toc-text">进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优先调度算法"><span class="toc-text">优先调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高优先权优先调度算法"><span class="toc-text">高优先权优先调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于时间片的轮询调度算法"><span class="toc-text">基于时间片的轮询调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念特性"><span class="toc-text">概念特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原子包java-util-concurrent-atomic-锁自旋"><span class="toc-text">原子包java.util.concurrent.atomic(锁自旋)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA问题"><span class="toc-text">ABA问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是AQS-抽象的队列同步器"><span class="toc-text">什么是AQS(抽象的队列同步器)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS资源共享方式"><span class="toc-text">AQS资源共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步器的实现ABS核心-state资源状态计数"><span class="toc-text">同步器的实现ABS核心(state资源状态计数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock实现独占和共享两种方式"><span class="toc-text">ReentrantReadWriteLock实现独占和共享两种方式</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Categories</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java-java编程思想-读书笔记/" href="/categories/java-java编程思想-读书笔记/"><div class='name'>java - java编程思想 - 读书笔记</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(24)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 22px; color: #636363">java编程思想</a> <a href="/tags/jvm/" style="font-size: 20px; color: #707070">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 18px; color: #7e7e7e">多线程</a> <a href="/tags/字符串/" style="font-size: 14px; color: #999">字符串</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/异常/" style="font-size: 14px; color: #999">异常</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/数组/" style="font-size: 14px; color: #999">数组</a> <a href="/tags/枚举/" style="font-size: 14px; color: #999">枚举</a> <a href="/tags/泛型/" style="font-size: 14px; color: #999">泛型</a> <a href="/tags/注解/" style="font-size: 14px; color: #999">注解</a> <a href="/tags/类型信息/" style="font-size: 14px; color: #999">类型信息</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16px; color: #8b8b8b">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="" target="_blank" class="codename">Hello World</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
