<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>java编程思想第十八章 | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  
    <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/11/17/java编程思想第十八章/">
        java编程思想第十八章
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          <h2 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h2><h3>对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</h3>

<ul>
<li><strong>Java 1.0</strong>版本以来，<strong>Java</strong>的<strong>I/O</strong>类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于<strong>Unicode</strong>的类。在<strong>JDK 1.4</strong>中，添加了<strong>nio</strong>类(对于“新<strong>I/O</strong>”来说，这是一个从现在起我们将要使用若干年的名称，即使它们在<strong>JDK 1.4</strong>中就已经被引入了，因此它们已经“旧”了)添加进来是为了改进性能及功能。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul>
<li><strong>File</strong>(文件)类这个名字具有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。==它既能代表一个特定文件的名称，有能代表一个目录下的一组文件的名称==。如果它指的是一个文件集，我们就可以对此集合调用<strong>list()</strong>方法，这个方法会返回一个字符数组。</li>
</ul>
<h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><ul>
<li><p>假设查看一个目录列表，可以用两种方法来使用<strong>File</strong>对象。如果调用不带参数的<strong>list()</strong>方法，便可以获得此<strong>File</strong>对象包含的全部列表。但是，如果我们想要获得一个受限列表，如：想得到所有拓展名为<strong>.java</strong>的文件，那么就需要使用“<strong>目录过滤器</strong>”，这个类会告诉我们怎么显示符合条件的<strong>File</strong>对象。</p>
</li>
<li><p>通过使用<strong>java.utils.sort()</strong>和<strong>String.CASE_INSENSITIVE.ORDERComparator</strong>，可以很容易的对结果进行排序(按字母顺序)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">            Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DirFilter</strong>这个类存在的唯一原因就是<strong>accept()</strong>方法。创建这个类的目的在于把<strong>accept()</strong>方法提供给<strong>list()</strong>使用，使<strong>list()</strong>可以回调<strong>accept()</strong>，进而以决定哪些文件包含在列表中。因此，这种结构也常常被称为==回调==。更具体的说，这是一个==策略模式==。==策略的目的就是提供了代码行为的灵活性==。</p>
</li>
<li><p><strong>accept()</strong>方法必须接受一个代表某个特定文件所在目录的<strong>File</strong>对象，以及包含那个文件的一个<strong>String</strong>。注意：==<strong>list()</strong>方法会为此目录对象下的每个文件名调用<strong>accept()</strong>,来判断该文件是否包含在内；判断结果由<strong>accept()</strong>返回的布尔值决定。==</p>
</li>
</ul>
<h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><ul>
<li><strong>File</strong>类不仅仅只代表存在的文件或目录。也可以用<strong>File</strong>对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，检查某个<strong>File</strong>对象代表的是一个文件还是一个目录，并可以删除文件。</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><strong>I/O</strong>库中常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。“流”屏蔽了实际的<strong>I/O</strong>设备中处理数据的细节。</li>
<li><strong>Java</strong>类库中的<strong>I/O</strong>类分成==输入和输出==两部分。通过==继承==，任何自<strong>InputStream</strong>或<strong>Reader</strong>派生而来的类都含有名为<strong>read()</strong>的基本方法，==用于读取单个字节或者字节数组==。同样，任何自<strong>OutputStream</strong>或<strong>Writer</strong>派生而来的类都含有名为<strong>write()</strong>的基本方法，==用于写单个字节或者字节数组==。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个流对象来提供所期望的功能(这是装饰器设计模式)。</li>
<li>实际上。<strong>Java</strong>中的“<strong>流</strong>”类库让人迷惑的主要原因就在于：==创建单一的结果流，却需要创建多个对象==。</li>
<li>在<strong>Java 1.0</strong>中，类库的设计者首先限定与<strong>输入</strong>有关的所有类都应该从<strong>InputStream</strong>继承,而<strong>输出</strong>有关的所有类都应该从<strong>OutputStream</strong>继承。</li>
</ul>
<h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul>
<li><strong>InputStream</strong>的作用是用来表示那些从不同数据源产生输入的类。包括：<ol>
<li>字节数组。</li>
<li><strong>String</strong>对象。</li>
<li>文件。</li>
<li>“管道”，工作方式与实际管道类似，即，从一端输入，从另一端输出。</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集和并到一个流内。</li>
<li>其他数据源，如<strong>Internet</strong>连接等。</li>
</ol>
</li>
<li>每一种数据源都有相应的<strong>InputStream</strong>子类。另外，<strong>FileInputStream</strong>也属于一种<strong>InputStream</strong>，为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayInputStream</strong></td>
<td>允许将内存的缓冲区当作<strong>InputStrem</strong>使用</td>
<td>缓冲区，字节将从中取出<br>          作为一种数据源：将其与<strong>FileterInputStream</strong>对象相连以提供有用接口</td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong></td>
<td>将<strong>String</strong>转换为<strong>InputStream</strong></td>
<td>字符串。底层实现实际使用<strong>StringBuffer</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td>用于从文件中读取信息</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象1相连以提供有用接口</td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td>产生用于写入相关<strong>PipedOutputStream</strong>的数据。实现“管道化”概念</td>
<td><strong>PipedOutputStream</strong><br>          作为多线程中的数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
<td>将两个或多个<strong>InputStream</strong>对象转换成单一<strong>InputStream</strong></td>
<td>两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<strong>Enumeration</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterInputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中“装饰器”为其他类的<strong>InputStream</strong>类提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><ul>
<li>该类型的类决定了输出所要去往的目标：字节数组，文件或管道。</li>
<li><strong>FilterOutputStream</strong>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td>
<td>缓冲区大小(可选的)<br>          用于指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td>用于将信息写至文件。</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td>任何写入其中的信息都会自动作为相关<strong>PipedInputStream</strong>的输出。实现“管道化”概念</td>
<td><strong>PipedInputStream</strong>          <br>指定用于多线程的数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中，“装饰器”为其他<strong>OutputStream</strong>提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><ul>
<li><strong>Java I/O</strong>类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是<strong>Java I/O</strong>类库里存在<strong>filter</strong>(过滤器)类的原因所在抽象类<strong>filter</strong>是所有装饰器的基类。</li>
<li>==装饰器必须具有和它所装饰的对象相同的接口==，但它也可以扩展接口，这种情况只发生在个别<strong>filter</strong>类中。</li>
<li>装饰器的==缺点==：在编写程序时，==增加了代码的复杂性==。<strong>Java I/O</strong>类库操作不便的原因在于：我们必须创建许多类—“核心” <strong>I/O</strong>类型加上所有的装饰器，才能得到我们所希望的单个<strong>I/O</strong>对象。</li>
<li><strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>是用来提供装饰器类接口以控制特定输入流(<strong>InputStream</strong>)和输出流(<strong>OutputStream</strong>)的两个类。<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>分别自<strong>I/O</strong>类库中的基类<strong>InputStream</strong>和<strong>OutputStream</strong>派生而来，这两个类是装饰器的必要条件。</li>
</ul>
<h4 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a>通过FilterInputStream从InputStream读取数据</h4><ul>
<li><strong>FilterInputStream</strong>类能够完成两件完全不同的事情。<ol>
<li><strong>DataInputStream</strong>允许我们读取不同的基本类型数据以及<strong>String</strong>对象(所有的方法都以“<strong>read</strong>”开头，如：<strong>readByte()</strong>,<strong>readFloat()</strong>等等)。搭配相应的<strong>DataOutputStream</strong>,就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</li>
<li>其他<strong>FilterInputStream</strong>类则在内部修改<strong>InputStream</strong>的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。</li>
</ol>
</li>
<li>我们几乎每次都要对输入进行缓冲—–不管我们正在连接的是什么<strong>I/O</strong>设备，所以，<strong>I/O</strong>类库把无缓冲输入(而不是缓冲输入)作为特殊情况(或只是方法调用)就显得更加合理了。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataInputStream</strong></td>
<td>与<strong>DataOutputStream</strong>搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)。</td>
<td><strong>InputStream</strong><br>包含用于读取基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td>使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。</td>
<td><strong>InputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong></td>
<td>跟踪输入流中的行号；可调用<strong>getLineNumber()</strong>和<strong>setLineNumber(int)</strong>。</td>
<td><strong>InputStream</strong><br>仅增加了行号，因此可能要与接口对象搭配使用。</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td>具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退。</td>
<td><strong>InputStream</strong><br>通常作为编译器的扫面器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td>
</tr>
</tbody></table>
<h4 id="通过FilterOutPutStream向OutputStream写入"><a href="#通过FilterOutPutStream向OutputStream写入" class="headerlink" title="通过FilterOutPutStream向OutputStream写入"></a>通过FilterOutPutStream向OutputStream写入</h4><ul>
<li>与<strong>DataInputStream</strong>对应的是<strong>DataOutputStream</strong>，它可以将各种<strong>基本数据类型</strong>以及<strong>String</strong>对象格式化输出到“流”中；这样，任何设备上的任何<strong>DataInputStream</strong>都能够读取它们。所有的方法都以”<strong>wirte</strong>“开头，如<strong>writeByte()</strong>,<strong>writeFloat()</strong>等等。</li>
<li><strong>PrintStream</strong>最初目的便是为了以可视化格式打印所有的<strong>基本数据类型</strong>以及<strong>String</strong>对象。这和<strong>DataOutputStream</strong>不同，后者的目的是将数据元素置入“流”中，使<strong>DataInputStream</strong>能够可移植地重构它们。</li>
<li><strong>PrintStream</strong>可能会有些问题，因为它捕捉了所有的<strong>IOException</strong>(因此，我们必需使用<strong>checkError()</strong>自行测试错误状态，如果出现错误它返回<strong>true</strong>)。另外，<strong>PrintStream</strong>也未完全国际化，不能以平台无关地方式处理换行动作(这些问题在<strong>printWriter</strong>中得到了解决)。</li>
<li><strong>BufferedOutputStream</strong>是一个修改过的<strong>OutputStream</strong>，<strong>它对数据流使用缓冲技术</strong>；因此当每次向流写入时，不必每次都进行实际的物理写操作。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
<td>与<strong>DataInputStream</strong>搭配使用，因此可以按照可移植方式向流中写入基本类型数据(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)</td>
<td><strong>OutputStream</strong><br>包含用于写入基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td>用于产生格式化输出。其中<strong>DataOutputStream</strong>处理数据的存储，<strong>PrintStream</strong>处理显示。</td>
<td><strong>OutputStream</strong>,可以用<strong>boolean</strong>值指示是否在每次换行时清空缓冲区(可选的)应该是对<strong>OutputStream</strong>对象的“<strong>final</strong>”封装。</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td>使用它以避免每次发送数据时都要进行实际的写操作。代表“使用缓冲区”。可以调用<strong>flush()</strong>清空缓冲区。</td>
<td><strong>OutputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
</tbody></table>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul>
<li><strong>Java 1.1</strong>对基本的<strong>I/O</strong>流类库进行了重大的修改。<strong>InputStream</strong>和<strong>OutputStream</strong>在以面向==字节==形式的<strong>I/O</strong>中提供极有价值的功能，<strong>Reader</strong>和<strong>Writer</strong>则提供兼容<strong>Unicode</strong>与面向==字符==的<strong>I/O</strong>功能。</li>
<li>有时我们必须把来自“<strong>字节</strong>”层次结构中的类和“<strong>字符</strong>”层次结构中的类结合起来使用。为了实现这个目的，要用到”<strong>适配器</strong>“(adapter)类：<strong>InputStreamReader</strong>可以把<strong>InputStream</strong>转换为<strong>Reader</strong>，而<strong>OutputStreamWriter</strong>可以把<strong>OutputStream</strong>转换为<strong>Writer</strong>。</li>
<li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的<strong>I/O</strong>流继承层次结构仅支持<strong>8位字节流</strong>，并且不能很好地处理<strong>16位的Unicode字符</strong>。由于<strong>Unicode</strong>用于<strong>字符国际化</strong>(<strong>Java</strong>本身的<strong>char</strong>也是16位的<strong>Unicode</strong>)，所以添加<strong>Reader</strong>和<strong>Writer</strong>继承层次结构就是为了在所有的<strong>I/O</strong>操作中都支持<strong>Unicode</strong>。</li>
</ul>
<h4 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h4><ul>
<li>在某些场合中，==面向字节==的<strong>InputStream</strong>和<strong>OutputStream</strong>才是正确的解决方案；特别是，<strong>java.util.zip</strong>类库就是==面向字节的而不是面向字符==的。因此，最明智的做法就是尽量尝试使用<strong>Reader</strong>和<strong>Writer</strong>，一旦程序代码无法成功编译，我们就会发现自己==不得不使用面向字节==的类库。</li>
<li>下面展示了在两个继承层次结构中，信息的来源和去处(即数据物理上来自哪里及去向哪里)之间的关系：</li>
</ul>
<table>
<thead>
<tr>
<th>来源与去处：Java 1.0类</th>
<th>相应的Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong><br>适配器：<strong>InputStreamReader</strong></td>
</tr>
<tr>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong><br>适配器：<strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td><strong>FileReader</strong></td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileWriter</strong></td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong>(已弃用)</td>
<td><strong>StringReader</strong></td>
</tr>
<tr>
<td>无</td>
<td><strong>StringWriter</strong></td>
</tr>
<tr>
<td><strong>ByteArrayInputStream</strong></td>
<td><strong>CharArrayReader</strong></td>
</tr>
<tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td><strong>CharArrayWriter</strong></td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td><strong>PipedReader</strong></td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td><strong>PipedWriter</strong></td>
</tr>
</tbody></table>
<h4 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h4><ul>
<li>对于<strong>InputStream</strong>和<strong>OutputStream</strong>来说，我们会使用<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>的装饰器子类来修改“<strong>流</strong>”以满足特殊需要。<strong>Reader</strong>和<strong>Writer</strong>的类继承层次结构继续沿用相同的思想，但是并不完全相同。</li>
</ul>
<table>
<thead>
<tr>
<th>过滤器 Java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FilterInputStream</strong></td>
<td><strong>FilterReader</strong></td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td><strong>FilterWriter</strong>(抽象类，没有子类)</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedReader</strong>(也有<strong>readLine()</strong>)</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td><strong>DataInputStream</strong></td>
<td>使用<strong>DataInputStream</strong>(除了当需要使用<strong>readLine()</strong>时以外，这时应该使用<strong>BufferedReader</strong>)</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td><strong>PrintWriter</strong></td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong>(已弃用)</td>
<td><strong>LineNumberReader</strong></td>
</tr>
<tr>
<td><strong>StreamTokenizer</strong></td>
<td><strong>StreamTokenizer</strong>(使用接受<strong>Reader</strong>的构造器)</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td><strong>PushbackReader</strong></td>
</tr>
</tbody></table>
<ul>
<li>无论我们何时使用<strong>readLine()</strong>,都不应该使用<strong>DataInputStream</strong>(这会遭到编译器的强烈反对)，而应该使用<strong>BufferedReader</strong>。除这一点，<strong>DataInputStream</strong>仍然是<strong>I/O</strong>类库的首选。</li>
<li><strong>PrintWriter</strong>提供了一个既能接受<strong>Writer</strong>对象又能接受任何<strong>OutputStream</strong>对象的构造器。<strong>PrintWriter</strong>的格式化接口实际上与<strong>PrintStream</strong>相同。</li>
<li>有一种<strong>PrintWriter</strong>构造器还有一个选项，就是“<strong>自动执行清空</strong>”选项。如果构造器设置此选项，则每个<strong>Println()</strong>执行之后，便会自动清空。</li>
</ul>
<h4 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h4><table>
<thead>
<tr>
<th>以下这些Java 1.0类在Java 1.1中没有相应类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
</tr>
<tr>
<td><strong>File</strong></td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>DataOutputStream</strong>，在使用时没有任何变化；因此如果想以“可传输的”格式存储和检索数据，可以使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构。</li>
</ul>
<h3 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h3><ul>
<li><strong>RandomAccessFile</strong>适用于由大小已知的记录组成的文件，所以我们可以使用<strong>seek()</strong>将记录从一处转移到另一处，然后读取或者修改记录。</li>
<li>除了实现了<strong>DataInput</strong>和<strong>DataOutput</strong>接口之外，它和这两个继承层次结构没有任何关联。甚至不适用<strong>InputStream</strong>和<strong>OutputStream</strong>类中已有的任何功能。它是一个完全独立的类，这么做是因为<strong>RandomAccessFile</strong>拥有和别的<strong>I/O</strong>类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。</li>
<li>只有RandomAccessFile支持搜寻方法，并且只适用于文件。</li>
</ul>
<h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I/O流的典型使用方式"></a>I/O流的典型使用方式</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul>
<li><p>如果想要打开一个文件用于字符输入，可以使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputReader</strong>。为了提高速度，我们希望对那个文件进行缓冲，那么将所产生的引用传给一个<strong>BufferedReader</strong>构造器。由于<strong>BufferedReader</strong>也提供了<strong>readLine()</strong>方法，所以这是我们的最终对象和进行读取的接口。当<strong>readLine()</strong>将返回<strong>null</strong>时，你就达到了文件的末尾。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串<strong>sb</strong>用来累计文件的全部内容(包括必须添加的换行符，因为<strong>readLine()</strong>已将它们删掉)。最后，调用<strong>close()</strong>关闭文件。</p>
</li>
</ul>
<h4 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h4><ul>
<li><p>下面，从<strong>BufferedInputFile.read()</strong>读入的<strong>String</strong>结果被用来创建一个<strong>StringReader</strong>。然后调用<strong>read()</strong>每次读取一个字符，并把它发送到控制台。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = sr.read())!= -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read()</strong>是以<strong>int</strong>形式返回下一字节，因此必须类型转型为<strong>char</strong>才能正确打印。</p>
</li>
</ul>
<h4 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h4><ul>
<li><p>要读取格式化数据，可以使用<strong>DataInputStream</strong>,它是一个面向字节的<strong>I/O</strong>类(不是面向字符的)。因此我们必须使用<strong>InputStream</strong>类而不是<strong>Reader</strong>类。当然，可以用<strong>InputStream</strong>以字节的形式读取任何数据(如一个文件)，不过，这里使用的是字符串。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile</span><br><span class="line">                                    .read(<span class="string">"D://HelloWorld.java"</span>)</span><br><span class="line">                                    .getBytes()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>必须为<strong>ByteArrayInputStream</strong>提供字节数组，为了产生该数组<strong>String</strong>包含了一个可以实现此项工作的<strong>getBytes()</strong>方法。所产生的<strong>ByteArrayInputStream</strong>是一个适合传递给<strong>DataInputStream</strong>的<strong>InputStream</strong>。</p>
</li>
<li><p>如果我们从<strong>DataInputStream</strong>用<strong>readByte()</strong>一次一个字节读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束。相反，我们可以使用<strong>available()</strong>方法查看还有多少可供存储的字符。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesrEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul>
<li><p>FileWriter对象可以向文件写入数据。创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出(尝试移除此包装来感受对性能的影响——缓冲往往能显著地增加I/O操作地性能)。下面，为了提供格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可作为普通文本文件读取。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://HelloWorld.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            out.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">2: 	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">3: 	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">4: 	&#125;</span></span><br><span class="line"><span class="comment">5: &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦读完输入数据流，<strong>readLine()</strong>会返回<strong>null</strong>。我们可以看到要为<strong>out</strong>显示调用<strong>close()</strong>。如果我们不为所有的输出文件调用<strong>close()</strong>,就会发现缓冲区内容不会被刷新清空，那么它们就不完整。</p>
</li>
</ul>
<h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><ul>
<li><p><strong>PrintWriter</strong>可以对数据进行格式化，以便人们阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用<strong>DataOutputStream</strong>写入数据，并用<strong>DataInputStream</strong>恢复数据。当然，这些流可以是任意形式。注意：<strong>DataOutputStream</strong>和<strong>DataInputStream</strong>是==面向字节==的，因此要使用<strong>InputStream</strong>和<strong>OutputStream</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">That was pi</span></span><br><span class="line"><span class="comment">1.41413</span></span><br><span class="line"><span class="comment">Square root of 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>DataOutputStream</strong>写入数据，<strong>Java</strong>保证我们可以使用<strong>DataInputStream</strong>准确地读取数据—无论读和写数据的平台多么不同。</p>
</li>
<li><p>当使用<strong>DataOutputStream</strong>时，写字符串并且让<strong>DataInputStream</strong>能够恢复它的==唯一可靠==的做法就是使用<strong>UTF-8</strong>编码，在示例中是用<strong>writeUTF()</strong>和<strong>readUTF()</strong>实现的。</p>
</li>
<li><p><strong>writeDouble()</strong>将<strong>double</strong>类型的数字存储到流中，并用相应的<strong>readDouble()</strong>恢复它(对于其他的数据类型，也有类似方法用于读写)。</p>
</li>
</ul>
<h4 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h4><ul>
<li><p>使用<strong>RandomAccessFile</strong>，类似于组合使用了<strong>DataInputStream</strong>和<strong>DataOutputStream</strong>(因为它实现了相同的接口：<strong>DataInput</strong>和<strong>DataOutput</strong>)。另外，利用<strong>seek()</strong>可以在文件中到处移动，并修改文件中的某个值。</p>
</li>
<li><p>使用<strong>RandomAccessFile</strong>时，你必须知道文件排版，这样才能正确使用它。<strong>RandomAccessFile</strong>拥有读取基本类型和<strong>UTF-8</strong>字符串的各种方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">" "</span>+rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">            rf.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">            rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">            rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 7.069999999999999</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 47.001</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>display()</strong>方法打开了一个文件，并以<strong>double</strong>值的形式显示了其中的七个元素。在<strong>main()</strong>中，首先创建了文件，然后打开并修改它。因为<strong>double</strong>总是8字节长，所以为了用<strong>seek()</strong>查找第5个双精度值，你只需用5*8来产生查找位置。</p>
</li>
</ul>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul>
<li>程序的<strong>所有输入</strong>都可以来自于<strong>标准输入</strong>，它的<strong>所有输出</strong>也都可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送到<strong>标准错误</strong>。<strong>标准I/O</strong>的意义在于：我们可以很容易地把程序串联起来，一个程序的<strong>标准输出</strong>可以成为另一个程序的<strong>标准输入</strong>。</li>
</ul>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul>
<li><p>按照标准<strong>I/O</strong>模型，<strong>Java</strong>提供了<strong>System.in</strong>,<strong>System.out</strong>,<strong>System.err</strong>。其中<strong>System.out</strong>已经事先被包装成了<strong>printStream</strong>对象。<strong>System.err</strong>同样也是<strong>PrintStream</strong>，但是<strong>System.in</strong>却是一个没有被包装过的未经加工的<strong>InputStream</strong>。这意味着尽管我们可以立即使用<strong>System.out</strong>和<strong>System.err</strong>，但是在读取<strong>System.in</strong>之前必须对其进行包装。</p>
</li>
<li><p>通常我们会用<strong>readLine()</strong>一次一行地读取输入，我们可以将<strong>System.in</strong>包装成<strong>BufferedReader</strong>来使用这要求我们必须用<strong>InputStreamReader</strong>把<strong>System.in</strong>转换成<strong>Reader</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><ul>
<li><p><strong>System.out</strong>是一个<strong>PrintStream</strong>，而<strong>PrintStream</strong>是一个<strong>OutputStream</strong>。<strong>PrintWriter</strong>有一个可以接受<strong>OutputStream</strong>作为参数的构造器。所以，只要需要，就可以使用那个构造器把<strong>System.out</strong>转换成<strong>PrintWriter</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将第二个参数设为<strong>true</strong>，以便开启自动清空功能；否则，有可能看不到输出。</p>
</li>
</ul>
<h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><ul>
<li><p><strong>System</strong>类提供了一些简单的静态方法调用，以允许我们对标准输入，输出和错误<strong>I/O</strong>流进行<strong>重定向</strong>：</p>
<ul>
<li><strong>setIn(InputStream)</strong></li>
<li><strong>setOut(PrintStream)</strong></li>
<li><strong>setErr(PrintStream)</strong></li>
</ul>
</li>
<li><p>如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"D://test.txt"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>I/O</strong>重定向操纵的是<strong>字节流</strong>，而不是字符流；因此我们使用的是<strong>InputStream</strong>和<strong>OutputStream</strong>，而不是<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
</ul>
<h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><ul>
<li><p><strong>JDK 1.4</strong>的<strong>java.nio.*</strong>包中引入了新的<strong>Java I/O</strong>类库，其目的在于<strong>提高速度</strong>。速度的提高在<strong>文件I/O</strong>和<strong>网络I/O</strong>中都有可能发生。</p>
</li>
<li><p>速度的提高来自所使用的结构更接近于操作系统执行<strong>I/O</strong>的方式：<strong>通道和缓冲器</strong>。</p>
</li>
<li><p>唯一直接与通道交互的缓冲器是<strong>ByteBuffer</strong>—也就是说，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<strong>ByteBuffer</strong>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但却正好，因为这是大多数操作系统中更有效的映射方式。</p>
</li>
<li><p>旧<strong>I/O</strong>类库中有三个类被修改了，用以产生<strong>FileChannel</strong>。分别是<strong>FileInputStream</strong>,<strong>FileOutputStream</strong>以及用于<strong>既读又写</strong>的<strong>RandomAccessFile</strong>。注意这些是<strong>字节操作流</strong>，与低层的<strong>nio</strong>性质一致。<strong>Reader</strong>和<strong>Writer</strong>这种<strong>字符模式类</strong>不能用于产生通道；但是<strong>java.nio.channels.Channels</strong>类提供了实用方法，用以在通道中产生<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
<li><p>下面演示上面的三种类型的流，用于产生<strong>可写</strong>的，<strong>可读可写</strong>的及<strong>可读</strong>的通道。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span> (buff.hasRemaining())</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buff.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Some text Some more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getChannel()</strong>将会产生一个<strong>FileChannel</strong>。通道是一种相当基础的东西：可以向它传送用于读写的<strong>ByteBuffer</strong>，并且可以锁定文件的某些区域用于独占式访问。</p>
</li>
<li><p>将字节存放于<strong>ByteBufferr</strong>的方法之一是：使用一种“<strong>put</strong>”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<strong>warp()</strong>方法将已存在的字节数组“包装”到<strong>ByteBuffer</strong>中。一旦如此，就不再复制底层的数组，而是把它作为所产生的<strong>ByteBuffer</strong>的存储器，我们称之为数组支持的<strong>ByteBuffer</strong>。</p>
</li>
<li><p>对于只读访问，我们必须显式地使用静态的<strong>allocate()</strong>方法来分配<strong>ByteBuffer</strong>。<strong>nio</strong>的目标就是快速移动大量数据，因此<strong>ByteBuffer</strong>的大小就显得尤为重要。</p>
</li>
<li><p>甚至达到更高的速度也有可能，方法就是使用<strong>allocateDirect()</strong>而不是<strong>allocate()</strong>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p>
</li>
<li><p>一旦调用<strong>read()</strong>来告知<strong>FileChannel</strong>向<strong>ByteBuffer</strong>存储字节，就必须调用缓冲器上的<strong>fip()</strong>，让它做好让别人读取字节的准备。</p>
</li>
<li><p>如果打算使用缓冲器执行进一步的<strong>read()</strong>操作，我们也必须得调用<strong>clear()</strong>来为每个<strong>read()</strong>做好准备。如下面这个简单文件复制程序。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，打开一个<strong>FileChannel</strong>用于读，而打开另一个以用于写。<strong>ByteBuffer</strong>被分配了空间，当<strong>FileChannel.read()</strong>返回<strong>-1</strong>时，表示我们已经到达了输入的末尾。每次<strong>read()</strong>操作之后，就会将数据输入到缓冲器中，<strong>filp()</strong>则是准备缓冲器以便它的信息可以由<strong>write()</strong>提取。<strong>write()</strong>操作之后，信息仍在缓冲器中，接着<strong>clear()</strong>操作则对所有的内部指针重新排序，以便缓冲器在另一个<strong>read()</strong>操作期间能够做好接受数据的准备。</p>
</li>
<li><p>上面的程序并不是处理此类操作的理想方式，特殊方法<strong>transferTo()</strong>和<strong>transferFrom()</strong>允许我们将一个通道和另一个通道直接相连。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><ul>
<li><p>尽管ByteBuffer只能保留字节类型的数据，但是它具有可以从其他所容纳的字节中产生出各种不同基本类型值的方法。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; bb.limit())</span><br><span class="line">            <span class="keyword">if</span> (bb.get() != <span class="number">0</span>)</span><br><span class="line">                System.out.print(<span class="string">"nonzero"</span>);</span><br><span class="line">        System.out.print(<span class="string">"i ="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"Howdy!"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = bb.getChar())!= <span class="number">0</span>)</span><br><span class="line">            System.out.print(c+<span class="string">" "</span>+<span class="string">"\b"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">        System.out.println(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getInt());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getLong());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getFloat());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getDouble());</span><br><span class="line">        bb.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i =1025Howdy!</span></span><br><span class="line"><span class="comment">12390</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">9.9471144E7</span></span><br><span class="line"><span class="comment">9.9471142E7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在分配一个<strong>ByteBuffer</strong>之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零，它的确是这样做的。这里一共检测了<strong>1024</strong>个值(由缓冲器的<strong>limit()</strong>决定)，并且所有的值都是<strong>0</strong>。</p>
</li>
<li><p>向<strong>ByteBuffer</strong>插入基本类型数据的最简单方式是：利用<strong>asCharBuffer(),asShortBuffer()</strong>等获得该缓冲器上的视图，然后使用视图的<strong>put()</strong>方法，使用<strong>ShortBuffer</strong>的<strong>put()</strong>方法时，需要进行类型转换。</p>
</li>
</ul>
<h4 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h4><ul>
<li><p>视图缓冲器(view buffer)可以让我们通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong>。<strong>ByteBuffer</strong>依然是实际存储数据的地方，“支持”着前面的视图。因此，对视图的修改都会映射成为对<strong>ByteBuffer</strong>中数据的修改。这使得我们可以很方便地向<strong>ByteBuffer</strong>插入数据。视图还允许我们从<strong>ByteBuffer</strong>一次一个地或者成批的读取基本类型值。下面，通过<strong>IntBuffer</strong>操纵<strong>ByteBuffer</strong>中的<strong>int</strong>型数值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">888</span>,<span class="number">345</span>,<span class="number">3456</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span> (ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">1811</span></span><br><span class="line"><span class="comment">888</span></span><br><span class="line"><span class="comment">345</span></span><br><span class="line"><span class="comment">3456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先用重载后的<strong>put()</strong>方法存储一个整数数组。接着<strong>get()</strong>和<strong>put()</strong>方法调用直接访问底层<strong>ByteBuffer</strong>中的某个整数位置。</p>
</li>
<li><p>一旦底层的<strong>ByteBuffer</strong>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型。</p>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p>Java I/O类库中的类支持读写压缩格式的数据流，这些类不是从Reader和Writer类派生而来的，而是属于InputStream和OutputStream继承层次结构的一部分。这是因为压缩类库是按字节方式而不是字符方式处理的。</p>
<table>
<thead>
<tr>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CheckedInputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>InputStream</strong>产生校验和(不仅是解压缩)</td>
</tr>
<tr>
<td><strong>CheckedOutputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>OutputStream</strong>产生校验和(不仅是压缩)</td>
</tr>
<tr>
<td><strong>DeflaterOutputStream</strong></td>
<td>压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipOutputStream</strong></td>
<td>一个<strong>DeflaterOutputStream</strong>，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td><strong>GZIPOutputStream</strong></td>
<td>一个个<strong>DeflaterOutputStream</strong>，用于将数据压缩成GZIP文件格式</td>
</tr>
<tr>
<td><strong>InflaterInputStream</strong></td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td><strong>GZIPInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩GZIP文件格式的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h4><ul>
<li><p>如果对单个数据流进行压缩，<strong>GZIP</strong>可能是一个比较适合的选择。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: \nGZIPcompress file\n"</span>+</span><br><span class="line">                    <span class="string">"\tUses GZIP comression to compress"</span> + <span class="string">"the file to test.gz"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"E://test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file"</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read())!= -<span class="number">1</span>)</span><br><span class="line">            out.write(c);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">"D://test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine())!= <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将输出流封装成<strong>GZIPOutputStream</strong>或<strong>ZipOutputStream</strong>，并将输入流封装成<strong>GZIPInputStream</strong>或<strong>ZipInputStream</strong>即可。</p>
</li>
</ul>
<h4 id="Java档案文件"><a href="#Java档案文件" class="headerlink" title="Java档案文件"></a>Java档案文件</h4><ul>
<li><p><strong>Zip</strong>格式也被应用于<strong>JAR</strong>(Java Archive,Java档案文件)文件格式中。这种格式就像<strong>Zip</strong>一样，可以将一组文件压缩到单个压缩文件中。</p>
</li>
<li><p>如果不采用<strong>JAR</strong>文件，<strong>Web</strong>浏览器在下载构成一个应用的所有文件时必须重复多次请求<strong>Web</strong>服务器；而且所有这些文件都是未经压缩的。如果将所有这些文件合并到一个<strong>JAR</strong>文件中，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，可以使传输时间更短。另外，处于安全考虑，<strong>JAR</strong>文件中的每个条目都可以加上数字化签名。</p>
</li>
<li><p><code>jar [options] destination [manifest] inputfile(s)</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>创建一个新的或空的压缩文档</td>
</tr>
<tr>
<td>t</td>
<td>列出目录表</td>
</tr>
<tr>
<td>x</td>
<td>解压所有文件</td>
</tr>
<tr>
<td>x file</td>
<td>解压该文件</td>
</tr>
<tr>
<td>f</td>
<td>意指：“我打算指定一个文件名。” 如果没有用这个选项，jar假设所有的输入都来自标准输入；或者在创建一个文件时，输出对象也假设为标准输出。</td>
</tr>
<tr>
<td>m</td>
<td>表示第一个参数将是用户自建的清单文件的名字</td>
</tr>
<tr>
<td>v</td>
<td>产生详细输出，描述jar所作的工作</td>
</tr>
<tr>
<td>O</td>
<td>只存储文件，不压缩文件(用来创建一个可放在类路径中的JAR文件)</td>
</tr>
<tr>
<td>M</td>
<td>不自动创建文件清单</td>
</tr>
</tbody></table>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul>
<li>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。</li>
<li><strong>Java</strong>的对象序列化将那些实现了<strong>Serializable</strong>接口的对象转换成了一个<strong>字节序列</strong>，并能在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。</li>
<li>序列化可以实现轻量级持久性。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久化的效果。</li>
<li>对象序列化主要是为了支持两种特性：<ol>
<li><strong>Java</strong>的<strong>远程方法调用(Remote Method Invocation,RMI)</strong>，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li>
<li>对<strong>Java Beans</strong>来说，对象的序列化也是必须的。使用<strong>Bean</strong>时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保留下来，并在程序启动时进行后期恢复；这种具体的工作就是由对象序列化完成的。</li>
</ol>
</li>
<li>要序列化一个对象，首先要创建某些<strong>OutputStream</strong>对象，然后将其封装在一个<strong>ObjectOutputStream</strong>对象内。这时，只需要调用<strong>writeObject()</strong>即可将对象序列化，并将其发送给<strong>OutputStream</strong>(对象化序列是基于字节的，因要使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构)。要反向进行该过程(即将一个序列化还原为一个对象)，需要将一个<strong>InputStream</strong>封装在<strong>ObjectInputStream</strong>内，然后调用<strong>readObject()</strong>。我们最后获得的是一个引用，它指向一个向上转型的<strong>Object</strong>，所以必须向下转型才能直接设置它们。</li>
</ul>
<h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><ul>
<li><p>我们将一个对象序列化，并通过网络将其作为文件传递给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个文件吗？</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    setter&amp;getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"D://X.file"</span>));</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://X.file"</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件和读取<strong>mystery</strong>对象的内容都需要<strong>User</strong>的<strong>Class</strong>对象；而<strong>Java</strong>虚拟机找不到<strong>User.class</strong>(除非它正好在类路径<strong>Classpath</strong>内)。这样就会得到一个<strong>ClassNotFoundException</strong>的异常。必须保证<strong>Java</strong>虚拟机能找到相关的<strong>.class</strong>文件。</p>
</li>
</ul>
<h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><ul>
<li>某些情况下你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</li>
<li>在这些特殊情况下，可通过实现<strong>Externalizable</strong>接口—–代替实现<strong>Serialzable</strong>接口—来对序列化进行控制。<strong>Externalizable</strong>接口继承了<strong>Serializable</strong>接口，同时还增加了两个方法：<strong>writeExternal()</strong>和<strong>readExternal()</strong>。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</li>
</ul>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><ul>
<li><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息，通常就会面临这种情况。即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式访问它。</p>
</li>
<li><p>如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个的关闭序列化。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"username = "</span>+username+<span class="string">"&amp;&amp;"</span>+<span class="string">"password = "</span>+password+<span class="string">"&amp;&amp;"</span>+<span class="string">"date"</span>+date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">"Tom"</span>,<span class="string">"11111111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span>+ a);</span><br><span class="line">        ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">                o.writeObject(a);</span><br><span class="line">                o.close();</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Recovering object at "</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        a = (Logon)in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span> + a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = 11111111&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">Recovering object at Sun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = null&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>date</strong>字段被存储到磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
</li>
<li><p>由于<strong>Externalizable</strong>对象在默认情况下不保存它们的任何字段，所以<strong>transient</strong>关键字只能和<strong>Serializable</strong>对象一起使用。</p>
</li>
</ul>

        </div>
        
          


  <section class='meta' id="footer-meta">
    <hr>
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-11-17T21:01:21+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>last updated at Nov 17, 2019</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>java编程思想</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/I-O/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>I/O</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/11/17/java编程思想第十八章/&title=java编程思想第十八章 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://yoursite.com/2019/11/17/java编程思想第十八章/&title=java编程思想第十八章 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/11/17/java编程思想第十八章/&title=java编程思想第十八章 | 编程是一门艺术&summary="
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;Previous</h6>
                            <h4>
                                <a href="/2019/11/17/java编程思想第十二章/" rel="prev" title="java编程思想第十二章">
                                  
                                      java编程思想第十二章
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/java/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>java</a> <a class="tag" href="/tags/java编程思想/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>java编程思想</a> <a class="tag" href="/tags/异常/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>异常</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>Next&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/11/17/java编程思想第十七章/" rel="prev" title="java编程思想第十七章">
                                    
                                        java编程思想第十七章
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/tags/java/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>java</a> <a class="tag" href="/tags/java编程思想/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>java编程思想</a> <a class="tag" href="/tags/容器/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>容器</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'java编程思想第十八章',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;TOC</div>
  
    <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div>
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第十八章-Java-I-O系统"><span class="toc-text">第十八章 Java I/O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File类"><span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#目录列表器"><span class="toc-text">目录列表器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目录的检查及创建"><span class="toc-text">目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入和输出"><span class="toc-text">输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream类型"><span class="toc-text">InputStream类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStream类型"><span class="toc-text">OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加属性和有用的接口"><span class="toc-text">添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过FilterInputStream从InputStream读取数据"><span class="toc-text">通过FilterInputStream从InputStream读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过FilterOutPutStream向OutputStream写入"><span class="toc-text">通过FilterOutPutStream向OutputStream写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader和Writer"><span class="toc-text">Reader和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据的来源和去处"><span class="toc-text">数据的来源和去处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更改流的行为"><span class="toc-text">更改流的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#未发生变化的类"><span class="toc-text">未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自我独立的类：RandomAccessFile"><span class="toc-text">自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O流的典型使用方式"><span class="toc-text">I/O流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲输入文件"><span class="toc-text">缓冲输入文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从内存输入"><span class="toc-text">从内存输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化的内存输入"><span class="toc-text">格式化的内存输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本的文件输出"><span class="toc-text">基本的文件输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#存储和恢复数据"><span class="toc-text">存储和恢复数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写随机访问文件"><span class="toc-text">读写随机访问文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准I-O"><span class="toc-text">标准I/O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从标准输入中读取"><span class="toc-text">从标准输入中读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将System-out转换成PrintWriter"><span class="toc-text">将System.out转换成PrintWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准I-O重定向"><span class="toc-text">标准I/O重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新I-O"><span class="toc-text">新I/O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取基本类型"><span class="toc-text">获取基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#视图缓冲器"><span class="toc-text">视图缓冲器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#压缩"><span class="toc-text">压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#用GZIP进行简单压缩"><span class="toc-text">用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java档案文件"><span class="toc-text">Java档案文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象序列化"><span class="toc-text">对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找类"><span class="toc-text">寻找类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列化的控制"><span class="toc-text">序列化的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transient关键字"><span class="toc-text">transient关键字</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Categories</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(25)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;Hot Tags</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 22px; color: #636363">java编程思想</a> <a href="/tags/jvm/" style="font-size: 20px; color: #707070">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 18px; color: #7e7e7e">多线程</a> <a href="/tags/字符串/" style="font-size: 14px; color: #999">字符串</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/异常/" style="font-size: 14px; color: #999">异常</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/数组/" style="font-size: 14px; color: #999">数组</a> <a href="/tags/枚举/" style="font-size: 14px; color: #999">枚举</a> <a href="/tags/泛型/" style="font-size: 14px; color: #999">泛型</a> <a href="/tags/注解/" style="font-size: 14px; color: #999">注解</a> <a href="/tags/类型信息/" style="font-size: 14px; color: #999">类型信息</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16px; color: #8b8b8b">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
  <div>
    Use
    <a href="" target="_blank" class="codename">Hello World</a>
    as theme
    
      , 
      total visits
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      times
    
    . 
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>



      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "Copied";
  let COPY_FAILURE = "Copy failed";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
