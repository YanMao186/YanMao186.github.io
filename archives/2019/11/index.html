<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2019/11 | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
	
		
  <section class="post-list">
    
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第二十章/">
      java编程思想第二十章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第二十章-注解"><a href="#第二十章-注解" class="headerlink" title="第二十章 注解"></a>第二十章 注解</h2><ul>
<li>==注解(也被称为元数据)为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。==</li>
<li>注解是众多引入到Java SE5中的重要地语言变化之一，它们可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。</li>
<li>注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写“样板”代码的负担。</li>
<li>注解的优点：==更加干净易读的代码以及编译期类型检查等==。</li>
<li>Java SE5中内置了三种注解，定义在java.lang中：<ul>
<li><strong>@Override</strong>：表示当前方法定义将覆盖超类中的方法。</li>
<li><strong>@Deprecated</strong>:如果使用了注解为他的元素。那么编译器会发出警告信息。</li>
<li><strong>@SuppressWarnings</strong>:关闭不当的编译器警告信息。在Java  SE5之前的版本中，也可以使用该注解，不过忽略会被忽略不起作用。</li>
</ul>
</li>
<li>每当你创建描述符性质的类或者接口时，一旦其中包括了重复性的工作。那就可以考虑使用注解来简化自动化该过程。</li>
<li>注解是真正的语言级的概念。一旦构造出来，就享有编译期的类型检查保护。注解(annotation)是在实际的源代码级别保存所有的信息。而不是某种注释性的文字(comment)，这使得代码更简洁，且便于维护。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>下面使用<strong>@Test</strong>对<strong>testExecute()</strong>方法进行注解，该注解本身并不做任何事情，但是编译器要确保在其构造路径上必须有<strong>@Test注</strong>解的定义。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Executing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面中注解的方法与其他的方法没有任何区别，注解<strong>@Test</strong>可以与任何修饰共同作用与方法，如<strong>public</strong>,<strong>static</strong>,<strong>void</strong>，注解的使用方式几乎与修饰符的使用一模一样。</p>
</li>
</ul>
<h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><ul>
<li><p>下面是注解<strong>@Test</strong>的定义，可以看到，注解的定义看起来很像接口，事实上，与其他任何<strong>Java</strong>接口一样，注解也将会编译成class文件。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    Class&lt;? extends Throwable&gt; expected() <span class="keyword">default</span> Test.None.class;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">None</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@Test</strong>的定义很像一个空的接口，定义注解时，会需要一些元注解，如<strong>@Target</strong>和<strong>@Retention</strong>。<strong>@Target</strong>用来定义你的注解将应用于什么地方(如是一个方法或是一个域)。<strong>@Retention</strong>用来定义该注解在那一个级别可用，在源代码中(<strong>SOURCE</strong>)，类文件中(<strong>CLASS</strong>)，或运行时(<strong>RUNTIME</strong>)。</p>
</li>
</ul>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>Java目前内置了四种元注解，元注解专门负责注解其他的注解。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>@Target</strong></td>
<td>表示该注解可以用于什么地方，可能的<strong>ElementType</strong>参数包括：<br><strong>CONSTRUCTOR</strong>：构造器的声明<br><strong>FIELD</strong>:域声明(包括enum实例)<br><strong>LOCAL_VARIABLE</strong>:局部变量声明<br><strong>METHOD</strong>：方法声明<br><strong>PACKAGE</strong>：包声明<br><strong>PARAMETER</strong>:参数声明<br><strong>TYPE</strong>:类，接口(包括注解类型)或<strong>enum</strong>声明</td>
</tr>
<tr>
<td><strong>@Retention</strong></td>
<td>表示需要在什么级别保存该注解信息。可选的<strong>RetentionPolicy</strong>参数包括：<br><strong>SOURCE</strong>：注解将被编译器丢弃。<br><strong>CLASS</strong>:注解在class文件中可用，但会被VM丢弃。<br><strong>RUNTIME</strong>:VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td>
</tr>
<tr>
<td><strong>@Documented</strong></td>
<td>此注解包含在Javadoc中。</td>
</tr>
<tr>
<td><strong>@Inherited</strong></td>
<td>允许子类继承父类中的注解。</td>
</tr>
</tbody></table>
<h3 id="编写注解处理器"><a href="#编写注解处理器" class="headerlink" title="编写注解处理器"></a>编写注解处理器</h3><ul>
<li><p>使用注解的过程中，很重要的一部分就是创建与使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员构造这类工具，它还提供了一个外部工具apt帮助程序员解析带有注解的Java源代码。</p>
</li>
<li><p>下面编写一个注解处理器，用它来读取PasswordUtils类，并使用反射机制查找@UseCase标记。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span>,description = <span class="string">"password must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (password.matches(<span class="string">"\\w*\\d\\w*"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>,description = <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(List&lt;String&gt; prevPasswords,String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(password);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases,Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Found Use Case:"</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : useCases) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Warning:Missing use case"</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Collections.addAll(useCases,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>);</span><br><span class="line">        trackUseCases(useCases,PasswordUtils.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Found Use Case:47 password must contain at least one numeric</span></span><br><span class="line"><span class="comment">Found Use Case:48 no description</span></span><br><span class="line"><span class="comment">Found Use Case:49 New passwords can't equal previously used ones</span></span><br><span class="line"><span class="comment">Warning:Missing use case50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面用到了两个反射的方法：<strong>getDeclaredMethods()</strong>和<strong>getAnnotation()</strong>，<strong>getAnnotation()</strong>返回指定类型的注解对象，此处就是<strong>UseCase</strong>,如果被注解的方法上没有该类型的注解，则返回<strong>null</strong>值。然后我们通过调用<strong>id()</strong>和<strong>description()</strong>方法从返回的<strong>UseCase</strong>对象中提取元素的值。</p>
</li>
</ul>
<h4 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h4><ul>
<li>标签<strong>@UseCase</strong>由<strong>UseCase.java</strong>定义，其中包含<strong>int</strong>元素<strong>id</strong>，以及一个<strong>String</strong>元素<strong>description</strong>。注解元素可用的类型包含以下几种。<ul>
<li>所有基本类型(<strong>int</strong>,<strong>float</strong>,<strong>boolean</strong>等)</li>
<li><strong>String</strong></li>
<li><strong>Class</strong></li>
<li><strong>enum</strong></li>
<li><strong>Annotation</strong></li>
<li>以上类型的数组</li>
</ul>
</li>
<li>如果你使用了其他类型编译器就会报错，也不允许使用任何包装类型。注解也可以作为元素的类型，也就是说注解可以嵌套。</li>
</ul>
<h4 id="默认值限制"><a href="#默认值限制" class="headerlink" title="默认值限制"></a>默认值限制</h4><ul>
<li><p>元素不能有不确定的值，也就是说，元素必须要么具有默认值，要么在使用注解时提供元素的值。</p>
</li>
<li><p>对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以<strong>null</strong>作为其值。</p>
</li>
<li><p>为了绕开这个约束，我们只能自己定义一些特殊的值，如空字符串或负数，以此表示某个元素不存在。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimulatingNull &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="生成外部文件"><a href="#生成外部文件" class="headerlink" title="生成外部文件"></a>生成外部文件</h4><ul>
<li><p>假设你希望提供一些基本类型的对象/关系映射功能，能够自动生成数据库表，用以存储JavaBean对象。使用注解实现此功能，你可以将所有信息都保存在JavaBean源文件中，为此，我们需要一些新的注解，用以定义与Bean关联的数据库表的名字，以及与Bean属性关联的名字和SQL类型。</p>
</li>
<li><p>下面是一个注解的定义，他告诉注解处理器，你需要为我生成一个数据库表：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>==@DBTable有一个name()元素，该注解通过这个元素为处理器创建数据库表提供表的名字。==</p>
</li>
<li><p>接下来为修饰JavaBean域准备的注解：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constrains &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span> <span class="keyword">default</span> @Constrains</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span> <span class="keyword">default</span> @Constrains</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解处理器通过<strong>@Constrains</strong>注解提取出数据库表的元数据，<strong>primaryKey()</strong>,<strong>allowNull()</strong>,<strong>unique()</strong>提供了默认值。</p>
</li>
<li><p>下面两个<strong>@interface</strong>定义的是<strong>SQL</strong>类型。如果希望这个<strong>framework</strong>更有价值的话，就应该为每种<strong>SQL</strong>类型都定义相应的注解。</p>
</li>
<li><p>这些<strong>SQL</strong>类型具有<strong>name()</strong>元素和<strong>constraints()</strong>元素，后者利用了嵌套注解的功能。注意<strong>constraints()</strong>元素的默认值是<strong>@Constraints</strong>。由于<strong>@Constraints</strong>注解类型之后，没有在括号中指明<strong>@Constraints</strong>中的元素的值，因此，<strong>constraints()</strong>元素的默认值实际上就是一个所有元素都为默认值的<strong>@Constraits</strong>注解。如果要令嵌入的<strong>@Constraits</strong>注解中的<strong>unique()</strong>元素为<strong>true</strong>，并以此作为<strong>constraints()</strong>元素的默认值，则需要如下定义该元素。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">    <span class="function">Constrains <span class="title">constrains</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">default</span> @<span class="title">Constrains</span><span class="params">(unique = <span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是一个简单的Bean，我们在其中应用了以上这些注解：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">30</span>)</span><br><span class="line">    String firstName;</span><br><span class="line">    <span class="meta">@SQLString</span>(<span class="number">50</span>)</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="meta">@SQLInteger</span></span><br><span class="line">    Integer age;</span><br><span class="line">    <span class="meta">@SQLString</span>(value = <span class="number">30</span>,constrains = </span><br><span class="line">    <span class="meta">@Constrains</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">    String handle;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>@SQLString</strong>注解有两个有趣的地方：</p>
<ul>
<li>它们都使用了嵌入的<strong>@Constrains</strong>注解的默认值。</li>
<li>它们都使用了快捷方式？就是说如果程序员的注解中定义了名为<strong>value</strong>的元素，并且在应用该注解的时候，如果该元素是唯一需要赋值的一个元素，那么此时无需使用名-值对的这种语法，而只需在括号内给出<strong>value</strong>元素所需的值即可。这可以应用于任何合法类型的元素。</li>
</ul>
</li>
</ul>
<h4 id="变通之道"><a href="#变通之道" class="headerlink" title="变通之道"></a>变通之道</h4><ul>
<li>在上例中，你可以使用一个单一的注解类<strong>@TableColumn</strong>，它带有一个<strong>enum</strong>元素，该枚举类定义了<strong>STRING</strong>，<strong>INTEGER</strong>以及<strong>FLOAT</strong>等枚举类型。这就消除了每个<strong>SQL</strong>类型都需要一个<strong>@interface</strong>定义的负担，不过也使得以额外的信息修饰<strong>SQL</strong>类型的需求变得不可能，而这些额外的信息，如长度或精度等，可能是非常有必要的需求。</li>
<li>我们也可以使用<strong>String</strong>元素来描述实际的<strong>SQL</strong>类型，比如<strong>VARCHAR(30)</strong>或<strong>INTEGER</strong>。但是，它同时也将<strong>Java</strong>类型到<strong>SQL</strong>类型的映射绑在了一起，我们并不希望更换数据库导致代码必须修改并重新编译。</li>
<li>第三种方案是同时使用两个注解类型来注解一个域，<strong>@Constraints</strong>和相应的<strong>SQL</strong>类型(如：<strong>@SQLIntege</strong>)。这种方式可能会使代码有点乱，不过编译器允许程序员对一个目标同时使用多个注解，但是，使用多个注解的时候，同一个注解不能重复使用。</li>
</ul>
<h4 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h4><ul>
<li>不能使用关键字extends来继承某个@interface.在Java未来的版本中，似乎没有任何关于让注解支持继承的提案。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/注解/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>注解</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十九章/">
      java编程思想第十九章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十九章-枚举类型"><a href="#第十九章-枚举类型" class="headerlink" title="第十九章 枚举类型"></a>第十九章 枚举类型</h2><p>关键字<strong>enum</strong>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<h3 id="基本enum特性"><a href="#基本enum特性" class="headerlink" title="基本enum特性"></a>基本enum特性</h3><ul>
<li><p>创建enum时，编译器会为你生成一个相关的类，这个类继承自<strong>java.lang.Enum</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Shrubbery &#123;</span><br><span class="line">    GROUND,CRAWLING,HANGING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Shrubbery s : Shrubbery.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">"ordinal:"</span> + s.ordinal());</span><br><span class="line">            System.out.println(s.compareTo(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(s.equals(Shrubbery.CRAWLING) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(s == Shrubbery.CRAWLING);</span><br><span class="line">            System.out.println(s.getDeclaringClass());</span><br><span class="line">            System.out.println(s.name());</span><br><span class="line">            System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span> (String s : <span class="string">"HANGING CRAWLING GROUND"</span>.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">                Shrubbery shrubbery = Enum.valueOf(Shrubbery.class, s);</span><br><span class="line">                System.out.println(shrubbery);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GROUNDordinal:0</span></span><br><span class="line"><span class="comment">-1 </span></span><br><span class="line"><span class="comment">false </span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">CRAWLINGordinal:1</span></span><br><span class="line"><span class="comment">0 </span></span><br><span class="line"><span class="comment">true </span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">HANGINGordinal:2</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">false </span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.com.ym.ThinkInJava15.Shrubbery</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ordinal()</strong>方法返回一个<strong>int</strong>值，这是每个<strong>enum</strong>实例在声明时的次序，从<strong>0</strong>开始。可以使用<strong>==</strong>来比较<strong>enum</strong>实例，编译器会自动为你提供<strong>equals()</strong>和<strong>hashCode()</strong>方法。</p>
</li>
<li><p><strong>Enum</strong>类实现了<strong>Comparable</strong>接口，所以它具有<strong>compareTo()</strong>方法。同时，它还实现了<strong>Serializable</strong>接口。</p>
</li>
<li><p>如果在<strong>enum</strong>实例上调用<strong>getDeclaringClass()</strong>方法，我们就能知道其所属的<strong>enum</strong>类。</p>
</li>
<li><p><strong>name()</strong>方法返回<strong>enum</strong>实例声明时的名字，这与使用<strong>toString()</strong>方法效果相同。<strong>valueOf()</strong>是在<strong>Enum</strong>中定义的<strong>static</strong>方法，它根据给定名字返回相应的<strong>enum</strong>实例，如果不存在给定名字的实例，将会抛出异常。</p>
</li>
</ul>
<h4 id="将静态导入用于enum"><a href="#将静态导入用于enum" class="headerlink" title="将静态导入用于enum"></a>将静态导入用于enum</h4><ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Spiciness &#123;</span><br><span class="line">    NOT,MILD,MEDIUM,HOT,FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Burrito&#123;"</span> +</span><br><span class="line">                <span class="string">"degree="</span> + degree +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(NOT));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(MEDIUM));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Burrito(HOT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=NOT&#125;</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=MEDIUM&#125;</span></span><br><span class="line"><span class="comment">Burrito&#123;degree=HOT&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>static import</strong>能够将<strong>enum</strong>实例的标识符带入当前的命名空间，所以无需再用<strong>enum</strong>类型来修饰<strong>enum</strong>实例。</p>
</li>
</ul>
<h3 id="向enum中添加新方法"><a href="#向enum中添加新方法" class="headerlink" title="向enum中添加新方法"></a>向enum中添加新方法</h3><ul>
<li><p>除了不能继承自一个<strong>enum</strong>之外，我们基本上可以将<strong>enum</strong>看作一个常规的类。也就是说我们可以向<strong>enum</strong>中添加方法。<strong>enum</strong>甚至可以有<strong>main()</strong>方法。</p>
</li>
<li><p>一般来说，我们希望每个枚举实例都能够返回对自身的描述，而不仅仅只是默认的toString()实现，这只能够返回枚举实例的名字。为此，你可以创建一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。如下</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OzWitch &#123;</span><br><span class="line">    WEST(<span class="string">"Miss Gulch,aka the Wicked Witch of the West"</span>),</span><br><span class="line">    NORTH(<span class="string">"Glinda, the good witch of the north"</span>),</span><br><span class="line">    EAST(<span class="string">"Wicked Witch of the East.wearer of the Ruby"</span>+<span class="string">"Slippers,crushed by Dorothy`s house"</span>),</span><br><span class="line">    SOUTH(<span class="string">"Good by inference,but missing"</span>);</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    OzWitch(String description) &#123;</span><br><span class="line">        <span class="comment">//必须添加有参构造否则会报错</span></span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OzWitch witch : OzWitch.values()) &#123;</span><br><span class="line">            System.out.println(witch+<span class="string">": "</span>+witch.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WEST: Miss Gulch,aka the Wicked Witch of the West</span></span><br><span class="line"><span class="comment">NORTH: Glinda, the good witch of the north</span></span><br><span class="line"><span class="comment">EAST: Wicked Witch of the East.wearer of the RubySlippers,crushed by Dorothy`s house</span></span><br><span class="line"><span class="comment">SOUTH: Good by inference,but missing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你打算定义自己的方法，那么必须在<strong>enum</strong>实例序列的最后添加一个分号。同时<strong>Java</strong>要求你必须定义一个<strong>enum</strong>实例。如果在定义<strong>enum</strong>实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。</p>
</li>
<li><p><strong>enum</strong>中的构造器与方法和普通的类没有什么区别，因为除了有少许限制外，<strong>enum</strong>就是一个普通的类。</p>
</li>
<li><p>上面我们将<strong>enum</strong>中的构造器声明为<strong>private</strong>，但对于它的可访问性而言，其实并没有什么变化，因为(即使不声明为<strong>private</strong>)我们只能在<strong>enum</strong>定义的内部使用其构造器创建<strong>enum</strong>实例。一旦<strong>enum</strong>地定义失败，编译器就不允许我们再使用其构造器来创建任何实例。</p>
</li>
</ul>
<h4 id="覆盖enum的方法"><a href="#覆盖enum的方法" class="headerlink" title="覆盖enum的方法"></a>覆盖enum的方法</h4><ul>
<li><p>覆盖<strong>toString()</strong>方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息，下面，我们使用的就是实例的名字，不过我们希望改变其格式。覆盖<strong>enum</strong>的<strong>toString()</strong>方法与覆盖一般类的方法没有什么区别。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SpaceShip &#123;</span><br><span class="line">    SCOUT,CARGO,TRANSPORT,CRUISER,BATTLESHIP,MOTHERSHIP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = name();</span><br><span class="line">        String lower = id.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> id.charAt(<span class="number">0</span>)+lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SpaceShip name : values()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scout</span></span><br><span class="line"><span class="comment">Cargo</span></span><br><span class="line"><span class="comment">Transport</span></span><br><span class="line"><span class="comment">Cruiser</span></span><br><span class="line"><span class="comment">Battleship</span></span><br><span class="line"><span class="comment">Mothership</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>toString()</strong>方法通过调用<strong>name()</strong>方法取得<strong>SpaceShip</strong>的名字，然后将其修改为只有首字母大写的格式。</p>
</li>
</ul>
<h3 id="values-的神秘之处"><a href="#values-的神秘之处" class="headerlink" title="values()的神秘之处"></a>values()的神秘之处</h3><ul>
<li><p>编译器为你创建的enum类都继承自Enum类，但是Enum类并没有values()方法，但是我们却使用过该方法，难道存在某种“隐藏的方法吗？？？”，我们可以通过反射机制编写一个简单的程序，一探究竟。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Explore &#123;</span><br><span class="line">    HERE,THERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">analyze</span><span class="params">(Class&lt;?&gt; enumClass)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Interfaces: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Type type : enumClass.getGenericInterfaces())</span><br><span class="line">            System.out.println(type);</span><br><span class="line">        System.out.println(<span class="string">"Base: "</span> + enumClass.getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">"Method: "</span>);</span><br><span class="line">        Set&lt;String&gt; methods = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method m : enumClass.getMethods())</span><br><span class="line">            methods.add(m.getName());</span><br><span class="line">        System.out.println(methods);</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; exploreMethods = analyze(Explore.class);</span><br><span class="line">        Set&lt;String&gt; enumMethods = analyze(Enum.class);</span><br><span class="line">        System.out.println(<span class="string">"Explore.containsAll(Enum)? "</span>+enumMethods.containsAll(enumMethods));</span><br><span class="line">        System.out.println(<span class="string">"Explore.removeAll(Enum): "</span>);</span><br><span class="line">        exploreMethods.removeAll(enumMethods);</span><br><span class="line">        System.out.println(exploreMethods);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Interfaces: </span></span><br><span class="line"><span class="comment">Base: class java.lang.Enum</span></span><br><span class="line"><span class="comment">Method: </span></span><br><span class="line"><span class="comment">[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, values, wait]</span></span><br><span class="line"><span class="comment">Interfaces: </span></span><br><span class="line"><span class="comment">java.lang.Comparable&lt;E&gt;</span></span><br><span class="line"><span class="comment">interface java.io.Serializable</span></span><br><span class="line"><span class="comment">Base: class java.lang.Object</span></span><br><span class="line"><span class="comment">Method: </span></span><br><span class="line"><span class="comment">[compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, wait]</span></span><br><span class="line"><span class="comment">Explore.containsAll(Enum)? true</span></span><br><span class="line"><span class="comment">Explore.removeAll(Enum): </span></span><br><span class="line"><span class="comment">[values]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结论是，values()方法是由编译器添加的static方法。</p>
</li>
</ul>
<h3 id="实现，而非继承"><a href="#实现，而非继承" class="headerlink" title="实现，而非继承"></a>实现，而非继承</h3><ul>
<li><h5 id="所有的enum都继承自java-lang-Enum类，由于Java不支持多重继承，所以你的-enum不能再继承其他类-。"><a href="#所有的enum都继承自java-lang-Enum类，由于Java不支持多重继承，所以你的-enum不能再继承其他类-。" class="headerlink" title="所有的enum都继承自java.lang.Enum类，由于Java不支持多重继承，所以你的==enum不能再继承其他类==。"></a>所有的<strong>enum</strong>都继承自<strong>java.lang.Enum</strong>类，由于Java不支持多重继承，所以你的==enum不能再继承其他类==。</h5></li>
<li><p>但是，在我们创建一个新的<strong>enum</strong>时，可以同时实现一个或多个接口。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CartoonCharacter implements Generator&lt;CartoonCharacter&gt; &#123;</span><br><span class="line">    SLAPPY,SPANKY,PUNCHY,SILLY,BOUNCY,NUTTY,BOB;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CartoonCharacter <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values()[rand.nextInt(values().length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumImplementation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printNext</span><span class="params">(Generator&lt;T&gt; rg)</span> </span>&#123;</span><br><span class="line">        System.out.println(rg.next()+<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CartoonCharacter cc = CartoonCharacter.BOB;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            printNext(cc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOB,</span></span><br><span class="line"><span class="comment">PUNCHY,</span></span><br><span class="line"><span class="comment">BOB,</span></span><br><span class="line"><span class="comment">SPANKY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">PUNCHY,</span></span><br><span class="line"><span class="comment">SLAPPY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">NUTTY,</span></span><br><span class="line"><span class="comment">SLAPPY,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果有点奇怪，不过你必须要有一个<strong>enum</strong>实例才能调用其上的方法，现在，在任何接受<strong>Generator</strong>参数的方法中，如<strong>printNext()</strong>,都可以使用<strong>CartoonCharacter</strong>。</p>
</li>
</ul>
<h3 id="使用接口组织枚举"><a href="#使用接口组织枚举" class="headerlink" title="使用接口组织枚举"></a>使用接口组织枚举</h3><ul>
<li><p>无法从<strong>enum</strong>继承子类有时很令人沮丧，这种需求有时源自我们希望扩展原<strong>enum</strong>中的元素，有时是因为我们希望使用将一个<strong>enum</strong>中的元素进行分类。</p>
</li>
<li><p>在一个接口内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类的目的。</p>
</li>
<li><p>下面假设你想要用<strong>enum</strong>来表示不同类别的食物，同时还希望每个<strong>enum</strong>元素仍然保持<strong>Food</strong>类型，可以这样实现。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Appetizer implements Food &#123;</span><br><span class="line">        SALAD,SOUP,SPRONG_ROLLS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> MainCourse implements Food &#123;</span><br><span class="line">        LASAGNE,BURRITO,PAD_THAI,</span><br><span class="line">        LENTILS,HUMMOUS,VINDALOO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Dessert implements Food &#123;</span><br><span class="line">        TIRAMISU,GELATO,BLACK_FOREST_CAKE,</span><br><span class="line">        FRUIT,CREME_CARAMEL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Coffee implements Food &#123;</span><br><span class="line">        BLACK_COFFEE,DECAF_COFFEE,ESPRESSO,</span><br><span class="line">        LATTE,CAPPUCCINO,TEA,HERB_TEA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<strong>enum</strong>而言，实现接口是使其子类化的唯一方法，所以嵌入在<strong>Food</strong>中的每个<strong>enum</strong>都实现了<strong>Food</strong>接口。下面，我们可以说“==所有的东西都是某种类型的<strong>Food</strong>==”。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeFood</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = Food.Appetizer.SALAD;</span><br><span class="line">        food = Food.MainCourse.LASAGNE;</span><br><span class="line">        food = Food.Dessert.GELATO;</span><br><span class="line">        food = Food.Coffee.CAPPUCCINO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<strong>enum</strong>类型实现了<strong>Food</strong>接口，那么就可以将其实例向上转型为<strong>Food</strong>，所以上面中的所有东西都是<strong>Food</strong>。</p>
</li>
<li><p>当我们需要与一大堆类型打交道时，接口就不如<strong>enum</strong>好了，如你想创建一个“枚举的枚举”，那么可以创建一个新的<strong>enum</strong>，然后用其实例包装<strong>Food</strong>中的每一个<strong>enum</strong>类。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">random</span><span class="params">(Class&lt;T&gt; ec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values[random.nextInt(values.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Course &#123;</span><br><span class="line">    APPETIZER(Food.Appetizer.class),</span><br><span class="line">    MAINCOURSE(Food.MainCourse.class),</span><br><span class="line">    DESSERT(Food.Dessert.class),</span><br><span class="line">    COFFEE(Food.Coffee.class);</span><br><span class="line">    <span class="keyword">private</span> Food[] values;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Course</span><span class="params">(Class&lt;? extends Food&gt; kind)</span> </span>&#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面中，每一个Course的实例都将其对应的Class对象作为构造器的参数。通过getEnumConstants()方法，乐意从该Class对象中取得某个Food子类的所有enum实例。这些实例在randomSelection()中被用到，因此，通过从每个Course实例中随机地选择一个Food，我们便能够生成一份菜单。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Course course : Course.values()) &#123;</span><br><span class="line">                Food food = course.randomSelection();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"========"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SPRONG_ROLLS</span></span><br><span class="line"><span class="comment">VINDALOO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">DECAF_COFFEE</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SOUP</span></span><br><span class="line"><span class="comment">VINDALOO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">TEA</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SALAD</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">FRUIT</span></span><br><span class="line"><span class="comment">TEA</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SALAD</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">CREME_CARAMEL</span></span><br><span class="line"><span class="comment">LATTE</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">SOUP</span></span><br><span class="line"><span class="comment">BURRITO</span></span><br><span class="line"><span class="comment">TIRAMISU</span></span><br><span class="line"><span class="comment">ESPRESSO</span></span><br><span class="line"><span class="comment">========</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面中，我们通过遍历每一个<strong>Course</strong>实例来获得“枚举的枚举”。</p>
</li>
<li><p>除此之外，还有一种更简洁的管理枚举的方法，就是将一个<strong>enum</strong>嵌套在另一个<strong>enum</strong>内，如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SecurityCategory &#123;</span><br><span class="line">    STOCK(Security.Stock.class),</span><br><span class="line">    BOND(Security.Bond.class);</span><br><span class="line">    Security[] values;</span><br><span class="line">    SecurityCategory(Class&lt;? extends Security&gt; kind) &#123;</span><br><span class="line">        values = kind.getEnumConstants();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Stock implements Security &#123;</span><br><span class="line">        SHORT,LONG,MARGIN</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Bond implements Security &#123;</span><br><span class="line">        MUNICIPAL,JUNK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Security <span class="title">randomSelecttion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enums.random(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            SecurityCategory category = Enums.random(SecurityCategory.class);</span><br><span class="line">            System.out.println(category+<span class="string">":"</span>+category.randomSelecttion());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">STOCK:MARGIN</span></span><br><span class="line"><span class="comment">STOCK:MARGIN</span></span><br><span class="line"><span class="comment">BOND:JUNK</span></span><br><span class="line"><span class="comment">STOCK:SHORT</span></span><br><span class="line"><span class="comment">STOCK:LONG</span></span><br><span class="line"><span class="comment">STOCK:LONG</span></span><br><span class="line"><span class="comment">BOND:MUNICIPAL</span></span><br><span class="line"><span class="comment">BOND:JUNK</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Security</strong>接口的作用是将其所包含的<strong>enum</strong>组合成一个公共类型，这一点是有必要的。然后，<strong>SecurityCategorg</strong>才能将<strong>Security</strong>中的<strong>enum</strong>作为其构造器的参数，以起到组织的效果。</p>
</li>
</ul>
<h3 id="使用EnumSet替代标志"><a href="#使用EnumSet替代标志" class="headerlink" title="使用EnumSet替代标志"></a>使用EnumSet替代标志</h3><ul>
<li><p><strong>Set</strong>是一种集合，只能向其中添加不重复的对象，<strong>enum</strong>也要求其成员都是唯一的，所以<strong>enum</strong>看起来也具有集合的行为。不过，由于不能从<strong>enum</strong>中删除或添加元素，所以他只能算是不太有用的集合。</p>
</li>
<li><p>Java SE5引入EnumSet，是为了通过enum创建一种替代品，以替代传统的基于int的“位标识”。这种标识可以用来表示某种“开/关”信息，不过，使用这种标识，我们最终操作的只是一些bit，而不是这些bit想要表达的概念。</p>
</li>
<li><p>EnumSet的设计充分考虑到速度因素，因为他必须与非常高效的bit标识相竞争(其操作与HashSet相比，非常地快)。就其内部而言，它（可能）就是一个long值作为比特向量，所以EnumSet非常快读高效。使用EnumSet的优点是，他在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。</p>
</li>
<li><p>EnumSet中的元素必须来自一个enum。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AlarmPoits &#123;</span><br><span class="line">    STAIR1,STAIR2,LOBBY,OFFICE1,OFFICE2,</span><br><span class="line">    OFFICE3,OFFICE4,BATHROOM,UTILITY,KITCHEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;AlarmPoits&gt; poits = EnumSet.noneOf(AlarmPoits.class);</span><br><span class="line">        poits.add(AlarmPoits.BATHROOM);</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits.addAll(EnumSet.of(AlarmPoits.STAIR1,AlarmPoits.STAIR2,AlarmPoits.KITCHEN));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits = EnumSet.allOf(AlarmPoits.class);</span><br><span class="line">        poits.removeAll(EnumSet.of(AlarmPoits.STAIR1,AlarmPoits.STAIR2,AlarmPoits.KITCHEN));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits.removeAll(EnumSet.range(AlarmPoits.OFFICE1,AlarmPoits.OFFICE2));</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">        poits = EnumSet.complementOf(poits);</span><br><span class="line">        System.out.println(poits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[BATHROOM]</span></span><br><span class="line"><span class="comment">[STAIR1, STAIR2, BATHROOM, KITCHEN]</span></span><br><span class="line"><span class="comment">[LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY]</span></span><br><span class="line"><span class="comment">[LOBBY, OFFICE3, OFFICE4, BATHROOM, UTILITY]</span></span><br><span class="line"><span class="comment">[STAIR1, STAIR2, OFFICE1, OFFICE2, KITCHEN]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>EnumSet</strong>的基础是<strong>long</strong>，一个<strong>long</strong>值有<strong>64</strong>位而一个<strong>enum</strong>实例只需一位<strong>bit</strong>表示其是否存在。也就是说，在不超过一个<strong>long</strong>的表达能力的情况下，你的<strong>EnumSet</strong>可以应用于最多不超过<strong>64</strong>个元素的<strong>enum</strong>。如果<strong>enum</strong>超过了<strong>64</strong>个元素会发生什么呢？</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEnumSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Big &#123;</span><br><span class="line">        A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,</span><br><span class="line">        A11,A12,A13,A14,A15,A16,A17,A18,A19,A20,</span><br><span class="line">        A21,A22,A23,A24,A25,A26,A27,A28,A29,A30,</span><br><span class="line">        A31,A32,A33,A34,A35,A36,A37,A38,A39,A40,</span><br><span class="line">        A41,A42,A43,A44,A45,A46,A47,A48,A49,A50,</span><br><span class="line">        A51,A52,A53,A54,A55,A56,A57,A58,A59,A60 ,</span><br><span class="line">        A61,A62,A63,A64,A65,A66,A67,A68,A69,A70,</span><br><span class="line">        A71,A72,A73,A74,A75,A76,A77,A78,A79,A80</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet&lt;Big&gt; bigEnumSet = EnumSet.allOf(Big.class);</span><br><span class="line">        System.out.println(bigEnumSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, </span></span><br><span class="line"><span class="comment">A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, </span></span><br><span class="line"><span class="comment">A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, </span></span><br><span class="line"><span class="comment">A31, A32, A33, A34, A35, A36, A37, A38, A39, A40, </span></span><br><span class="line"><span class="comment">A41, A42, A43, A44, A45, A46, A47, A48, A49, A50, </span></span><br><span class="line"><span class="comment">A51, A52, A53, A54, A55, A56, A57, A58, A59, A60, </span></span><br><span class="line"><span class="comment">A61, A62, A63, A64, A65, A66, A67, A68, A69, A70, </span></span><br><span class="line"><span class="comment">A71, A72, A73, A74, A75, A76, A77, A78, A79, A80]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>EnumSet</strong>可以应用于多过<strong>64</strong>个元素的<strong>enum</strong>，所以，<strong>Enum</strong>会在必要的时候增加一个<strong>long</strong>。</p>
</li>
</ul>
<h3 id="使用EnumMap"><a href="#使用EnumMap" class="headerlink" title="使用EnumMap"></a>使用EnumMap</h3><ul>
<li><p>EnumMap是一种特殊的Map，他要求其中的键(key)必须来自一个enum，由于enum本身的限制，所以EnumMap在内部可由数组实现。因此EnumMap的速度很快，我们可以放心的使用enum实例在EnumMap中进行查找操作。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMaps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumMap&lt;AlarmPoits,Command&gt; em = <span class="keyword">new</span> EnumMap&lt;AlarmPoits, Command&gt;(AlarmPoits.class);</span><br><span class="line">        em.put(AlarmPoits.KITCHEN,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Kitchen fire"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        em.put(AlarmPoits.BATHROOM,<span class="keyword">new</span> Command()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Bathroom alert"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;AlarmPoits, Command&gt; e : em.entrySet()) &#123;</span><br><span class="line">            System.out.println(e.getKey()+<span class="string">": "</span>);</span><br><span class="line">            e.getValue().action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        em.get(AlarmPoits.UTILITY).action();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BATHROOM: </span></span><br><span class="line"><span class="comment">Bathroom alert</span></span><br><span class="line"><span class="comment">KITCHEN: </span></span><br><span class="line"><span class="comment">Kitchen fire</span></span><br><span class="line"><span class="comment">java.lang.NullPointerException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与<strong>EnumSet</strong>一样，<strong>enum</strong>实例定义时的次序决定了其在<strong>EnumMap</strong>中的顺序。</p>
</li>
<li><p><strong>EnumMap</strong>有一个优点，那<strong>EnumMap</strong>允许程序员改变值对象，而常量相关的方法在编译期就被固定了。</p>
</li>
<li><p>在你有多种类型的<strong>enum</strong>，而且它们之间存在互操作的情况下，我们可以用<strong>EnumMap</strong>实现多路分发。</p>
</li>
</ul>
<h3 id="多路分发"><a href="#多路分发" class="headerlink" title="多路分发"></a>多路分发</h3><ul>
<li><p>当你要处理多种交互类型时，程序可能会变得相当复杂。如：如果一个系统要分析和执行数学表达式。我们可能会声明Number.plus(Number),Number.plus(Number)等等，其中Number是各种数学对象的超类。当你声明a.plus(b)时，你并不知道a或b的确切类型，那你如何能让它们正确的交互呢？？？？？</p>
</li>
<li><p>Java只支持单路分发。也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么Java的动态绑定机制只能处理其中一个的类型。这样就无法解决我们上面提到的问题，所以，你必须自己来绑定其他的类型，从而实现自己的动态绑定行为。</p>
</li>
<li><p>解决上面问题的方法就是多路分发，多态只能发生在方法调用时，所以，如果你想使用多路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知类型。</p>
</li>
<li><p>要利用多路分发，我们必须为每一个类型提供一个实际的方法调用，如果你要处理两个不同的类型体系，就需要为每个类型体系执行一个方法调用。</p>
</li>
<li><p>一般而言，需要有设定好的某种配置，以便一个方法调用能够引出更多的方法调用，从而能够在这个过程中处理多种类型。为了达到这种效果，我们需要与多个方法一同工作：因为每个分发都需要一个方法调用。</p>
</li>
<li><p>下面例子中(实现了”石头”，”剪刀”，”布”游戏)对应的方法是compete()和eval()，两者都是同一个类型的成员，它们可以产生三种Outcome实例中的一个作为结果：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Outcome &#123;</span><br><span class="line">    WIN,LOSE,DRAW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Outcome <span class="title">compete</span><span class="params">(Item it)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Paper p)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Scissors s)</span></span>;</span><br><span class="line"><span class="function">Outcome <span class="title">eval</span><span class="params">(Rock r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paper</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.DRAW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Paper"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scissors</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.DRAW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Scissors"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rock</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">compete</span><span class="params">(Item it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> it.eval(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Paper p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Scissors s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.LOSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outcome <span class="title">eval</span><span class="params">(Rock r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Outcome.WIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rock"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoShamBo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Item <span class="title">newItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="keyword">new</span> Scissors();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> <span class="keyword">new</span> Paper();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span> <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(Item a,Item b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a+<span class="string">"vs. "</span>+b+<span class="string">":"</span>+a.compete(b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            match(newItem(),newItem());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Rockvs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Scissors:DRAW</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Paper:DRAW</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Rockvs. Scissors:WIN</span></span><br><span class="line"><span class="comment">Rockvs. Paper:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Rock:WIN</span></span><br><span class="line"><span class="comment">Scissorsvs. Paper:WIN</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">Papervs. Scissors:LOSE</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Item是这几种类型的接口，将会被用作多路分发，RoShamBo1.match()有两个Item参数，通过调用Item.compete()方法开始两路分发。</p>
</li>
<li><p>要判断a的类型，分发机制会在a的实际类型的compete()内部起到分发的作用。compete()方法通过调用eval()来为另一个类型实现第二次分发。将自身(this)作为参数调用eval()，能够调用重载过的eval()方法,这能够保留第一次分发的类型信息。</p>
</li>
<li><p>要配置好多路分发需要很多工序，不过，他的好处在于方法调用时的优雅的语法</p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/枚举/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>枚举</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十六章/">
      java编程思想第十六章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十六章-数组"><a href="#第十六章-数组" class="headerlink" title="第十六章 数组"></a>第十六章 数组</h2><h3 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h3><ul>
<li>数组于其他种类的容器之间的区别有三方面：<strong>效率</strong>，<strong>类型</strong>和<strong>保存基本类型的能力</strong>。<ol>
<li>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价是数组对象的大小被固定，并且在其生命周期中不可变。</li>
<li>在泛型之前，其他的容器类在处理对象时，都将他们视作没有任何具体类型。就是说。他们将这些对象都当作Java中所有类的根类Object处理。数组之所以优于泛型之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译期检查，来防止插入错误类型和抽取不当类型。</li>
<li>数组可以持有基本类型，而泛型之前的容器则不能。但是有了泛型，容器就可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。</li>
</ol>
</li>
<li>随着自动包装机制的出现，容器已经可以与数组几乎一样方便地用于基本类型中了。数组硕果仅存的优点就是效率。然而，如果要解决更一般化的问题，那数组就可能受到过多的限制，因此在这些情况下你还是会使用容器。</li>
</ul>
<h3 id="数组是第一级对象"><a href="#数组是第一级对象" class="headerlink" title="数组是第一级对象"></a>数组是第一级对象</h3><ul>
<li><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个(数组)对象用以保存指向其他对象的引用。</p>
</li>
<li><p>对象数组和基本类型数组在使用上几乎是相同的；唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BerylliumSphere</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sphere"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerComparison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BerylliumSphere[] sphere = <span class="keyword">new</span> BerylliumSphere[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            sphere[i] = <span class="keyword">new</span> BerylliumSphere();</span><br><span class="line">        System.out.println(Arrays.toString(sphere));</span><br><span class="line">        System.out.println(sphere[<span class="number">4</span>]);</span><br><span class="line">        List&lt;BerylliumSphere&gt; sphereList = <span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">5</span>; i1++)</span><br><span class="line">            sphereList.add(<span class="keyword">new</span> BerylliumSphere());</span><br><span class="line">        System.out.println(sphereList);</span><br><span class="line">        System.out.println(sphereList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] integers = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">        System.out.println(integers[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        intList.add(<span class="number">97</span>);</span><br><span class="line">        System.out.println(intList);</span><br><span class="line">        System.out.println(intList.get(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Sphere0, Sphere1, Sphere2, Sphere3, Sphere4, null, null, null, null, null]</span></span><br><span class="line"><span class="comment">Sphere4</span></span><br><span class="line"><span class="comment">[Sphere5, Sphere6, Sphere7, Sphere8, Sphere9]</span></span><br><span class="line"><span class="comment">Sphere9</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 97]</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BerylliumSphere[] a;</span><br><span class="line">    BerylliumSphere[] b = <span class="keyword">new</span> BerylliumSphere[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">"b"</span>+ Arrays.toString(b));</span><br><span class="line">        BerylliumSphere[] c = <span class="keyword">new</span> BerylliumSphere[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="keyword">null</span>)</span><br><span class="line">                c[i] = <span class="keyword">new</span> BerylliumSphere();</span><br><span class="line">        BerylliumSphere[] d = &#123; <span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        <span class="keyword">new</span> BerylliumSphere(),<span class="keyword">new</span> BerylliumSphere()</span><br><span class="line">        &#125;;</span><br><span class="line">        a = <span class="keyword">new</span> BerylliumSphere[] &#123;</span><br><span class="line">                <span class="keyword">new</span> BerylliumSphere(),<span class="keyword">new</span> BerylliumSphere(),</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"a.length = "</span>+a.length);</span><br><span class="line">        System.out.println(<span class="string">"b.length = "</span>+b.length);</span><br><span class="line">        System.out.println(<span class="string">"c.length = "</span>+c.length);</span><br><span class="line">        System.out.println(<span class="string">"d.length = "</span>+d.length);</span><br><span class="line">        a = d;</span><br><span class="line">        System.out.println(<span class="string">"a.length = "</span>+a.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] e;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">"f: "</span>+ Arrays.toString(f));</span><br><span class="line">        <span class="keyword">int</span>[] g = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.length; i++)</span><br><span class="line">            g[i] = i * i;</span><br><span class="line">        <span class="keyword">int</span>[] h = &#123;<span class="number">11</span>,<span class="number">47</span>,<span class="number">93</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"f.length ="</span> +f.length);</span><br><span class="line">        System.out.println(<span class="string">"g.length ="</span> +g.length);</span><br><span class="line">        System.out.println(<span class="string">"h.length ="</span> +h.length);</span><br><span class="line">        e = h;</span><br><span class="line">        System.out.println(<span class="string">"e.length ="</span> +e.length);</span><br><span class="line">        e = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"e.length ="</span> +e.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b[null, null, null, null, null]</span></span><br><span class="line"><span class="comment">a.length = 2</span></span><br><span class="line"><span class="comment">b.length = 5</span></span><br><span class="line"><span class="comment">c.length = 4</span></span><br><span class="line"><span class="comment">d.length = 3</span></span><br><span class="line"><span class="comment">a.length = 3</span></span><br><span class="line"><span class="comment">f: [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">f.length =5</span></span><br><span class="line"><span class="comment">g.length =4</span></span><br><span class="line"><span class="comment">h.length =3</span></span><br><span class="line"><span class="comment">e.length =3</span></span><br><span class="line"><span class="comment">e.length =2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组a是一个尚未被初始化的局部变量，在你对他正确的初始化之前，编译期不允许用此引用做任何事情。</p>
</li>
<li><p>数组b初始化为指向一个<strong>BerylliumSphere</strong>引用的数组，但其实并没有<strong>BerylliumSphere</strong>对象置入数组中。</p>
</li>
<li><p>length是数组的大小，而不是实际保存的元素个数，新生成一个数组对象时，其中所有的引用被自动的初始化为null；所以检查其中的引用是否为null，即可知道数组的某个位置是否存有对象。</p>
</li>
<li><p>基本类型的数组如果是数值型，就会被自动初始化为0；如果是字符型(char)，就会被自动初始化为(char)O；如果是布尔型，就被自动初始化为false。</p>
</li>
</ul>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul>
<li><p>对于基本类型的多维数组，可以通过使用花括号将每个向量分隔开。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultidimensionalPrimitiveArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面使用<strong>Java SE5</strong>的<strong>Arrays.deepToString()</strong>方法，它可以将多维数组转换为多个<strong>String</strong>，还可以使用<strong>new</strong>来分配数组，下面的三维数组就是在<strong>new</strong>表达式中分配的：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSWithNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">		System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到基本类型数组的值在不进行显式初始化的情况下，会被自动初始化。对象数组会被初始化为<strong>null</strong>。</p>
</li>
</ul>
<h3 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h3><ul>
<li><p>通常，数组与泛型不能很好的结合，你不能实例化具有参数化类型的数组：==Peel<banana> [] peels = new Peel<banana>[10];==，擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。但是，你可以参数化数组本身的类型。</banana></banana></p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParmeterizedArrayType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubles = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>&#125;;</span><br><span class="line">        Integer[] ints2 = <span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2 = <span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        ints2 = MethodParameter.f(ints);</span><br><span class="line">        doubles2 = MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用参数化方法而不使用参数化类的方便之处在于：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的。</p>
</li>
<li><p>如上，不能创建泛型数组这一说法并不十分正确，编译期确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用，如：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这条语句可以顺利地通过编译期而不报任何错误。而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayOfGenerics</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt;[] ls;</span><br><span class="line">        List[] la = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        ls = (List&lt;String&gt;[])la;</span><br><span class="line">        ls[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        Object[] objects = ls;</span><br><span class="line">        objects[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;BerylliumSphere&gt;[] spheres = (List&lt;BerylliumSphere&gt;[])<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spheres.length; i++) &#123;</span><br><span class="line">            spheres[i] = <span class="keyword">new</span> ArrayList&lt;BerylliumSphere&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦拥有对List<string>[]的引用，你就会看到你将得到某些编译器检查。问题是数组是协变类型的，因此List<string>[]也是一个Object[]，并且你可以利用这一点，将一个ArrayList<integer>赋值到你的数组中，而不会有任何编译期或运行时错误。</integer></string></string></p>
</li>
</ul>
<h3 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h3><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><ul>
<li><p>Java标准类库提供有static方法<strong>System.arraycopy()</strong>，用它复制数组比用for循环要快很多。<strong>System.arraycopy()</strong>针对所有类型做了重载</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyingArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(i,<span class="number">47</span>);</span><br><span class="line">        Arrays.fill(j,<span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+Arrays.toString(i));</span><br><span class="line">        System.out.println(<span class="string">"j="</span>+Arrays.toString(j));</span><br><span class="line">        System.arraycopy(i,<span class="number">0</span>,j,<span class="number">0</span>,i.length);</span><br><span class="line">        System.out.println(<span class="string">"j="</span>+Arrays.toString(j));</span><br><span class="line">        <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(k,<span class="number">103</span>);</span><br><span class="line">        System.arraycopy(i,<span class="number">0</span>,k,<span class="number">0</span>,k.length);</span><br><span class="line">        System.out.println(<span class="string">"k="</span>+Arrays.toString(k));</span><br><span class="line">        Arrays.fill(k,<span class="number">103</span>);</span><br><span class="line">        System.arraycopy(k,<span class="number">0</span>,i,<span class="number">0</span>,k.length);</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+Arrays.toString(i));</span><br><span class="line">        Integer[] u = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        Integer[] v = <span class="keyword">new</span> Integer[<span class="number">5</span>];</span><br><span class="line">        Arrays.fill(u,<span class="keyword">new</span> Integer(<span class="number">47</span>));</span><br><span class="line">        Arrays.fill(v,<span class="keyword">new</span> Integer(<span class="number">99</span>));</span><br><span class="line">        System.out.println(<span class="string">"u="</span>+Arrays.toString(u));</span><br><span class="line">        System.out.println(<span class="string">"v="</span>+Arrays.toString(v));</span><br><span class="line">        System.arraycopy(v,<span class="number">0</span>,u,u.length/<span class="number">2</span>,v.length);</span><br><span class="line">        System.out.println(<span class="string">"u="</span>+Arrays.toString(u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=[47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">j=[99, 99, 99, 99, 99, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">j=[47, 47, 47, 47, 47, 47, 47, 99, 99, 99]</span></span><br><span class="line"><span class="comment">k=[47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">i=[103, 103, 103, 103, 103, 47, 47]</span></span><br><span class="line"><span class="comment">u=[47, 47, 47, 47, 47, 47, 47, 47, 47, 47]</span></span><br><span class="line"><span class="comment">v=[99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">u=[47, 47, 47, 47, 47, 99, 99, 99, 99, 99]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个例子说明基本类型数组与对象数组都可以复制。然而，如果复制对象数组，那么只是复制了对象的引用，而不是对象本身的拷贝。这被称为浅复制。</p>
</li>
<li><p><strong>System.arraycopy()</strong>不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。</p>
</li>
</ul>
<h4 id="数组的比较"><a href="#数组的比较" class="headerlink" title="数组的比较"></a>数组的比较</h4><ul>
<li><p><strong>Arrays</strong>类提供了重载后的<strong>equals()</strong>方法，用来比较整个数组。同样，此方法针对所有基本类型与<strong>Object</strong>都做了重载。数组相等的条件是元素个数必须相等，并且对应位置的元素也相等，这可以通过对每一个元素使用<strong>equals()</strong>作比较来判断。(对于基本类型，需要使用基本类型的包装器类的<strong>equals()</strong>方法)</p>
</li>
<li><p>如此处对于int类型使用Integer.equals()做比较</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparingArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] a2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Arrays.fill(a1,<span class="number">47</span>);</span><br><span class="line">        Arrays.fill(a2,<span class="number">47</span>);</span><br><span class="line">        System.out.println(Arrays.equals(a1,a2));</span><br><span class="line">        a2[<span class="number">3</span>] = <span class="number">11</span>;</span><br><span class="line">        System.out.println(Arrays.equals(a1,a2));</span><br><span class="line">        String[] s1 = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">        Arrays.fill(s1,<span class="string">"Hi"</span>);</span><br><span class="line">        String[] s2 = &#123;</span><br><span class="line">            <span class="keyword">new</span> String(<span class="string">"Hi"</span>),<span class="keyword">new</span> String(<span class="string">"Hi"</span>),</span><br><span class="line">            <span class="keyword">new</span> String(<span class="string">"Hi"</span>),<span class="keyword">new</span> String(<span class="string">"Hi"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.equals(s1,s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/数组/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>数组</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十五章/">
      java编程思想第十五章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h2><ul>
<li><p>一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。</p>
</li>
<li><p>有时候，拘泥于单继承体系，也会使程序受限太多。如果方法的参数是一个接口，而不是一个类，这种限制就放松了许多。因为任何实现了该接口的类都能满足该方法，这也包括暂时还不存在的类。接口允许我们快捷的实现类继承，也使我们有机会创建一个新类来做到这一点。</p>
</li>
<li><p>在有的时候，即便使用了接口，对程序的约束性还是太强大了。因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望达到的目地是编写更通用的代码，要使代码能够应用于”某种不具体的类型”而不是一个具体的接口或类。</p>
</li>
<li><p>泛型的概念：泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。</p>
</li>
</ul>
<h3 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h3><ul>
<li><p>有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。容器，就是存放要使用的对象的地方。数组也是如此，不过与简单的数组相比，容器类更加灵活，具备更多不同的功能。</p>
</li>
<li><p>有些情况下，我们希望容器能够同时存储多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。</p>
</li>
<li><p>与其使用Object，我们更喜欢使用暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换类型参数。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        thia.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder&lt;Automobile&gt; h = <span class="keyword">new</span> Holder&lt;Automobile&gt;(<span class="keyword">new</span> Automobile());</span><br><span class="line">        Automobile a = h.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型的核心概念：“告诉编译器想使用什么类型，然后编译器帮你处理一切细节”。</p>
</li>
</ul>
<h4 id="一个元组类库"><a href="#一个元组类库" class="headerlink" title="一个元组类库"></a>一个元组类库</h4><ul>
<li><p>在开发中可能经常会遇到，仅一次方法调用就能返回多个对象。可是return语句只允许返回单个对象。因此，解决方法就是创建一个对象，用它来持有想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。可是有了泛型，就能够一次性的解决问题，同时，我们在编译期就能确保类型安全。</p>
</li>
<li><p>这被称为==元组==(tuple):它是将一组对象直接打包存储于其中一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。(这个概念也称为数据传送对象，或信使)。</p>
</li>
<li><p>通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。不过，我们希望能够为每一个对象指明其类型，并且从容器中读取出来时，能够得到正确的类型，要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个二维元组，它能够持有两个对象。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a, B b)</span> </span>&#123;</span><br><span class="line">        first = a;</span><br><span class="line">       second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TwoTuple&#123;"</span> +</span><br><span class="line">                <span class="string">"first="</span> + first +</span><br><span class="line">                <span class="string">", second="</span> + second +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以使用继承机制实现长度更长的元组。从下面可以看到，增加类型参数是件很简单的事情。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">        third = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span>+first+<span class="string">","</span>+second+<span class="string">","</span>+third+<span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了使用元组，你只需要定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。</p>
</li>
</ul>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul>
<li><p>泛型也可以应用于接口，例如生成器(generator)，这是一种专门负责创建对象的类。</p>
</li>
<li><p>一般而言，一个生成器只定义一个方法，该方法用以产生新的对象。此处，就是<strong>next()</strong>方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//方法next()的返回类型是参数化T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java泛型的局限性：基本类型无法作为类型参数。</p>
</li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li><p>可以在类中包含参数化方法，而这个方法所在的类可以是泛型类，也可以不是泛型类。</p>
</li>
<li><p>泛型方法使得该方法能够独立于类而产生变化。</p>
</li>
<li><p>无论何时只要你能做到，你就应该尽量使用泛型方法。就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。</p>
</li>
<li><p>对于一个<strong>static</strong>的方法而言，无法访问类的类型参数，所以，如果<strong>static</strong>方法需要使用泛型能力，<strong>就必须使其成为泛型方法。</strong></p>
</li>
<li><p>泛型方法格式 :</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerirMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(x.getClass().getName()<span class="string">");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法时，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为<strong>类型参数推断(type argument inference)</strong>。</p>
<h4 id="可变参数与泛型方法"><a href="#可变参数与泛型方法" class="headerlink" title="可变参数与泛型方法"></a>可变参数与泛型方法</h4><ul>
<li><p>泛型方法与可变参数能够很好的共存。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; ls = makeList(<span class="string">"A"</span>);</span><br><span class="line">            System.out.println(ls);</span><br><span class="line">            ls = makeList(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>);</span><br><span class="line">            System.out.pringln(ls);</span><br><span class="line">            ls = makeList(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>.spilt(<span class="string">""</span>));</span><br><span class="line">            System.out.println(ls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h3><ul>
<li><p>当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的，如，尽管可以声明<strong>ArrayList.class</strong>，但是不能声明<strong>ArrayList<integer>.class</integer></strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ArrayList<string></string></strong>与<strong>ArrayList<integer></integer></strong>很容易被认为是不同的类型。不同的类型在行为方面肯定是不同的，如：将一个<strong>Integer</strong>放入<strong>ArrayList<string></string></strong>,所得到的行为(将失败)与把一个<strong>Integer</strong>放入<strong>ArrayList<integer></integer></strong>(将成功)所得到的行为完全不同。但是上面的程序会认为他们是相同的类型。</p>
</li>
<li><p>下面是对这个谜题的一个补充。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frob</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fnorkle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quark</span>&lt;<span class="title">Q</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>&lt;<span class="title">POSITION</span>,<span class="title">MOMENTUM</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LostInformation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Frob&gt; list = <span class="keyword">new</span> ArrayList&lt;Frob&gt;();</span><br><span class="line">        Map&lt;Frob,Fnorkle&gt; map = <span class="keyword">new</span> HashMap&lt;Frob,Fnorkle&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = <span class="keyword">new</span> Quark&lt;Fnorkle&gt;();</span><br><span class="line">        Particle&lt;Long,Double&gt; p = <span class="keyword">new</span> Particle&lt;Long,Double&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Class.getTypeParameters()</strong>将”返回一个<strong>TypeVariable</strong>对象数组，表示有泛型声明所声明的类型参数······”.</p>
</li>
<li><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。</p>
</li>
<li><p><strong>Java</strong>泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此<strong>List<string></string></strong>和<strong>List<integer></integer></strong>在运行时事实上是相同的类型。这两种形式都被擦除成他们的“<strong>原生</strong>”类型，即<strong>List</strong>。</p>
</li>
<li><p>擦除减少了泛型的泛化性。泛型在Java中仍旧是有用的，只是不如他们本来设想的那么有用，而原因就是擦除。</p>
</li>
<li><p>在基于擦除的实现中，泛型类型被当作第二类型处理，即不能在某些重要的上下文环境中使用的类型。</p>
</li>
<li><p>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。</p>
</li>
<li><p>擦出的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“<strong>迁移兼容性</strong>”。</p>
</li>
</ul>
<h4 id="擦除的问题"><a href="#擦除的问题" class="headerlink" title="擦除的问题"></a>擦除的问题</h4><ul>
<li>泛型不能用于显式地引用运行时类型的操作之中，例如<strong>转型</strong>，<strong>instanceof</strong>操作和<strong>new表达式</strong>。</li>
<li>擦除和迁移兼容性意味着，使用泛型并不是强制的。</li>
<li>JDK5之后提供了一个注解<strong>@SuppressWarnings(“”)</strong>用于压制警告。</li>
</ul>
<h3 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h3><ul>
<li><p>擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125;				<span class="comment">//Error</span></span><br><span class="line">        T <span class="keyword">var</span> = <span class="keyword">new</span> T();					<span class="comment">//Error</span></span><br><span class="line">        T[] array = <span class="keyword">new</span> T[SIZE];			<span class="comment">//Error</span></span><br><span class="line">        T[] array = (T)<span class="keyword">new</span> Object[SIZE];	<span class="comment">//Unchecked warning</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>偶尔可以绕过这些问题来编程，但是有时必须通过引入类型标签来对擦除进行补偿。这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用他。</p>
</li>
</ul>
<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><ul>
<li><p>不能创建泛型数组。一般的解决方案是在任何想要创建泛型数组的地方都使用<strong>ArrayList</strong>(底层使用的数组结构)。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfGenerics</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; array = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        array.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里你将获得数组的行为，以及由泛型提供的编译期的类型安全。</p>
</li>
<li><p>成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。</p>
</li>
</ul>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>边界使得你可以在用于泛型的参数类型上设置限制条件。尽管这使得你可以强制规定泛型可以应用的类型，但是其潜在的一个更重要的效果是你可以按照自己的边界类型来调用方法。</li>
<li>因为擦除移除了类型信息，所以，可以用无界泛型参数调用的方法只是那些可以用Object调用的方法。但是，如果能够将这个参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行这种限制，<strong>Java</strong>泛型重用了<strong>extends</strong>关键字。</li>
</ul>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonCovariantGenerics</span> </span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt; ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Apple</strong>的<strong>List</strong>不是<strong>Fruit</strong>的<strong>List</strong>。<strong>Apple</strong>的<strong>List</strong>将持有<strong>Apple</strong>和<strong>Apple</strong>的子类型，而<strong>Fruit</strong>的<strong>List</strong>将持有任何类型的<strong>Fruit</strong>，诚然，这包括<strong>Apple</strong>在内，但是它不是一个<strong>Apple</strong>的<strong>List</strong>，它仍旧是<strong>Fruit</strong>的<strong>List</strong>。<strong>Apple</strong>的<strong>List</strong>在类型上不等价于<strong>Fruit</strong>的<strong>List</strong>，即使<strong>Apple</strong>是一种<strong>Fruit</strong>类型。</p>
</li>
<li><p>有时你想在两个类型之间建立某种类型的向上转型关系，这是通配符所允许的。如：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndCovariance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = <span class="keyword">new</span> ArrayList&lt;Apple&gt; ();</span><br><span class="line">        flist.add(<span class="keyword">null</span>);</span><br><span class="line">        Fruit f = flist.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flist</strong>类型现在是<strong>List&lt;? extends Fruit&gt;</strong>,你可以将其读作“具有任何从Fruit继承的类型的列表”。</p>
</li>
<li><p><strong>List&lt;? extends Fruit&gt;</strong>可以合法的指向一个<strong>List<orange></orange></strong>。一旦执行这种类型的向上转型，你就将丢失掉向其中传递任何对象的能力，甚至是传递<strong>Object</strong>也不行。</p>
</li>
</ul>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><ul>
<li><p>另外一种方式，及使用超类型通配符。可以声明通配符是由某个特定类的任何基类来界定的，方法是指定&lt;? super MyClass&gt;,甚至是使用类型参数：&lt;? super T&gt;(尽管你不能对泛型参数给出一个超类型边界；及不能声明<t super myclass>)。这使得你可以安全地传递一个类型对象到泛型类型中。但是，有了泛型通配符，就可以向Collection写入了：</t></p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTypeWildcards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(List&lt;? <span class="keyword">super</span> Apple&gt; apples)</span> </span>&#123;</span><br><span class="line">        apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        apples.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">        <span class="comment">//apples.add(new Fruit()); //Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><ul>
<li><p>无界通配符&lt;?&gt;看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型，事实上，编译器初看起来是支持这种判断的。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedWildcards1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List list1;</span><br><span class="line">    <span class="keyword">static</span> List&lt;?&gt; list2;</span><br><span class="line">    <span class="keyword">static</span> List&lt;? extends Object&gt; list3;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign1</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;	Warning:unchecked conversion</span><br><span class="line">        <span class="comment">//Found: List,Required: List&lt;? extends Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign2</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assign3</span><span class="params">(List&lt;? extends Object&gt; list)</span> </span>&#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        <span class="comment">//assing3(new ArrayList());	//Warning</span></span><br><span class="line">        <span class="comment">//Unchecked conversion.Found: ArrayList</span></span><br><span class="line">        <span class="comment">//Required:List&lt;? extends Object&gt;</span></span><br><span class="line">        assign1(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        <span class="comment">//Both forms are acceptable as List&lt;?&gt;;</span></span><br><span class="line">        List&lt;?&gt; wildList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        wildList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器并非总是关注像List和List<?>之间的这种差异，因此他们看起来就像是相同的事物。因为，事实上，由于泛型参数将擦除到他的第一个边界，因此List<?>看起来等价于List<object>,而List实际上也是List<object>除非这些语句都不为真。</object></object></p>
</li>
<li><p>List实际上表示“持有任何Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么”。</p>
</li>
<li><p>使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。</p>
</li>
</ul>
<h4 id="捕获转换"><a href="#捕获转换" class="headerlink" title="捕获转换"></a>捕获转换</h4><ul>
<li><p>有一种情况需要使用<?>而不是原生类型。如果向一个使用<?>的方法传递原生类型，那么对于编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法，下面演示这种技术，他被称为==<strong>捕获转换</strong>==，因为未指定的通配符类型被捕获，并被转换为确切类型，这里，有关警告的注释只有在<strong>@SuppressWarnings</strong>注解被移除之后才能起作用。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder);	<span class="comment">//Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//f1(raw);	//Produces warnings</span></span><br><span class="line">        f2(raw);	<span class="comment">//No warnings</span></span><br><span class="line">        Hplder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object());	<span class="comment">//warning</span></span><br><span class="line">        f2(rawBasic);	<span class="comment">//No warnings</span></span><br><span class="line">        <span class="comment">//Upcast to Holder&lt;?&gt;,still figures it out;</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>f1()</strong>中的类型参数都是确切的，没有通配符或边界。在<strong>f2()</strong>中，<strong>Holder</strong>参数是一个无界通配符，因此它看起来是未知的。但是，在<strong>f2()</strong>中，<strong>f1()</strong>被调用，而<strong>f1()</strong>需要一个已知参数。这里所发生的是：参数类型在调用<strong>f2()</strong>的过程中被捕获，因此它可以在对<strong>f1()</strong>的调用中被使用。</p>
</li>
</ul>
<h3 id="泛型常见问题"><a href="#泛型常见问题" class="headerlink" title="泛型常见问题"></a>泛型常见问题</h3><h4 id="任何基本类型都不能作为类型参数"><a href="#任何基本类型都不能作为类型参数" class="headerlink" title="任何基本类型都不能作为类型参数"></a>任何基本类型都不能作为类型参数</h4><ul>
<li><p>解决方案是使用基本类型的包装器以及Java SE5的自动包装机制。如果创建一个ArrayList<integer>，并将基本类型int应用于这个容器，那么自动包装机制将自动的实现int到Integer的双向转换。</integer></p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">            li.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i : li) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="实现参数化接口"><a href="#实现参数化接口" class="headerlink" title="实现参数化接口"></a>实现参数化接口</h4><ul>
<li><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口，下面是产生这种冲突的原因。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hourly不能编译，因为擦除会将Payable<employee>和Payable<hourly>简化为相同的类Payable，这样，上面的代码就以为着在重复两次地实现相同地接口。有趣的是，如果从Payable地两种用法中都移除掉泛型参数，这段代码就可以编译。</hourly></employee></p>
</li>
</ul>
<h4 id="转型和警告"><a href="#转型和警告" class="headerlink" title="转型和警告"></a>转型和警告</h4><ul>
<li><p>使用带有泛型类型参数的转型或<strong>instanceof</strong>不会有任何效果。下面的容器在内部将各个值存储为<strong>Object</strong>，并在获取这些值时，在将他们转型回<strong>T</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedSizeStack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        storage = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        storage[index++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)storage[--index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericCast</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            FixedSizeStack&lt;String&gt; strings = <span class="keyword">new</span> FixedSizeStack&lt;String&gt;(SIZE);</span><br><span class="line">            <span class="keyword">for</span>(String s : <span class="string">"A BC D E F G H I J"</span>.split(<span class="string">" "</span>))</span><br><span class="line">            strings.push(s);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                String s = strings.pop();</span><br><span class="line">                System.out.println(s + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有<strong>@SuppressWarnings</strong>注解，编译器将对<strong>pop()</strong>产生“<strong>unchecked cast</strong>”警告。由于擦除的原因，编译器无法知道这个转型是否是安全的，并且<strong>pop()</strong>方法实际上并没有执行任何转型。这是因为，T被擦除到它的第一个边界，默认情况下是<strong>Object</strong>,因此<strong>pop()</strong>实际上只是将<strong>Object</strong>转型为<strong>Object</strong>。</p>
</li>
</ul>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul>
<li><p>下面的程序是不能编译的，即使编译它是一种合理的尝试。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于擦除的原因，重载方法将产生相同的类型签名。</p>
</li>
<li><p>与此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自限定的类型"><a href="#自限定的类型" class="headerlink" title="自限定的类型"></a>自限定的类型</h3><ul>
<li><p>在Java泛型中，有一个好像是经常性出现的惯用法，它相当令人费解：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这就像是两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。<strong>SelfBounded</strong>类接受泛型参数<strong>T</strong>，而<strong>T</strong>由一个边界类限定，这个边界类就是拥有<strong>T</strong>作为其参数的<strong>SelfBounded</strong>。</p>
</li>
<li><p>当你首次看见他时，很难去解析它，它强调的是当<strong>extends</strong>关键字用于边界与用来创建子类明显是不同的。</p>
</li>
</ul>
<h4 id="自限定"><a href="#自限定" class="headerlink" title="自限定"></a>自限定</h4><ul>
<li><p><strong>BasicHolder</strong>可以使用任何类型作为其泛型类型，就像下面看到的这样。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicHolder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    element = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> element;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(element.getClass().getSimpleName());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicOther</span> <span class="keyword">extends</span> <span class="title">BasicHolder</span>&lt;<span class="title">Other</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unconstrained</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BasicOther b = <span class="keyword">new</span> BasicOther();</span><br><span class="line">        b2 = BasicOther();</span><br><span class="line">        b.set(<span class="keyword">new</span> Other());</span><br><span class="line">        Other other = b.get();</span><br><span class="line">        b.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">Other</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。"><a href="#自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。" class="headerlink" title="自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。"></a>自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。</h5></li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T element;</span><br><span class="line">    <span class="function">SelfBounded&lt;T&gt; <span class="title">set</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        element = arg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">B</span>&gt; </span>&#123;&#125;	<span class="comment">//Also OK</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">setAndGet</span><span class="params">(C arg)</span> </span>&#123;</span><br><span class="line">        set(arg);</span><br><span class="line">        <span class="keyword">return</span> get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBounding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.set(<span class="keyword">new</span> A());</span><br><span class="line">        a = a.set(<span class="keyword">new</span> A()).get();</span><br><span class="line">        a = a.get();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c = c.setAndGet(<span class="keyword">new</span> C());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自限定所做的，就是要求在继承关系中，像下面这样使用这个类：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这会强制要求将正在定义的类当作参数传递给基类。</p>
</li>
<li><p>自限定参数的意义</p>
<ul>
<li>可以保证类型参数必须与正在被定义的类相同。</li>
<li>还可以从使用了另一个<strong>SelfBounded</strong>参数的<strong>SelfBounded</strong>中导出。</li>
</ul>
</li>
<li><p>自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。</p>
</li>
<li><p>还可以将自限定用于泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg.set(arg).get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = f(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="参数协变"><a href="#参数协变" class="headerlink" title="参数协变"></a>参数协变</h4><ul>
<li><p>自限定类型的价值在于<strong>他们可以产生协变参数类型——方法参数类型会随着子类而变化</strong>。尽管自限定类型还可以产生于子类类型相同的返回类型，但是这并不十分重要，因为协变返回类型是在Java SE5中引入的：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DerivedGetter</span> <span class="keyword">extends</span> <span class="title">OrdinaryGetter</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturnTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(DerivedGetter d)</span> </span>&#123;</span><br><span class="line">        Derived d2 = d.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DerivedGetter</strong>中的<strong>get()</strong>方法覆盖了<strong>OrdinaryGetter</strong>中的<strong>get()</strong>,并返回了一个从<strong>OrdinaryGetter.get()</strong>的返回类型中导出的类型。尽管这是完全合乎逻辑的事情(<strong>导出类方法应该能够返回比它覆盖的基类方法更具体地类型</strong>)但是这在早先的Java版本中是不合法的。</p>
</li>
</ul>
<h3 id="动态类型安全"><a href="#动态类型安全" class="headerlink" title="动态类型安全"></a>动态类型安全</h3><ul>
<li><p>因为可以向<strong>Java SE5</strong>之前的代码传递泛型容器，所以旧式代码仍有可能会破坏你的容器，<strong>Java SE5</strong>的<strong>java.util.Collections</strong>中有一组便利工具，可以解决在这种情况下的类型检查问题，分别为：静态方法<strong>checkedCollection(),checkedList(),checkedMap(),checkedSet(),checkedSortedMap()</strong>及<strong>checkedSortedSet()</strong>。这些方法每一个都会将你希望动态检查的容器当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。</p>
</li>
<li><p>受检查的容器在你试图插入类型不正确的对象时抛出<strong>ClassCastException</strong>,这与泛型之前的(原生)容器形成了对比，对于后者来说，当你将对象从容器中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的容器，就可以发现谁在试图插入不良对象。</p>
</li>
<li><p>我们用受检查的容器来看看“将猫插入到狗列表中”这个问题。这里，<strong>oldStyleMethod()</strong>表示遗留代码，因为它接受的是原生的<strong>List</strong>，而<strong>@SuppressWarnings(“unchecked”)</strong>注解对于压制所产生的警告是必须的。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldStyleMethod</span><span class="params">(List probablyDogs)</span> </span>&#123;</span><br><span class="line">        probablyDogs.add(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Dog&gt; dogs1 = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">        oldStyleMethod(dogs1);</span><br><span class="line">        List&lt;Dog&gt; dogs2 = Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;(),Dog.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oldStyleMethod(dogs2);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Pet&gt; pets = Collections.checkedList (<span class="keyword">new</span> ArrayList&lt;Pet&gt;(),Pet.class);</span><br><span class="line">            pets.add(<span class="keyword">new</span> Dog());</span><br><span class="line">            pets.add(<span class="keyword">new</span> Cat());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行此程序时，你会发现插入一个Cat对于dogs1来说没有任何问题，而dogs2立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。</p>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p>由于擦除的原因，将泛型应用于异常时非常受限的。catch语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承自Throwable(这将进一步阻止你去定义不能捕获的泛型异常)。</p>
</li>
<li><p>但是，类型参数可能会在一个方法的throws子句中用到。这使得你可以编写随检查型异常的类型而发生变化的泛型代码。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;T&gt; resultCollector)</span> <span class="keyword">throws</span> E</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProcessRunner</span>&lt;<span class="title">T</span>,<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">Processor</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="function">List&lt;T&gt; <span class="title">processAll</span><span class="params">()</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">   	 	List&lt;T&gt; resultCollector = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    	<span class="keyword">for</span>(Processor&lt;T,E&gt; processor : <span class="keyword">this</span>)</span><br><span class="line">    		processor.process(resultCollector);</span><br><span class="line">    	<span class="keyword">return</span> resultCollector;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Failurel</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor1</span> <span class="keyword">implements</span> <span class="title">Processpr</span>&lt;<span class="title">String</span>,<span class="title">Failure1</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; resultCollector)</span> <span class="keyword">throws</span> Failure1 </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            resultCollctor.add(<span class="string">"Hep!"</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            resultCollector.add(<span class="string">"Ho!"</span>);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Failure1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Failure2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Processor2</span> <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">Integer</span>,<span class="title">Failure2</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; resultCollector)</span> <span class="keyword">throws</span> Failure2 </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count-- = <span class="number">0</span>)</span><br><span class="line">            	resultCollector.add(<span class="number">47</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resultCollector.add(<span class="number">11</span>);</span><br><span class="line">            &#125;	</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Failure2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowGenericException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            ProcessRunner&lt;String,Failure1&gt; runner = <span class="keyword">new</span> ProcessRunner&lt;String,Failure1&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            	runner.add(<span class="keyword">new</span> Processor1());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(runner.processAll());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Failure1 e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessRunner&lt;Integer,Failure2&gt; runner2 = <span class="keyword">new</span> ProcessRunner&lt;Integer,Failure2&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) </span><br><span class="line">            	runner2.add(<span class="keyword">new</span> Processor2());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(runner2.processAll());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Failure2 <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Processor</strong>执行<strong>process()</strong>，并且可能会抛出具有类型E的异常。<strong>process()</strong>的结果存储在<strong>List<t> resultCollector</t></strong>中(<strong>这被称为收集参数</strong>)。<strong>ProcessRunner</strong>有一个<strong>processAll()</strong>方法，它将执行所持有的每个<strong>Process</strong>对象，并返回<strong>resultCollector</strong>。</p>
</li>
<li><p>如果不能参数化所抛出的异常，那么由于检查型异常的缘故，将不能编写出这种泛化的代码。</p>
</li>
</ul>
<h3 id="混型"><a href="#混型" class="headerlink" title="混型"></a>混型</h3><ul>
<li>混型：其最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类。</li>
<li>混型的价值之一是它们可以将特性和行为一致的应用于多个类之上。</li>
<li>在Java中，擦除会忘记基类类型，因此泛型类不能直接继承自一个泛型参数。</li>
</ul>
<h4 id="与接口混合"><a href="#与接口混合" class="headerlink" title="与接口混合"></a>与接口混合</h4><ul>
<li><p>常见的推荐解决方案是使用接口来产生混型效果，如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStampedImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStampedImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumberedImp</span> <span class="keyword">implements</span> <span class="title">SerialNumbered</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">Basic</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mixin</span> <span class="keyword">extends</span> <span class="title">BasicImp</span> <span class="keyword">implements</span> <span class="title">TimeStamped</span>,<span class="title">SerialNumbered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TimeStamped timeStamped = <span class="keyword">new</span> TimeStampedImp();</span><br><span class="line">    <span class="keyword">private</span> SerialNumbered serialNumbered = <span class="keyword">new</span> SerialNumberedImp();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamped.getStamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumbered.getSerialNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mixins</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mixin mixin1 = <span class="keyword">new</span> Mixin(),mixin2 = <span class="keyword">new</span> Mixin();</span><br><span class="line">        mixin1.set(<span class="string">"text string 1"</span>);</span><br><span class="line">        mixin2.set(<span class="string">"text string 2"</span>);</span><br><span class="line">        System.out.println(mixin1.get()+<span class="string">" "</span>+mixin1.getStamp()+<span class="string">" "</span>+mixin1.getSerialNumber());</span><br><span class="line">        System.out.println(mixin2.get()+<span class="string">" "</span>+mixin2.getStamp()+<span class="string">" "</span>+mixin2.getSerialNumber());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">text string 1 1571578397640 1</span></span><br><span class="line"><span class="comment">text string 2 1571578397640 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mixin</strong>类基本上是在使用代理，因此每个混入类型都要求在<strong>Mixin</strong>中有一个相应的域，而你必须在<strong>Mixin</strong>中编写所有必须的方法，将方法调用转发给恰当的对象。</p>
</li>
</ul>
<h4 id="使用装饰器模式"><a href="#使用装饰器模式" class="headerlink" title="使用装饰器模式"></a>使用装饰器模式</h4><ul>
<li><p>装饰器模式使用分层对象来动态地向单个对象中添加责任。装饰器指定包装在最初的对象周围的所有对象都具有相同的基本接口。某些事物是可装饰的，可以通过将其他类包装在这个可装饰对象的四周，来将功能分层。</p>
</li>
<li><p>装饰器是通过使用组合和形式化结构(可装饰物/装饰器层次结构)来实现的，而混型是基于继承的，因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Basic basic;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basic = basic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">        basic.set(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> basic.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeStamped</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeStamp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeStamped</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">        timeStamp = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerialNumbered</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> serialNumber = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerialNumbered</span><span class="params">(Basic basic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decoration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeStamped t = <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic());</span><br><span class="line">        TimeStamped t2= <span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic()));</span><br><span class="line">        SerialNumbered s = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> Basic());</span><br><span class="line">        SerialNumbered s2 = <span class="keyword">new</span> SerialNumbered(<span class="keyword">new</span> TimeStamped(<span class="keyword">new</span> Basic()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由使用装饰器所产生的对象的类型是最后被装饰的类型。也就是说，尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效的工作于装饰中的一层(最后一层)，而混型方法显然会更自然一些。因此，装饰器只是对由混型提出问题的一种局限的解决方案。</p>
</li>
</ul>
<h3 id="对缺乏潜在类型机制的补偿"><a href="#对缺乏潜在类型机制的补偿" class="headerlink" title="对缺乏潜在类型机制的补偿"></a>对缺乏潜在类型机制的补偿</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li><p>可以使用的一种方式是反射。下面的<strong>perform()</strong>方法就是用了潜在类型机制。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walkAgainstTheWind</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Pretending to sit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushInvisibleWalls</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mime"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Woof"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sitting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reproduce</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommunicateReflectively</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">(Object speaker)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; spkr = speaker.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method speak = spkr.getMethod(<span class="string">"speak"</span>);</span><br><span class="line">                speak.invoke(speaker);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker+<span class="string">"cannot speak"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method sit = spkr.getMethod(<span class="string">"sit"</span>);</span><br><span class="line">                sit.invoke(speaker);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                System.out.println(speaker+<span class="string">"cannot sit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(speaker.toString(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatentReflection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> SmartDog());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Robot());</span><br><span class="line">        CommunicateReflectively.perform(<span class="keyword">new</span> Mime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面这些类完全是彼此分离的，没有任何公共基类(除了<strong>Object</strong>)或接口。通过反射，<strong>CommunicateRefleCtively.perform()</strong>能够动态地确定所需要的方法是否可用并调用他们，它甚至能够处理<strong>Mime</strong>只具有一个必须的方法这一事实，并能够部分实现其目标。</p>
</li>
</ul>
<h3 id="总结：转型真的如此之糟吗"><a href="#总结：转型真的如此之糟吗" class="headerlink" title="总结：转型真的如此之糟吗"></a>总结：转型真的如此之糟吗</h3><ul>
<li>在<strong>Java SE5</strong>之前，当你将一个对象放置到容器中时，这个对象就会被向上转型为<strong>Object</strong>，因此你会丢失类型信息。当你想要将这个对象从容器中取回，用它去执行某些操作时，必须将其向下转型回正确的类型。如果没有<strong>Java SE5</strong>的泛型版本的容器，你放到容器里和从容器中取回，都是<strong>Object</strong>。</li>
<li>泛型出现之前的<strong>Java</strong>并不会让你误用放入到容器中的对象。如果将一个<strong>Dog</strong>扔到<strong>Cat</strong>的容器中，并且试图将这个容器中的所有东西都当作<strong>Cat</strong>处理，那么当你从这个<strong>Cat</strong>容器中取回那个<strong>Dog</strong>引用，并且试图将其转型为<strong>Cat</strong>时，就会得到一个<strong>RuntimeException</strong>。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/泛型/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>泛型</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十四章/">
      java编程思想第十四章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h2><ul>
<li>运行时类型信息使得你可以在程序运行时发现和使用类型信息。</li>
<li>Java是如何让我们在运行时识别对象和类的信息的，主要有两种方式。<ul>
<li>一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型。</li>
<li>一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</li>
</ul>
</li>
</ul>
<h3 id="为什么需要RTTI"><a href="#为什么需要RTTI" class="headerlink" title="为什么需要RTTI"></a>为什么需要RTTI</h3><ul>
<li>下面看一个我们已经很熟悉的一个例子，它使用了多态的类层次结构。最通用的类型是(泛型)是基类<strong>Shape</strong>，而派生出的具体类有<strong>Circle</strong>，<strong>Square</strong>和<strong>Triangle</strong>。</li>
</ul>
<p><img src="/2019/11/17/java编程思想第十四章/1568909940991.png" alt="1568909940991"></p>
<ul>
<li>这是一个典型的类层次结构图，基类位于顶部，派生类向下拓展。面向对象编程中基本的目的是：<strong>让代码只操纵对基类的引用</strong>。这样，如果要添加一个新类来扩展程序，就不会影响到原来的代码。在这个例子的<strong>Shape</strong>接口中动态的绑定了<strong>draw()</strong>方法，目的就是让客户端程序员使用泛化的<strong>Shape</strong>引用来调用<strong>draw()</strong>。<strong>draw()</strong>在所有派生类里都会被覆盖，并且由于它是被<strong>动态绑定</strong>的，所以即使是通过泛化的<strong>Shape</strong>引用来调用，也能产生正确行为。这就是==多态==。</li>
<li>因此，通常会创建一个具体的对象(Circle,Square,或者Triangle),把它向上转型成Shape(忽略对象的具体类型)，并在后面的程序中使用匿名的Shape引用。你可以像下面这样对Shape层次结构编码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">".draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Circle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Square"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Triangle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Shape&gt; shapeList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Circle(),<span class="keyword">new</span> Square(),<span class="keyword">new</span> Triangle());</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapeList) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Circle.draw()</span></span><br><span class="line"><span class="comment">Square.draw()</span></span><br><span class="line"><span class="comment">Triangle.draw()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>基类包含<strong>draw()</strong>方法，它通过传递<strong>this</strong>参数给<strong>System.out.println()</strong>,间接的使用<strong>toString()</strong>打印类标识符(注意，<strong>toString()被声明为abstract，以此强制继承者覆写该方法，并可以防止对无格式的Shape的实例化</strong>)。如果某个对象出现在字符串表达式中(涉及“+”和字符串对象的表达式)，<strong>toString()</strong>方法就会被自动调用，以生成表示该对象的<strong>String</strong>。每个派生类都要覆盖(从<strong>Object</strong>继承来的)<strong>toString()</strong>方法，这样<strong>draw()</strong>在不同情况下就打印出不同的消息(多态)。</p>
</li>
<li><p>在这个例子中，当把<strong>Shape</strong>对象放入<strong>List<shape></shape></strong>的数组时会向上转型。但在向上转型为<strong>Shape</strong>的时候也丢失了<strong>Shape</strong>对象的具体类型。对于数组而言，它们只是<strong>Shape</strong>类的对象。</p>
</li>
<li><p>当从数组中取出元素时，这种容器—–实际上它将所有的事物都当作<strong>Object</strong>持有—–会自动将结果转型回<strong>Shape</strong>。这是<strong>RTTI</strong>最基本的使用形式，因为在Java中，<strong>所有的类型转换都是在运行时进行正确性检查的</strong>，这也是<strong>RTTI</strong>名字的含义：在运行时，识别一个对象的类型。</p>
</li>
<li><p>在这个例子中，<strong>RTTI</strong>类型转换并不彻底：<strong>Object</strong>被转型为<strong>Shape</strong>，而不是转型为<strong>Circle</strong>,<strong>Square</strong>或者<strong>Triangle</strong>。这是因为目前我们只知道这个<strong>List<shape></shape></strong>保存的都是<strong>Shape</strong>。在编译时，将由容器和Java的泛型系统来强制确保这一点；而在运行时，由类型转换操作来确保这一点。</p>
</li>
<li><p>接下来就是多态机制的事情了，<strong>Shape</strong>对象实际执行什么样的代码，是由引用所指向的具体对象<strong>Circle</strong>,<strong>Square</strong>或者<strong>Triangle</strong>而决定的。通常，也正是这样的要求；你希望大部分代码尽可能少地了解对象的具体类型，而是只与对象家族中的一个通用表示打交道(在这个例子中是Shape)。这样代码会更容易写，更容易读，且更便于维护；设计也更容易实现，理解和改变。所以“多态”是面向对象编程的基本目标。</p>
</li>
</ul>
<h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><ul>
<li>要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。事实上，Class对象就是用来创建类的所有的“常规”对象的，Java使用Class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。Class对象还拥有大量的使用RTTI的其他方式。</li>
<li>类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生一个Class对象(更恰当地说，是被保存在一个同名的.class文件中)。为了生成这个类的对象，运行这个程序的Java虚拟机(JVM)将使用被称为“类加载器”的子系统。</li>
<li>类加载器子系统实际上可以包含一条类加载器链，但是只有一个原生的类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，他们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊需求(如以某种特殊的方式加载类，以支持Web服务器应用，或者在网络中下载类)，那么你有一种方式可以挂接额外的类加载器。</li>
<li>所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此，使用new操作符创建类的新对象也会被当作对类的静态成员的引用。</li>
<li>因此，Java程序在它运行之前并非被完全加载，其各个部分是在必需时才加载的。这一点与许多传统语言都不同。</li>
<li>类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。</li>
<li>一旦某个类的Class对象被加载进内存，它就被用来创建这个类的所有对象。如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.ThinkingInJava;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Candy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Gum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SweetShop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"inside main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Candy();</span><br><span class="line">        System.out.println(<span class="string">"After creating Candy"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"Gum"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Couldn`t find Gum"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"After Class.forName(\"Gum\")"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cookie();</span><br><span class="line">        System.out.println(<span class="string">"After creating Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inside main</span></span><br><span class="line"><span class="comment">Loading Candy</span></span><br><span class="line"><span class="comment">After creating Candy</span></span><br><span class="line"><span class="comment">Couldn`t find Gum</span></span><br><span class="line"><span class="comment">After Class.forName("Gum")</span></span><br><span class="line"><span class="comment">Loading Cookie</span></span><br><span class="line"><span class="comment">After creating Cookie</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的每个类Candy,Gum和Cookie,都有一个static子句，该子句在类第一次被加载时执行。这时会有相应的信息打印出来，告诉我们这个类什么时候被加载了。在main()中，创建对象的代码被置于打印语句之间，以帮助我们判断加载的时间点。</li>
<li>从输出中可以看到，Class对象仅在需要的时候才被加载，static初始化是在类加载时进行的。</li>
<li>上面的<code>Class.forName(&quot;Gum&quot;);</code>这个方法是Class类的一个static成员。Class对象就和其他对象一样，我们可以获取并操作它的引用(这也是类加载器的工作)。forName()是取得Class对象的引用的一种方法。它是用一个包含目标类的文本名的String作输入参数，返回的是一个Class对象的引用，上面的代码忽略了返回值。对forName()的调用是为了它产生的“副作用”：如果类Gum还没有被加载就加载它。在加载的过程中。Gum的static子句被执行。</li>
<li>无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的<strong>Class</strong>对象的引用。<strong>Class.forName()</strong>就是实现此功能的便捷途径，因为你不需要为了获得<strong>Class</strong>引用而持有该类型的对象。但是，如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用<strong>getClass()</strong>方法来获取<strong>Class</strong>引用了，这个方法属于根类<strong>Object</strong>的一部分，它将返回表示该对象的实际类型的<strong>Class</strong>引用。</li>
</ul>
<h4 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h4><ul>
<li><p>Java还提供了另一种方法来生成对Class对象的引用，及使用==类字面常量==。即使用==类字面常量(类名.class)==。这样做不仅更简单，而且更安全。因为他在编译的时候就会受到检查(因此不需要置于try语句块中)。并且它根除了对==forName()==方法的调用，所以也更高效。</p>
</li>
<li><p>类字面常量不仅可以应用于普通的类，也可以用于接口，数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象，如下：</p>
<table>
<thead>
<tr>
<th align="center">boolean.class</th>
<th align="center">等价于</th>
<th align="center">Boolean.TYPE</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>char.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Character.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>byte.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Byte.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>short.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Short.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>int.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Integer.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>long.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Long.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>float.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Float.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>double.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Double.TYPE</strong></td>
</tr>
<tr>
<td align="center"><strong>void.class</strong></td>
<td align="center"><strong>等价于</strong></td>
<td align="center"><strong>Void.TYPE</strong></td>
</tr>
</tbody></table>
</li>
<li><p>当使用“<strong>.class</strong>”来创建对<strong>Class</strong>对象的引用的时候，不会自动地初始化该<strong>Class</strong>对象。为了使用类而做的准备工作实际包含三个步骤：</p>
<ul>
<li><strong>加载</strong>，这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个Class对象。</li>
<li><strong>链接</strong>，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。</li>
<li><strong>初始化</strong>，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。初始化被延迟到了对静态方法或者非常数静态域进行首次引用时才执行。</li>
</ul>
</li>
<li><p>初始化有效地实现了尽可能的“惰性”。仅使用<strong>.class</strong>语法来获得对类的引用不会引发初始化。但是，为了产生<strong>Class</strong>引用，<strong>Class.forName()</strong>立即就进行了初始化。</p>
</li>
<li><p>如果一个<strong>static</strong>域不是<strong>final</strong>的，那么在对他进行访问时，总是要求在它被读取之前，要先进行链接(为这个域分配存储空间)和初始化(初始化该存储空间)。</p>
</li>
</ul>
<h4 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h4><ul>
<li><strong>Class</strong>引用总是指向某个<strong>Class</strong>对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。他还包含该类的静态成员，因此，<strong>Class</strong>引用表示的就是它所指向的对象的确切类型，而该对象便是<strong>Class</strong>类的一个对象。</li>
<li>在Java se5中，将他的类型变得更具体了一些，而这是通过允许你对Class引用所指向的Class对象的类型进行限制而实现的，此处用到了泛型语法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        Class&lt;Integer&gt; genericIntClass = <span class="keyword">int</span>.class;</span><br><span class="line">        genericIntClass = Integer.class;</span><br><span class="line">        intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>普通的类不会产生警告信息，尽管泛型类引用只能赋值为指向声明的类型，但是普通的类引用可以被重新赋值为指向任何其他的Class对象。通过使用泛型语法。可以让编译器强制执行额外的类型检查。</li>
<li>为了在使用泛化的Class引用时放松限制，使用通配符，它是java泛型的一部分。通配符就是“?”，表示“任何事物”。我们可以在上例的普通Class引用中添加通配符，并产生相同的结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardClassReferenes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; intClass = <span class="keyword">int</span>.class;</span><br><span class="line">        intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Java se5中，Class<?>优于平凡的Class，即便他们是等价的，并且平凡的Class如你所见，不会产生编译器警告信息。Class<?>的好处是它表示你并非是碰巧或者由于疏忽，而使用了一个非具体的类引用，你就是选择了非具体的版本。</li>
<li>为了创建一个Class引用，他被限定为某种类型，或该类型的任何子类型，你需要将通配符与extends关键字相结合，创建一个范围。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedClassReferences</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;? extends Number&gt; bounded = <span class="keyword">int</span>.class;</span><br><span class="line">        bounded = <span class="keyword">double</span>.class;</span><br><span class="line">        bounded= Number.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查，因此如果你操作有误，稍后立即就会发现这一点。</li>
</ul>
<h4 id="新的转型语法"><a href="#新的转型语法" class="headerlink" title="新的转型语法"></a>新的转型语法</h4><ul>
<li><p>Java SE5中添加了用于Class引用的新的转型语法，即<strong>cast()</strong>方法:</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">House</span> <span class="keyword">extends</span> <span class="title">Building</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassCasts</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Building b = <span class="keyword">new</span> House();</span><br><span class="line">        Class&lt;House&gt; houseType = House.class;</span><br><span class="line">        House h = houseType.cast(b);</span><br><span class="line">        h = (house)b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cast()</strong>方法接受参数对象，并将其转型为<strong>Class</strong>引用的类型。</p>
</li>
</ul>
<h3 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h3><ul>
<li><p>目前为止，已知的RTTI形式包括。</p>
<ul>
<li><p>传统的类型转换，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个<strong>ClassCastException</strong>异常。</p>
</li>
<li><p>代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。</p>
</li>
<li><p>RTTI在Java中还有第三种形式，就是关键字<strong>instanceof</strong>。他返回一个布尔值，告诉我们对象是不是某个特定类型的实例。可以用提问的方式使用它，就像这样:</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog) </span><br><span class="line">	((Dog)x).bark();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在将<strong>x</strong>转型为一个<strong>Dog</strong>前，上面的<strong>if</strong>语句会检查对象<strong>x</strong>是否从属于<strong>Dog</strong>类。进行向下兼容前，如果没有其他信息可以告诉你这个对象是什么类型，那么使用<strong>instanceof</strong>是非常重要的，否则会得到一个<strong>ClassCastException</strong>异常。</p>
</li>
</ul>
</li>
</ul>
<h3 id="注册工厂"><a href="#注册工厂" class="headerlink" title="注册工厂"></a>注册工厂</h3><ul>
<li>你可能会考虑在每个子类中添加静态初始化器，以使得该初始化器可以将它的类添加到某个List中，遗憾的是，静态初始化器只有在类首先被加载的情况下才能被调用，因此你就要面临”先有鸡还是先有蛋”的问题，生成器在其列表中不包含这个类，因此它永远不能创建这个类的对象，而这个类也就不能被强制加载并置于这个列表中。</li>
<li>这主要是因为，你被强制要求自己去手工创建这个列表(除非你想编写一个工具，它可以全面搜索和分析源代码，然后创建和编译这个列表)。因此，最佳的做法是，将这个列表置于一个位于中心的，位置明显的地方，而我们感兴趣的继承结构的基类可能就是这个最佳位置。</li>
<li>这里我们需要做的其他修改就是使用工厂方法设计模式，将对象的创建工作交给类自己去完成，工厂方法可以被多态的调用，从而为你创建恰当类型的对象。下面这个例子中，工厂方法就是<strong>Factory</strong>接口中的<strong>create()</strong>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型参数T使得create()可以在每种Factory实现中返回不同的类型。这也充分利用了协变返回类型。</li>
</ul>
<h3 id="反射：运行时的类信息"><a href="#反射：运行时的类信息" class="headerlink" title="反射：运行时的类信息"></a>反射：运行时的类信息</h3><ul>
<li>如果不知道某个对象的确切类型，RTTI可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别他，并利用这些信息做一些有用的事。</li>
<li>人们想要在运行时获取类的信息的另外一个动机，便是希望提供在跨网络的远程平台上创建和运行对象的能力。这被称为<strong>远程方法调用(RMI)</strong>，它允许一个Java程序将对象分布到多台机器上。</li>
<li>Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field,Method以及Constructor类(每个类都实现了Method接口)。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。</li>
<li>当通过反射与一个未知类型的对象打交道时，JVM只是简单得检查这个对象，看他属于哪个特定的类。在用它做其他事情之前必须先加载那个类的Class对象。因此，那个类的<strong>.class</strong>文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所以<strong>RTTI</strong>和反射之间真正的区别只在于，对<strong>RTTI</strong>来说，编译器在编译时打开和检查<strong>.class</strong>文件。而对于反射来说<strong>.class</strong>文件在编译时是不可获取的，所以是在运行时打开和检查<strong>.class</strong>文件。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/类型信息/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>类型信息</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十三章/">
      java编程思想第十三章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章 字符串"></a>第十三章 字符串</h2><h3 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h3><ul>
<li>==String对象是不可变的==，String类中每个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象则丝毫未动。</li>
<li>每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</li>
</ul>
<h3 id="重载-“-”-与StringBuilder"><a href="#重载-“-”-与StringBuilder" class="headerlink" title="重载   “+”  与StringBuilder"></a>重载   “+”  与StringBuilder</h3><ul>
<li>String对象是不可变的,你可以给一个String对象加任意多的别名。因为String对象具有只读特性，所以指向它的任意引用都不可能改变它的值，因此，也就不会对其他的引用有什么影响。</li>
<li>不可变性会带来一定的效率问题。为String对象重载的“+”操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义(用于String的“+”与“+=”是java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符)。</li>
<li>操作符“+”可以用来连接String。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Concatenation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String mango = <span class="string">"mango"</span>;</span><br><span class="line">        String s = <span class="string">"abc"</span> + mango + <span class="string">"def"</span> + <span class="string">"47"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">abcmangodef47</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>StringBuilder是Java se1.5引入的，在这之前使用的是StringBuffer,后者是线程安全的，因此开销也会大些，所以在Java Se5/6中，字符串操作应该还会更快一些。</li>
</ul>
<h3 id="无意识的递归"><a href="#无意识的递归" class="headerlink" title="无意识的递归"></a>无意识的递归</h3><ul>
<li>Java中的每个类从根本上都是继承自<strong>Object</strong>，标准容器类也不例外，因此容器类都有<strong>toString()</strong>方法，并且覆写了该方法，使得它生成的String结果能够表达容器自身，以及容器所包含的对象。例如<strong>ArrayList.toString()</strong>，它会遍历<strong>ArrayList</strong>中包含的所有对象，调用每个对象上的<strong>toString()</strong>方法。</li>
<li>如果你希望toString()方法打印出对象的内存地址，也许你会考虑使用==this==关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfinitRecursion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"InfinitRecursion address: "</span>+ <span class="keyword">this</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;InfinitRecursion&gt; v = <span class="keyword">new</span> ArrayList&lt;InfinitRecursion&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>:i++) &#123;</span><br><span class="line">    		v.add(<span class="keyword">new</span> InfinitRecursion());</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当你创建了<strong>InfinitRecursion</strong>对象，并将其打印出来的时候，你会得到一串非常长的异常，</p>
<p><img src="/2019/11/17/java编程思想第十三章/1568475112738.png" alt="1568475112738"></p>
<p>如果你将该<strong>InfiniteRecursion</strong>对象存入一个<strong>ArrayList</strong>中，然后打印该<strong>ArrayList</strong>，你也会得到同样的异常，其实，当如下代码运行时：==”InfinitRecursion address: “+ this==,在这里发生了自动类型装换，由==InfinitRecursion==类型转换为String类型，因为编译器看到一个String对象后面跟着一个“+”，而后面的对象不是String，于是编译器试着将this转换成一个String。它怎么转换呢，正是调用this上的toString()方法，于是就发生了递归调用。</p>
</li>
<li><p>如果你真的想要打印出对象的内存地址，应该调用<strong>Object.toString()</strong>方法，这才是负责此任务的方法。所以你不该使用this，而是应该调用<strong>super.toString()</strong>方法。</p>
</li>
</ul>
<p><img src="/2019/11/17/java编程思想第十三章/1568475178185.png" alt="1568475178185"></p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/字符串/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>字符串</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十二章/">
      java编程思想第十二章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><h3 id="java的基本理念是”结构不佳的代码不能直接运行”"><a href="#java的基本理念是”结构不佳的代码不能直接运行”" class="headerlink" title="java的基本理念是”结构不佳的代码不能直接运行”"></a>java的基本理念是”结构不佳的代码不能直接运行”</h3><h3 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h3><ul>
<li>当发生异常后,会有几件事情随之发生,首先,将使用new在堆内存中创建异常对象,然后,当前的执行路径被终止,并且从当前环境中弹出对异常对象的引用,此时,异常处理机制接管程序,并开始寻找一个恰当的地方来继续执行程序,这个恰当的地方就是==异常处理程序==,他的任务是将程序从错误状态中恢复,以使程序能要么换一种方式运行,要么继续运行下去.</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ul>
<li><p>如:对于一个对象的引用t,传递给你的时候可能未被初始化,所以在使用这个对象引用调用其方法之前,会先对引用进行检查,可以创建一个代表错误信息的对象,并且将它从当前环境中”抛出”,这样就把错误信息传播到了”更大”的环境中,这被称为抛出异常如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常参数"><a href="#异常参数" class="headerlink" title="异常参数"></a>异常参数</h3><ul>
<li>与java中的其他对象一样,我们总是使用new在堆上创建异常对象,这也伴随着存储空间的分配和构造器的调用,所有的标准异常类都有两个构造器,一个是默认构造器;另一个是接受字符串作为参数,以便能把相关信息放入异常对象的构造器:   <code>throw new BullPointerException(&quot;t == null&quot;)</code></li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul>
<li><p><strong>try块</strong></p>
<ul>
<li>在方法内部抛出了异常(或者在方法内部调用的其他方法抛出异常),这个方法将在抛出异常的过程中结束,要是不希望方法就此结束,可以在方法内部设置一个特殊的块来捕获异常.因为在这个块里”尝试各种可能产生异常的方法调用,所以称之为try块,它是跟在try关键字之后的普通的程序块.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理程序</strong></p>
<ul>
<li>抛出的异常必须在某处得到处理,这个”地点”就是异常处理程序,而且针对每个要捕获的异常,得准备相应的处理程序.异常处理程序必须紧跟在<strong>try</strong>块之后,以关键字<strong>catch</strong>表示.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type1 id1) &#123;</span><br><span class="line">    <span class="comment">//Handle exceptions of Type1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type2 id2) &#123;</span><br><span class="line">    <span class="comment">//Handle exceptions of Type2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type3 idd3) &#123;</span><br><span class="line">    <span class="comment">//Handle exception of Type3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常处理程序必须紧跟在<strong>try</strong>块之后,当异常被抛出时,异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序,然后进入<strong>catch</strong>子句执行,此时认为异常得到了处理.一旦<strong>catch</strong>子句结束,则处理程序的查找过程结束,只有匹配的<strong>catch</strong>子句才能得到执行.</li>
</ul>
</li>
<li><p><strong>终止与恢复</strong></p>
<ul>
<li>异常处理理论上有两种基本模型.<ul>
<li>java支持<strong>终止模型</strong>,在这种模型中,将假设错误非常关键,以至于程序无法返回到异常发生的地方继续执行,一旦异常被抛出,就表明错误已无法挽回,也就不能回来继续执行.</li>
<li>另一种称为<strong>恢复模型</strong>,就是异常处理程序的工作是修正错误,然后重新尝试调用出问题的方法,并认为第二次能成功,,对于恢复模型,通常希望异常被处理之后能继续执行程序.如果用java实现类似的恢复的行为,那么在遇到错误时就不能抛出异常,而是调用方法来修正该错误.或者,把try块放在while循环中,这样就不断地进入try块,直到得到满意的结果.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h3><ul>
<li>java<strong>提供的异常体系不可能预见所有的希望加以报告的错误</strong>,所以可以<strong>自定义异常类</strong>来表示程序中可能遇见的特定问题.<strong>要自定义异常类,必须从已有的异常类中继承,最好的方法就是选择意思相近的异常类继承(不过这样的有异常并不容易找).建立新的异常类的最简单的方法就是让编译器为你产生默认构造器</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ym.ThinkingInJava;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritingExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throw SimpleException from f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SimpleException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InheritingExceptions sed = <span class="keyword">new</span> InheritingExceptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sed.f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SimpleException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">"Caught it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h3><ul>
<li><h5 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h5><ul>
<li>有时希望把刚刚捕获的异常重新抛出,尤其是在Exception捕获所有异常的时候,既然已经得到了对当前异常对象的引用,可以直接把它重新抛出:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"An exception was thrown"</span>);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重新抛出异常会把异常抛给上一级环境中的异常处理程序,同一个try块的后续catch子句将被忽略,此外,异常对象的所有信息都得以保持,所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息</li>
<li>永远不必为清理前一个异常对象而担心,或者说为异常对象的清理而担心,他们都是用new在堆上创建的对象,所以垃圾回收器会自动把他们清理掉.</li>
</ul>
</li>
<li><p><strong>异常链</strong></p>
<ul>
<li>常常会想要在捕获一个异常后抛出另一个异常,并且希望把原始异常的信息保存下来,这被称为==异常链==</li>
<li>在jdk1.4之前，程序员必须自己编写代码来保存原始异常的信息。现在所有的<strong>Throwable</strong>的子类在构造器中都可以接受一个cause对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</li>
<li>在==Throwable==的子类中，只有三种基本的异常类提供了带==cause==参数的构造器。分别为==Error==(用于java虚拟机报告系统错误)，==Exception以及RuntimeException。==如果要把其他类型的异常链接起来，应该使用==initCause()==方法而不是构造器。</li>
</ul>
</li>
</ul>
<h3 id="Java标准异常"><a href="#Java标准异常" class="headerlink" title="Java标准异常"></a>Java标准异常</h3><ul>
<li>==Throwable==这个Java类被用来表示任何作为异常被抛出的类。==Throwable==对象可以被分为两种类型<ul>
<li>==Error==：用来表示编译时和系统错误。</li>
<li>==Exception==:是可以被抛出的基本类型，在java类库，用户方法以及运行时故障中都可能抛出==Exception==型异常，所以我们需要关心的基类通常是==Exception==。</li>
<li>异常的基本的概念是用名称代表发生的问题，并且异常的名称应该是可以望文之意。异常并非全部定义在==java.lang==包里定义的，有些异常是用来支持其他像==util，net和io==这样的程序包，这些异常可以通过他们的完整名称或者从他们的父类中看出端倪，如：所有的输入/输出异常都是从==java.io.IOException==继承而来的。</li>
</ul>
</li>
</ul>
<h3 id="使用finally进行清理"><a href="#使用finally进行清理" class="headerlink" title="使用finally进行清理"></a>使用finally进行清理</h3><ul>
<li><p>对于一些代码，可能希望无论在try块中的异常是否抛出，他们都得到执行。这通常适用于内存回收之外的情况，为了达到这个效果需要在异常处理程序的后面加上finally子句。finally包围的代码表示总是执行(无论异常是否抛出)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//The guarded region: Dangerous activities</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (A a1) &#123;</span><br><span class="line">   <span class="comment">//Handler for situation A</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (A a2) &#123;</span><br><span class="line">	<span class="comment">//Handler for situation B</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (A a3) &#123;</span><br><span class="line">	<span class="comment">//Handler for situation C</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">//Activities that happen every time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finally用来做什么"><a href="#finally用来做什么" class="headerlink" title="finally用来做什么"></a>finally用来做什么</h4><ul>
<li>对于没有垃圾回收和析构函数自动调用机制的语言来说，finally非常重要，他能使程序员保证：==无论try块中发生了什么，内存总能得到释放==。但是java中有垃圾回收机制，所以内存释放不再是问题。而且，Java也没有析构函数可供调用。</li>
<li>Java在什么情况下需要用到finally？<ul>
<li>当要把除内存之外的资源恢复到他们的初始状态时，就要用到finally子句，这种需要清理的资源包括：已经打开的文件资源或网络连接，在屏幕上画得图形，甚至是外部世界的某个开关。</li>
<li>当涉及break和continue语句的时候，finally子句也会得到执行，请注意，如果把finally子句和带标签的break及continue配合使用，在java里就没有必要使用goto语句了。</li>
</ul>
</li>
</ul>
<h4 id="在return中使用finally"><a href="#在return中使用finally" class="headerlink" title="在return中使用finally"></a>在return中使用finally</h4><ul>
<li><p>因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		print(<span class="string">"Initialization that requires cleanup"</span>);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			print(<span class="string">"Point 1"</span>);</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">			print(<span class="string">"Point 2"</span>);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">			print(<span class="string">"Point 3"</span>);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">			print(<span class="string">"End"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		  print(<span class="string">"Performing cleanup"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) </span><br><span class="line">			f(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="缺憾：异常丢失"><a href="#缺憾：异常丢失" class="headerlink" title="缺憾：异常丢失"></a>缺憾：异常丢失</h4><ul>
<li>Java的异常实现也有瑕疵，异常作为程序出错的标志，决不应该被忽略，但他还是有可能被轻易的忽视。用某些特殊的方式使用finally子句，就会出现这种情况：</li>
</ul>
</li>
</ul>
<h3 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h3><ul>
<li>当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常，这个限制很又用，因为这意味着，当基类使用的代码应用到其派生类对象的时候，一样能够工作(当然这是面向对象的基本概念)，异常也不例外。</li>
</ul>
<h3 id="异常匹配"><a href="#异常匹配" class="headerlink" title="异常匹配"></a>异常匹配</h3><ul>
<li>抛出异常的时候，异常处理系统会按照代码的书写顺序找出”最近”的处理程序。找到匹配的处理程序之后，他就认为异常将得到处理，然后就不再继续查找。</li>
<li>查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。</li>
</ul>
<h3 id="其他可选方式"><a href="#其他可选方式" class="headerlink" title="其他可选方式"></a>其他可选方式</h3><ul>
<li><p>异常处理的一个重要原则就是“只有在你知道如何处理的情况下才捕获异常”。实际上，异常处理的一个重要目标就是把错误处理的代码同错误发生的地点向分离。这使你能在一段代码中专注于要完成的事情，至于如何处理错误，则放在另一段代码中完成。这样一来，主干代码就不会与错误处理代码混在一起，也更容易理解和维护。通过允许一个处理程序去处理多个出错点，异常处理还使得错误处理代码的数量趋向于减少。</p>
</li>
<li><p>“被检查的异常”使这个问题变得有些复杂，因为他们强制你在可能还没准备好处理错误的时候被迫加上==catch==子句，这就导致了==吞食则有害==的问题</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//...to do something useful</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ObligatoryException e) &#123;&#125;	<span class="comment">// Gulp</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常使用指南"><a href="#异常使用指南" class="headerlink" title="异常使用指南"></a>异常使用指南</h3><ol>
<li>在恰当的级别处理问题。(在知道该如何处理的情况下才捕获异常)</li>
<li>解决问题并且重新调用产生异常的方法。</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行。</li>
<li>用别的数据进行计算，以代替方法预计会返回的值。</li>
<li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</li>
<li>把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</li>
<li>终止程序。</li>
<li>进行简化。</li>
<li>让类库和程序更安全。</li>
</ol>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/异常/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>异常</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十八章/">
      java编程思想第十八章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h2><h3>对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</h3>

<ul>
<li><strong>Java 1.0</strong>版本以来，<strong>Java</strong>的<strong>I/O</strong>类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于<strong>Unicode</strong>的类。在<strong>JDK 1.4</strong>中，添加了<strong>nio</strong>类(对于“新<strong>I/O</strong>”来说，这是一个从现在起我们将要使用若干年的名称，即使它们在<strong>JDK 1.4</strong>中就已经被引入了，因此它们已经“旧”了)添加进来是为了改进性能及功能。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul>
<li><strong>File</strong>(文件)类这个名字具有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。==它既能代表一个特定文件的名称，有能代表一个目录下的一组文件的名称==。如果它指的是一个文件集，我们就可以对此集合调用<strong>list()</strong>方法，这个方法会返回一个字符数组。</li>
</ul>
<h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><ul>
<li><p>假设查看一个目录列表，可以用两种方法来使用<strong>File</strong>对象。如果调用不带参数的<strong>list()</strong>方法，便可以获得此<strong>File</strong>对象包含的全部列表。但是，如果我们想要获得一个受限列表，如：想得到所有拓展名为<strong>.java</strong>的文件，那么就需要使用“<strong>目录过滤器</strong>”，这个类会告诉我们怎么显示符合条件的<strong>File</strong>对象。</p>
</li>
<li><p>通过使用<strong>java.utils.sort()</strong>和<strong>String.CASE_INSENSITIVE.ORDERComparator</strong>，可以很容易的对结果进行排序(按字母顺序)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">            Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DirFilter</strong>这个类存在的唯一原因就是<strong>accept()</strong>方法。创建这个类的目的在于把<strong>accept()</strong>方法提供给<strong>list()</strong>使用，使<strong>list()</strong>可以回调<strong>accept()</strong>，进而以决定哪些文件包含在列表中。因此，这种结构也常常被称为==回调==。更具体的说，这是一个==策略模式==。==策略的目的就是提供了代码行为的灵活性==。</p>
</li>
<li><p><strong>accept()</strong>方法必须接受一个代表某个特定文件所在目录的<strong>File</strong>对象，以及包含那个文件的一个<strong>String</strong>。注意：==<strong>list()</strong>方法会为此目录对象下的每个文件名调用<strong>accept()</strong>,来判断该文件是否包含在内；判断结果由<strong>accept()</strong>返回的布尔值决定。==</p>
</li>
</ul>
<h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><ul>
<li><strong>File</strong>类不仅仅只代表存在的文件或目录。也可以用<strong>File</strong>对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，检查某个<strong>File</strong>对象代表的是一个文件还是一个目录，并可以删除文件。</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><strong>I/O</strong>库中常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。“流”屏蔽了实际的<strong>I/O</strong>设备中处理数据的细节。</li>
<li><strong>Java</strong>类库中的<strong>I/O</strong>类分成==输入和输出==两部分。通过==继承==，任何自<strong>InputStream</strong>或<strong>Reader</strong>派生而来的类都含有名为<strong>read()</strong>的基本方法，==用于读取单个字节或者字节数组==。同样，任何自<strong>OutputStream</strong>或<strong>Writer</strong>派生而来的类都含有名为<strong>write()</strong>的基本方法，==用于写单个字节或者字节数组==。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个流对象来提供所期望的功能(这是装饰器设计模式)。</li>
<li>实际上。<strong>Java</strong>中的“<strong>流</strong>”类库让人迷惑的主要原因就在于：==创建单一的结果流，却需要创建多个对象==。</li>
<li>在<strong>Java 1.0</strong>中，类库的设计者首先限定与<strong>输入</strong>有关的所有类都应该从<strong>InputStream</strong>继承,而<strong>输出</strong>有关的所有类都应该从<strong>OutputStream</strong>继承。</li>
</ul>
<h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul>
<li><strong>InputStream</strong>的作用是用来表示那些从不同数据源产生输入的类。包括：<ol>
<li>字节数组。</li>
<li><strong>String</strong>对象。</li>
<li>文件。</li>
<li>“管道”，工作方式与实际管道类似，即，从一端输入，从另一端输出。</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集和并到一个流内。</li>
<li>其他数据源，如<strong>Internet</strong>连接等。</li>
</ol>
</li>
<li>每一种数据源都有相应的<strong>InputStream</strong>子类。另外，<strong>FileInputStream</strong>也属于一种<strong>InputStream</strong>，为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayInputStream</strong></td>
<td>允许将内存的缓冲区当作<strong>InputStrem</strong>使用</td>
<td>缓冲区，字节将从中取出<br>          作为一种数据源：将其与<strong>FileterInputStream</strong>对象相连以提供有用接口</td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong></td>
<td>将<strong>String</strong>转换为<strong>InputStream</strong></td>
<td>字符串。底层实现实际使用<strong>StringBuffer</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td>用于从文件中读取信息</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象1相连以提供有用接口</td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td>产生用于写入相关<strong>PipedOutputStream</strong>的数据。实现“管道化”概念</td>
<td><strong>PipedOutputStream</strong><br>          作为多线程中的数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
<td>将两个或多个<strong>InputStream</strong>对象转换成单一<strong>InputStream</strong></td>
<td>两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<strong>Enumeration</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterInputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中“装饰器”为其他类的<strong>InputStream</strong>类提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><ul>
<li>该类型的类决定了输出所要去往的目标：字节数组，文件或管道。</li>
<li><strong>FilterOutputStream</strong>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td>
<td>缓冲区大小(可选的)<br>          用于指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td>用于将信息写至文件。</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td>任何写入其中的信息都会自动作为相关<strong>PipedInputStream</strong>的输出。实现“管道化”概念</td>
<td><strong>PipedInputStream</strong>          <br>指定用于多线程的数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中，“装饰器”为其他<strong>OutputStream</strong>提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><ul>
<li><strong>Java I/O</strong>类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是<strong>Java I/O</strong>类库里存在<strong>filter</strong>(过滤器)类的原因所在抽象类<strong>filter</strong>是所有装饰器的基类。</li>
<li>==装饰器必须具有和它所装饰的对象相同的接口==，但它也可以扩展接口，这种情况只发生在个别<strong>filter</strong>类中。</li>
<li>装饰器的==缺点==：在编写程序时，==增加了代码的复杂性==。<strong>Java I/O</strong>类库操作不便的原因在于：我们必须创建许多类—“核心” <strong>I/O</strong>类型加上所有的装饰器，才能得到我们所希望的单个<strong>I/O</strong>对象。</li>
<li><strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>是用来提供装饰器类接口以控制特定输入流(<strong>InputStream</strong>)和输出流(<strong>OutputStream</strong>)的两个类。<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>分别自<strong>I/O</strong>类库中的基类<strong>InputStream</strong>和<strong>OutputStream</strong>派生而来，这两个类是装饰器的必要条件。</li>
</ul>
<h4 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a>通过FilterInputStream从InputStream读取数据</h4><ul>
<li><strong>FilterInputStream</strong>类能够完成两件完全不同的事情。<ol>
<li><strong>DataInputStream</strong>允许我们读取不同的基本类型数据以及<strong>String</strong>对象(所有的方法都以“<strong>read</strong>”开头，如：<strong>readByte()</strong>,<strong>readFloat()</strong>等等)。搭配相应的<strong>DataOutputStream</strong>,就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</li>
<li>其他<strong>FilterInputStream</strong>类则在内部修改<strong>InputStream</strong>的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。</li>
</ol>
</li>
<li>我们几乎每次都要对输入进行缓冲—–不管我们正在连接的是什么<strong>I/O</strong>设备，所以，<strong>I/O</strong>类库把无缓冲输入(而不是缓冲输入)作为特殊情况(或只是方法调用)就显得更加合理了。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataInputStream</strong></td>
<td>与<strong>DataOutputStream</strong>搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)。</td>
<td><strong>InputStream</strong><br>包含用于读取基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td>使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。</td>
<td><strong>InputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong></td>
<td>跟踪输入流中的行号；可调用<strong>getLineNumber()</strong>和<strong>setLineNumber(int)</strong>。</td>
<td><strong>InputStream</strong><br>仅增加了行号，因此可能要与接口对象搭配使用。</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td>具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退。</td>
<td><strong>InputStream</strong><br>通常作为编译器的扫面器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td>
</tr>
</tbody></table>
<h4 id="通过FilterOutPutStream向OutputStream写入"><a href="#通过FilterOutPutStream向OutputStream写入" class="headerlink" title="通过FilterOutPutStream向OutputStream写入"></a>通过FilterOutPutStream向OutputStream写入</h4><ul>
<li>与<strong>DataInputStream</strong>对应的是<strong>DataOutputStream</strong>，它可以将各种<strong>基本数据类型</strong>以及<strong>String</strong>对象格式化输出到“流”中；这样，任何设备上的任何<strong>DataInputStream</strong>都能够读取它们。所有的方法都以”<strong>wirte</strong>“开头，如<strong>writeByte()</strong>,<strong>writeFloat()</strong>等等。</li>
<li><strong>PrintStream</strong>最初目的便是为了以可视化格式打印所有的<strong>基本数据类型</strong>以及<strong>String</strong>对象。这和<strong>DataOutputStream</strong>不同，后者的目的是将数据元素置入“流”中，使<strong>DataInputStream</strong>能够可移植地重构它们。</li>
<li><strong>PrintStream</strong>可能会有些问题，因为它捕捉了所有的<strong>IOException</strong>(因此，我们必需使用<strong>checkError()</strong>自行测试错误状态，如果出现错误它返回<strong>true</strong>)。另外，<strong>PrintStream</strong>也未完全国际化，不能以平台无关地方式处理换行动作(这些问题在<strong>printWriter</strong>中得到了解决)。</li>
<li><strong>BufferedOutputStream</strong>是一个修改过的<strong>OutputStream</strong>，<strong>它对数据流使用缓冲技术</strong>；因此当每次向流写入时，不必每次都进行实际的物理写操作。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
<td>与<strong>DataInputStream</strong>搭配使用，因此可以按照可移植方式向流中写入基本类型数据(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)</td>
<td><strong>OutputStream</strong><br>包含用于写入基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td>用于产生格式化输出。其中<strong>DataOutputStream</strong>处理数据的存储，<strong>PrintStream</strong>处理显示。</td>
<td><strong>OutputStream</strong>,可以用<strong>boolean</strong>值指示是否在每次换行时清空缓冲区(可选的)应该是对<strong>OutputStream</strong>对象的“<strong>final</strong>”封装。</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td>使用它以避免每次发送数据时都要进行实际的写操作。代表“使用缓冲区”。可以调用<strong>flush()</strong>清空缓冲区。</td>
<td><strong>OutputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
</tbody></table>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul>
<li><strong>Java 1.1</strong>对基本的<strong>I/O</strong>流类库进行了重大的修改。<strong>InputStream</strong>和<strong>OutputStream</strong>在以面向==字节==形式的<strong>I/O</strong>中提供极有价值的功能，<strong>Reader</strong>和<strong>Writer</strong>则提供兼容<strong>Unicode</strong>与面向==字符==的<strong>I/O</strong>功能。</li>
<li>有时我们必须把来自“<strong>字节</strong>”层次结构中的类和“<strong>字符</strong>”层次结构中的类结合起来使用。为了实现这个目的，要用到”<strong>适配器</strong>“(adapter)类：<strong>InputStreamReader</strong>可以把<strong>InputStream</strong>转换为<strong>Reader</strong>，而<strong>OutputStreamWriter</strong>可以把<strong>OutputStream</strong>转换为<strong>Writer</strong>。</li>
<li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的<strong>I/O</strong>流继承层次结构仅支持<strong>8位字节流</strong>，并且不能很好地处理<strong>16位的Unicode字符</strong>。由于<strong>Unicode</strong>用于<strong>字符国际化</strong>(<strong>Java</strong>本身的<strong>char</strong>也是16位的<strong>Unicode</strong>)，所以添加<strong>Reader</strong>和<strong>Writer</strong>继承层次结构就是为了在所有的<strong>I/O</strong>操作中都支持<strong>Unicode</strong>。</li>
</ul>
<h4 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h4><ul>
<li>在某些场合中，==面向字节==的<strong>InputStream</strong>和<strong>OutputStream</strong>才是正确的解决方案；特别是，<strong>java.util.zip</strong>类库就是==面向字节的而不是面向字符==的。因此，最明智的做法就是尽量尝试使用<strong>Reader</strong>和<strong>Writer</strong>，一旦程序代码无法成功编译，我们就会发现自己==不得不使用面向字节==的类库。</li>
<li>下面展示了在两个继承层次结构中，信息的来源和去处(即数据物理上来自哪里及去向哪里)之间的关系：</li>
</ul>
<table>
<thead>
<tr>
<th>来源与去处：Java 1.0类</th>
<th>相应的Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong><br>适配器：<strong>InputStreamReader</strong></td>
</tr>
<tr>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong><br>适配器：<strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td><strong>FileReader</strong></td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileWriter</strong></td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong>(已弃用)</td>
<td><strong>StringReader</strong></td>
</tr>
<tr>
<td>无</td>
<td><strong>StringWriter</strong></td>
</tr>
<tr>
<td><strong>ByteArrayInputStream</strong></td>
<td><strong>CharArrayReader</strong></td>
</tr>
<tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td><strong>CharArrayWriter</strong></td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td><strong>PipedReader</strong></td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td><strong>PipedWriter</strong></td>
</tr>
</tbody></table>
<h4 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h4><ul>
<li>对于<strong>InputStream</strong>和<strong>OutputStream</strong>来说，我们会使用<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>的装饰器子类来修改“<strong>流</strong>”以满足特殊需要。<strong>Reader</strong>和<strong>Writer</strong>的类继承层次结构继续沿用相同的思想，但是并不完全相同。</li>
</ul>
<table>
<thead>
<tr>
<th>过滤器 Java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FilterInputStream</strong></td>
<td><strong>FilterReader</strong></td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td><strong>FilterWriter</strong>(抽象类，没有子类)</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedReader</strong>(也有<strong>readLine()</strong>)</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td><strong>DataInputStream</strong></td>
<td>使用<strong>DataInputStream</strong>(除了当需要使用<strong>readLine()</strong>时以外，这时应该使用<strong>BufferedReader</strong>)</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td><strong>PrintWriter</strong></td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong>(已弃用)</td>
<td><strong>LineNumberReader</strong></td>
</tr>
<tr>
<td><strong>StreamTokenizer</strong></td>
<td><strong>StreamTokenizer</strong>(使用接受<strong>Reader</strong>的构造器)</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td><strong>PushbackReader</strong></td>
</tr>
</tbody></table>
<ul>
<li>无论我们何时使用<strong>readLine()</strong>,都不应该使用<strong>DataInputStream</strong>(这会遭到编译器的强烈反对)，而应该使用<strong>BufferedReader</strong>。除这一点，<strong>DataInputStream</strong>仍然是<strong>I/O</strong>类库的首选。</li>
<li><strong>PrintWriter</strong>提供了一个既能接受<strong>Writer</strong>对象又能接受任何<strong>OutputStream</strong>对象的构造器。<strong>PrintWriter</strong>的格式化接口实际上与<strong>PrintStream</strong>相同。</li>
<li>有一种<strong>PrintWriter</strong>构造器还有一个选项，就是“<strong>自动执行清空</strong>”选项。如果构造器设置此选项，则每个<strong>Println()</strong>执行之后，便会自动清空。</li>
</ul>
<h4 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h4><table>
<thead>
<tr>
<th>以下这些Java 1.0类在Java 1.1中没有相应类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
</tr>
<tr>
<td><strong>File</strong></td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>DataOutputStream</strong>，在使用时没有任何变化；因此如果想以“可传输的”格式存储和检索数据，可以使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构。</li>
</ul>
<h3 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h3><ul>
<li><strong>RandomAccessFile</strong>适用于由大小已知的记录组成的文件，所以我们可以使用<strong>seek()</strong>将记录从一处转移到另一处，然后读取或者修改记录。</li>
<li>除了实现了<strong>DataInput</strong>和<strong>DataOutput</strong>接口之外，它和这两个继承层次结构没有任何关联。甚至不适用<strong>InputStream</strong>和<strong>OutputStream</strong>类中已有的任何功能。它是一个完全独立的类，这么做是因为<strong>RandomAccessFile</strong>拥有和别的<strong>I/O</strong>类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。</li>
<li>只有RandomAccessFile支持搜寻方法，并且只适用于文件。</li>
</ul>
<h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I/O流的典型使用方式"></a>I/O流的典型使用方式</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul>
<li><p>如果想要打开一个文件用于字符输入，可以使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputReader</strong>。为了提高速度，我们希望对那个文件进行缓冲，那么将所产生的引用传给一个<strong>BufferedReader</strong>构造器。由于<strong>BufferedReader</strong>也提供了<strong>readLine()</strong>方法，所以这是我们的最终对象和进行读取的接口。当<strong>readLine()</strong>将返回<strong>null</strong>时，你就达到了文件的末尾。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串<strong>sb</strong>用来累计文件的全部内容(包括必须添加的换行符，因为<strong>readLine()</strong>已将它们删掉)。最后，调用<strong>close()</strong>关闭文件。</p>
</li>
</ul>
<h4 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h4><ul>
<li><p>下面，从<strong>BufferedInputFile.read()</strong>读入的<strong>String</strong>结果被用来创建一个<strong>StringReader</strong>。然后调用<strong>read()</strong>每次读取一个字符，并把它发送到控制台。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = sr.read())!= -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read()</strong>是以<strong>int</strong>形式返回下一字节，因此必须类型转型为<strong>char</strong>才能正确打印。</p>
</li>
</ul>
<h4 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h4><ul>
<li><p>要读取格式化数据，可以使用<strong>DataInputStream</strong>,它是一个面向字节的<strong>I/O</strong>类(不是面向字符的)。因此我们必须使用<strong>InputStream</strong>类而不是<strong>Reader</strong>类。当然，可以用<strong>InputStream</strong>以字节的形式读取任何数据(如一个文件)，不过，这里使用的是字符串。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile</span><br><span class="line">                                    .read(<span class="string">"D://HelloWorld.java"</span>)</span><br><span class="line">                                    .getBytes()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>必须为<strong>ByteArrayInputStream</strong>提供字节数组，为了产生该数组<strong>String</strong>包含了一个可以实现此项工作的<strong>getBytes()</strong>方法。所产生的<strong>ByteArrayInputStream</strong>是一个适合传递给<strong>DataInputStream</strong>的<strong>InputStream</strong>。</p>
</li>
<li><p>如果我们从<strong>DataInputStream</strong>用<strong>readByte()</strong>一次一个字节读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束。相反，我们可以使用<strong>available()</strong>方法查看还有多少可供存储的字符。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesrEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul>
<li><p>FileWriter对象可以向文件写入数据。创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出(尝试移除此包装来感受对性能的影响——缓冲往往能显著地增加I/O操作地性能)。下面，为了提供格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可作为普通文本文件读取。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://HelloWorld.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            out.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">2: 	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">3: 	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">4: 	&#125;</span></span><br><span class="line"><span class="comment">5: &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦读完输入数据流，<strong>readLine()</strong>会返回<strong>null</strong>。我们可以看到要为<strong>out</strong>显示调用<strong>close()</strong>。如果我们不为所有的输出文件调用<strong>close()</strong>,就会发现缓冲区内容不会被刷新清空，那么它们就不完整。</p>
</li>
</ul>
<h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><ul>
<li><p><strong>PrintWriter</strong>可以对数据进行格式化，以便人们阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用<strong>DataOutputStream</strong>写入数据，并用<strong>DataInputStream</strong>恢复数据。当然，这些流可以是任意形式。注意：<strong>DataOutputStream</strong>和<strong>DataInputStream</strong>是==面向字节==的，因此要使用<strong>InputStream</strong>和<strong>OutputStream</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">That was pi</span></span><br><span class="line"><span class="comment">1.41413</span></span><br><span class="line"><span class="comment">Square root of 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>DataOutputStream</strong>写入数据，<strong>Java</strong>保证我们可以使用<strong>DataInputStream</strong>准确地读取数据—无论读和写数据的平台多么不同。</p>
</li>
<li><p>当使用<strong>DataOutputStream</strong>时，写字符串并且让<strong>DataInputStream</strong>能够恢复它的==唯一可靠==的做法就是使用<strong>UTF-8</strong>编码，在示例中是用<strong>writeUTF()</strong>和<strong>readUTF()</strong>实现的。</p>
</li>
<li><p><strong>writeDouble()</strong>将<strong>double</strong>类型的数字存储到流中，并用相应的<strong>readDouble()</strong>恢复它(对于其他的数据类型，也有类似方法用于读写)。</p>
</li>
</ul>
<h4 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h4><ul>
<li><p>使用<strong>RandomAccessFile</strong>，类似于组合使用了<strong>DataInputStream</strong>和<strong>DataOutputStream</strong>(因为它实现了相同的接口：<strong>DataInput</strong>和<strong>DataOutput</strong>)。另外，利用<strong>seek()</strong>可以在文件中到处移动，并修改文件中的某个值。</p>
</li>
<li><p>使用<strong>RandomAccessFile</strong>时，你必须知道文件排版，这样才能正确使用它。<strong>RandomAccessFile</strong>拥有读取基本类型和<strong>UTF-8</strong>字符串的各种方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">" "</span>+rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">            rf.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">            rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">            rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 7.069999999999999</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 47.001</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>display()</strong>方法打开了一个文件，并以<strong>double</strong>值的形式显示了其中的七个元素。在<strong>main()</strong>中，首先创建了文件，然后打开并修改它。因为<strong>double</strong>总是8字节长，所以为了用<strong>seek()</strong>查找第5个双精度值，你只需用5*8来产生查找位置。</p>
</li>
</ul>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul>
<li>程序的<strong>所有输入</strong>都可以来自于<strong>标准输入</strong>，它的<strong>所有输出</strong>也都可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送到<strong>标准错误</strong>。<strong>标准I/O</strong>的意义在于：我们可以很容易地把程序串联起来，一个程序的<strong>标准输出</strong>可以成为另一个程序的<strong>标准输入</strong>。</li>
</ul>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul>
<li><p>按照标准<strong>I/O</strong>模型，<strong>Java</strong>提供了<strong>System.in</strong>,<strong>System.out</strong>,<strong>System.err</strong>。其中<strong>System.out</strong>已经事先被包装成了<strong>printStream</strong>对象。<strong>System.err</strong>同样也是<strong>PrintStream</strong>，但是<strong>System.in</strong>却是一个没有被包装过的未经加工的<strong>InputStream</strong>。这意味着尽管我们可以立即使用<strong>System.out</strong>和<strong>System.err</strong>，但是在读取<strong>System.in</strong>之前必须对其进行包装。</p>
</li>
<li><p>通常我们会用<strong>readLine()</strong>一次一行地读取输入，我们可以将<strong>System.in</strong>包装成<strong>BufferedReader</strong>来使用这要求我们必须用<strong>InputStreamReader</strong>把<strong>System.in</strong>转换成<strong>Reader</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><ul>
<li><p><strong>System.out</strong>是一个<strong>PrintStream</strong>，而<strong>PrintStream</strong>是一个<strong>OutputStream</strong>。<strong>PrintWriter</strong>有一个可以接受<strong>OutputStream</strong>作为参数的构造器。所以，只要需要，就可以使用那个构造器把<strong>System.out</strong>转换成<strong>PrintWriter</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将第二个参数设为<strong>true</strong>，以便开启自动清空功能；否则，有可能看不到输出。</p>
</li>
</ul>
<h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><ul>
<li><p><strong>System</strong>类提供了一些简单的静态方法调用，以允许我们对标准输入，输出和错误<strong>I/O</strong>流进行<strong>重定向</strong>：</p>
<ul>
<li><strong>setIn(InputStream)</strong></li>
<li><strong>setOut(PrintStream)</strong></li>
<li><strong>setErr(PrintStream)</strong></li>
</ul>
</li>
<li><p>如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"D://test.txt"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>I/O</strong>重定向操纵的是<strong>字节流</strong>，而不是字符流；因此我们使用的是<strong>InputStream</strong>和<strong>OutputStream</strong>，而不是<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
</ul>
<h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><ul>
<li><p><strong>JDK 1.4</strong>的<strong>java.nio.*</strong>包中引入了新的<strong>Java I/O</strong>类库，其目的在于<strong>提高速度</strong>。速度的提高在<strong>文件I/O</strong>和<strong>网络I/O</strong>中都有可能发生。</p>
</li>
<li><p>速度的提高来自所使用的结构更接近于操作系统执行<strong>I/O</strong>的方式：<strong>通道和缓冲器</strong>。</p>
</li>
<li><p>唯一直接与通道交互的缓冲器是<strong>ByteBuffer</strong>—也就是说，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<strong>ByteBuffer</strong>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但却正好，因为这是大多数操作系统中更有效的映射方式。</p>
</li>
<li><p>旧<strong>I/O</strong>类库中有三个类被修改了，用以产生<strong>FileChannel</strong>。分别是<strong>FileInputStream</strong>,<strong>FileOutputStream</strong>以及用于<strong>既读又写</strong>的<strong>RandomAccessFile</strong>。注意这些是<strong>字节操作流</strong>，与低层的<strong>nio</strong>性质一致。<strong>Reader</strong>和<strong>Writer</strong>这种<strong>字符模式类</strong>不能用于产生通道；但是<strong>java.nio.channels.Channels</strong>类提供了实用方法，用以在通道中产生<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
<li><p>下面演示上面的三种类型的流，用于产生<strong>可写</strong>的，<strong>可读可写</strong>的及<strong>可读</strong>的通道。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span> (buff.hasRemaining())</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buff.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Some text Some more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getChannel()</strong>将会产生一个<strong>FileChannel</strong>。通道是一种相当基础的东西：可以向它传送用于读写的<strong>ByteBuffer</strong>，并且可以锁定文件的某些区域用于独占式访问。</p>
</li>
<li><p>将字节存放于<strong>ByteBufferr</strong>的方法之一是：使用一种“<strong>put</strong>”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<strong>warp()</strong>方法将已存在的字节数组“包装”到<strong>ByteBuffer</strong>中。一旦如此，就不再复制底层的数组，而是把它作为所产生的<strong>ByteBuffer</strong>的存储器，我们称之为数组支持的<strong>ByteBuffer</strong>。</p>
</li>
<li><p>对于只读访问，我们必须显式地使用静态的<strong>allocate()</strong>方法来分配<strong>ByteBuffer</strong>。<strong>nio</strong>的目标就是快速移动大量数据，因此<strong>ByteBuffer</strong>的大小就显得尤为重要。</p>
</li>
<li><p>甚至达到更高的速度也有可能，方法就是使用<strong>allocateDirect()</strong>而不是<strong>allocate()</strong>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p>
</li>
<li><p>一旦调用<strong>read()</strong>来告知<strong>FileChannel</strong>向<strong>ByteBuffer</strong>存储字节，就必须调用缓冲器上的<strong>fip()</strong>，让它做好让别人读取字节的准备。</p>
</li>
<li><p>如果打算使用缓冲器执行进一步的<strong>read()</strong>操作，我们也必须得调用<strong>clear()</strong>来为每个<strong>read()</strong>做好准备。如下面这个简单文件复制程序。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，打开一个<strong>FileChannel</strong>用于读，而打开另一个以用于写。<strong>ByteBuffer</strong>被分配了空间，当<strong>FileChannel.read()</strong>返回<strong>-1</strong>时，表示我们已经到达了输入的末尾。每次<strong>read()</strong>操作之后，就会将数据输入到缓冲器中，<strong>filp()</strong>则是准备缓冲器以便它的信息可以由<strong>write()</strong>提取。<strong>write()</strong>操作之后，信息仍在缓冲器中，接着<strong>clear()</strong>操作则对所有的内部指针重新排序，以便缓冲器在另一个<strong>read()</strong>操作期间能够做好接受数据的准备。</p>
</li>
<li><p>上面的程序并不是处理此类操作的理想方式，特殊方法<strong>transferTo()</strong>和<strong>transferFrom()</strong>允许我们将一个通道和另一个通道直接相连。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><ul>
<li><p>尽管ByteBuffer只能保留字节类型的数据，但是它具有可以从其他所容纳的字节中产生出各种不同基本类型值的方法。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; bb.limit())</span><br><span class="line">            <span class="keyword">if</span> (bb.get() != <span class="number">0</span>)</span><br><span class="line">                System.out.print(<span class="string">"nonzero"</span>);</span><br><span class="line">        System.out.print(<span class="string">"i ="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"Howdy!"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = bb.getChar())!= <span class="number">0</span>)</span><br><span class="line">            System.out.print(c+<span class="string">" "</span>+<span class="string">"\b"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">        System.out.println(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getInt());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getLong());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getFloat());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getDouble());</span><br><span class="line">        bb.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i =1025Howdy!</span></span><br><span class="line"><span class="comment">12390</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">9.9471144E7</span></span><br><span class="line"><span class="comment">9.9471142E7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在分配一个<strong>ByteBuffer</strong>之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零，它的确是这样做的。这里一共检测了<strong>1024</strong>个值(由缓冲器的<strong>limit()</strong>决定)，并且所有的值都是<strong>0</strong>。</p>
</li>
<li><p>向<strong>ByteBuffer</strong>插入基本类型数据的最简单方式是：利用<strong>asCharBuffer(),asShortBuffer()</strong>等获得该缓冲器上的视图，然后使用视图的<strong>put()</strong>方法，使用<strong>ShortBuffer</strong>的<strong>put()</strong>方法时，需要进行类型转换。</p>
</li>
</ul>
<h4 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h4><ul>
<li><p>视图缓冲器(view buffer)可以让我们通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong>。<strong>ByteBuffer</strong>依然是实际存储数据的地方，“支持”着前面的视图。因此，对视图的修改都会映射成为对<strong>ByteBuffer</strong>中数据的修改。这使得我们可以很方便地向<strong>ByteBuffer</strong>插入数据。视图还允许我们从<strong>ByteBuffer</strong>一次一个地或者成批的读取基本类型值。下面，通过<strong>IntBuffer</strong>操纵<strong>ByteBuffer</strong>中的<strong>int</strong>型数值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">888</span>,<span class="number">345</span>,<span class="number">3456</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span> (ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">1811</span></span><br><span class="line"><span class="comment">888</span></span><br><span class="line"><span class="comment">345</span></span><br><span class="line"><span class="comment">3456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先用重载后的<strong>put()</strong>方法存储一个整数数组。接着<strong>get()</strong>和<strong>put()</strong>方法调用直接访问底层<strong>ByteBuffer</strong>中的某个整数位置。</p>
</li>
<li><p>一旦底层的<strong>ByteBuffer</strong>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型。</p>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p>Java I/O类库中的类支持读写压缩格式的数据流，这些类不是从Reader和Writer类派生而来的，而是属于InputStream和OutputStream继承层次结构的一部分。这是因为压缩类库是按字节方式而不是字符方式处理的。</p>
<table>
<thead>
<tr>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CheckedInputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>InputStream</strong>产生校验和(不仅是解压缩)</td>
</tr>
<tr>
<td><strong>CheckedOutputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>OutputStream</strong>产生校验和(不仅是压缩)</td>
</tr>
<tr>
<td><strong>DeflaterOutputStream</strong></td>
<td>压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipOutputStream</strong></td>
<td>一个<strong>DeflaterOutputStream</strong>，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td><strong>GZIPOutputStream</strong></td>
<td>一个个<strong>DeflaterOutputStream</strong>，用于将数据压缩成GZIP文件格式</td>
</tr>
<tr>
<td><strong>InflaterInputStream</strong></td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td><strong>GZIPInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩GZIP文件格式的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h4><ul>
<li><p>如果对单个数据流进行压缩，<strong>GZIP</strong>可能是一个比较适合的选择。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: \nGZIPcompress file\n"</span>+</span><br><span class="line">                    <span class="string">"\tUses GZIP comression to compress"</span> + <span class="string">"the file to test.gz"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"E://test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file"</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read())!= -<span class="number">1</span>)</span><br><span class="line">            out.write(c);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">"D://test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine())!= <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将输出流封装成<strong>GZIPOutputStream</strong>或<strong>ZipOutputStream</strong>，并将输入流封装成<strong>GZIPInputStream</strong>或<strong>ZipInputStream</strong>即可。</p>
</li>
</ul>
<h4 id="Java档案文件"><a href="#Java档案文件" class="headerlink" title="Java档案文件"></a>Java档案文件</h4><ul>
<li><p><strong>Zip</strong>格式也被应用于<strong>JAR</strong>(Java Archive,Java档案文件)文件格式中。这种格式就像<strong>Zip</strong>一样，可以将一组文件压缩到单个压缩文件中。</p>
</li>
<li><p>如果不采用<strong>JAR</strong>文件，<strong>Web</strong>浏览器在下载构成一个应用的所有文件时必须重复多次请求<strong>Web</strong>服务器；而且所有这些文件都是未经压缩的。如果将所有这些文件合并到一个<strong>JAR</strong>文件中，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，可以使传输时间更短。另外，处于安全考虑，<strong>JAR</strong>文件中的每个条目都可以加上数字化签名。</p>
</li>
<li><p><code>jar [options] destination [manifest] inputfile(s)</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>创建一个新的或空的压缩文档</td>
</tr>
<tr>
<td>t</td>
<td>列出目录表</td>
</tr>
<tr>
<td>x</td>
<td>解压所有文件</td>
</tr>
<tr>
<td>x file</td>
<td>解压该文件</td>
</tr>
<tr>
<td>f</td>
<td>意指：“我打算指定一个文件名。” 如果没有用这个选项，jar假设所有的输入都来自标准输入；或者在创建一个文件时，输出对象也假设为标准输出。</td>
</tr>
<tr>
<td>m</td>
<td>表示第一个参数将是用户自建的清单文件的名字</td>
</tr>
<tr>
<td>v</td>
<td>产生详细输出，描述jar所作的工作</td>
</tr>
<tr>
<td>O</td>
<td>只存储文件，不压缩文件(用来创建一个可放在类路径中的JAR文件)</td>
</tr>
<tr>
<td>M</td>
<td>不自动创建文件清单</td>
</tr>
</tbody></table>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul>
<li>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。</li>
<li><strong>Java</strong>的对象序列化将那些实现了<strong>Serializable</strong>接口的对象转换成了一个<strong>字节序列</strong>，并能在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。</li>
<li>序列化可以实现轻量级持久性。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久化的效果。</li>
<li>对象序列化主要是为了支持两种特性：<ol>
<li><strong>Java</strong>的<strong>远程方法调用(Remote Method Invocation,RMI)</strong>，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li>
<li>对<strong>Java Beans</strong>来说，对象的序列化也是必须的。使用<strong>Bean</strong>时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保留下来，并在程序启动时进行后期恢复；这种具体的工作就是由对象序列化完成的。</li>
</ol>
</li>
<li>要序列化一个对象，首先要创建某些<strong>OutputStream</strong>对象，然后将其封装在一个<strong>ObjectOutputStream</strong>对象内。这时，只需要调用<strong>writeObject()</strong>即可将对象序列化，并将其发送给<strong>OutputStream</strong>(对象化序列是基于字节的，因要使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构)。要反向进行该过程(即将一个序列化还原为一个对象)，需要将一个<strong>InputStream</strong>封装在<strong>ObjectInputStream</strong>内，然后调用<strong>readObject()</strong>。我们最后获得的是一个引用，它指向一个向上转型的<strong>Object</strong>，所以必须向下转型才能直接设置它们。</li>
</ul>
<h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><ul>
<li><p>我们将一个对象序列化，并通过网络将其作为文件传递给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个文件吗？</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    setter&amp;getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"D://X.file"</span>));</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://X.file"</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件和读取<strong>mystery</strong>对象的内容都需要<strong>User</strong>的<strong>Class</strong>对象；而<strong>Java</strong>虚拟机找不到<strong>User.class</strong>(除非它正好在类路径<strong>Classpath</strong>内)。这样就会得到一个<strong>ClassNotFoundException</strong>的异常。必须保证<strong>Java</strong>虚拟机能找到相关的<strong>.class</strong>文件。</p>
</li>
</ul>
<h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><ul>
<li>某些情况下你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</li>
<li>在这些特殊情况下，可通过实现<strong>Externalizable</strong>接口—–代替实现<strong>Serialzable</strong>接口—来对序列化进行控制。<strong>Externalizable</strong>接口继承了<strong>Serializable</strong>接口，同时还增加了两个方法：<strong>writeExternal()</strong>和<strong>readExternal()</strong>。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</li>
</ul>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><ul>
<li><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息，通常就会面临这种情况。即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式访问它。</p>
</li>
<li><p>如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个的关闭序列化。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"username = "</span>+username+<span class="string">"&amp;&amp;"</span>+<span class="string">"password = "</span>+password+<span class="string">"&amp;&amp;"</span>+<span class="string">"date"</span>+date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">"Tom"</span>,<span class="string">"11111111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span>+ a);</span><br><span class="line">        ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">                o.writeObject(a);</span><br><span class="line">                o.close();</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Recovering object at "</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        a = (Logon)in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span> + a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = 11111111&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">Recovering object at Sun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = null&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>date</strong>字段被存储到磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
</li>
<li><p>由于<strong>Externalizable</strong>对象在默认情况下不保存它们的任何字段，所以<strong>transient</strong>关键字只能和<strong>Serializable</strong>对象一起使用。</p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/I-O/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>I/O</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十七章/">
      java编程思想第十七章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h2><h3 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h3><p><img src="/2019/11/17/java编程思想第十七章/1572948167233-1573995500325.png" alt="1572948167233"></p>
<ul>
<li>Java SE5新添加了：<ul>
<li><strong>Queue</strong>接口(<strong>LinkedList</strong>已经为实现该接口做了修改及其实现<strong>PrioityQueue</strong>和各种风格的<strong>BlockingQueue</strong>)。</li>
<li><strong>ConcurrentMap</strong>接口及其实现<strong>ConcurrentHashMap</strong>(用于多线程机制)。</li>
<li><strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>,它们也是用与多线程机制。</li>
<li><strong>EnumSet</strong>和<strong>EnumMap</strong>，为使用<strong>enum</strong>而设计的<strong>Set</strong>和<strong>Map</strong>的特殊实现。</li>
<li>在<strong>Collections</strong>类中的的多个便利方法，虚线框表示<strong>abstract</strong>类，它们只是部分实现了特定接口的工具。如：你可以在创建自己的<strong>Set</strong>,那么并不用从<strong>Set</strong>接口开始并实现其中的全部方法，只需从<strong>AbstractSet</strong>继承，然后执行一些创建新类必须的工作。</li>
</ul>
</li>
</ul>
<h3 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h3><ul>
<li><p>容器的填充仍然像java.util.Arrays一样面临不足。就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill()。与Arrays版本一样，此fill()方法也是只是复制同一个对象引用来填充整个容器的，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StringAddress&#123;"</span> +</span><br><span class="line">                <span class="string">"s='"</span> + s + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>,<span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"World"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;]</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面展示了两种对单个对象引用来填充Collection的方式。</p>
<ul>
<li>第一种是使用<strong>Collections.nCopies()</strong>创建传递给构造器的<strong>List</strong>，此处填充的是<strong>ArrayList</strong>。</li>
<li>第二种是使用<strong>Collection.fill()</strong>,<strong>fill()</strong>方法的用处有限，因为它只能替换已经在<strong>List</strong>中存在的元素，而不能添加新元素。</li>
</ul>
</li>
</ul>
<h3 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends T&gt;)</td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true(可选的)移除容器中的所有元素(可选的)</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection&lt;?&gt;)</td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素时返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>，可以用来遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回true(可选的)</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素。只要有移除动作发生就返回true(可选的)</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素(应用集合论的“交集”概念)。只要Collection发生了改变就返回true(可选的)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中元素的数目</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素(可选)</td>
</tr>
</tbody></table>
<ul>
<li>其中不包括随机访问所选择元素的<strong>get()</strong>方法。因为<strong>Collection</strong>包括<strong>Set</strong>，而<strong>Set</strong>是自己维护内部顺序的。因此，如果想检查<strong>Collection</strong>中的元素，那就必须使用迭代器。</li>
</ul>
<h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><ul>
<li>执行各种不同的添加和移除的方法在<strong>Collection</strong>接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。</li>
<li>接口时面向对象设计中的契约，它声明“<strong>无论你选择如何实现该接口，我保证你可以向该接口发送这些消息</strong>”，但是可选操作违反了这个非常基本的原则，它声明调用某些方法将不会执行有意义的行为，相反，他会抛出异常。</li>
<li>如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。</li>
<li>为什么将方法定义为可选的？因为这样做可以防止在设计中出现==接口爆炸==的情况。容器类库中的其他设计看起来总是为了描述每个主题的各种变体，而最终患上了接口过剩症。甚至这么做仍不能捕捉接口的各种特例，因为总有人发明新的接口，“未获支持的操作”这种方式可以实现Java容器类库的一个重要目标：==容器应该易学易用==。未获支持的操作是一种特例，可以延迟到需要时再实现。但是为了让这种方式能工作。<ol>
<li><strong>UnsupportedOperationException</strong>必须是一种罕见事件，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。这种设计留下了一个“后门”，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么它仍旧适合现有的类库。</li>
<li>如果一个操作是未获支持的，那么在实现接口的时候可能就会导致<strong>UnsupportedOperationException</strong>异常。毕竟，它表示编程上有错误，使用了不正确的接口实现。</li>
</ol>
</li>
<li>未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。</li>
</ul>
<h4 id="未获支持的操作"><a href="#未获支持的操作" class="headerlink" title="未获支持的操作"></a>未获支持的操作</h4><ul>
<li><p>常见的未获支持的操作，都来源于背后由==固定尺寸的数据结构支持的容器==，当你用<strong>Arrays.asList()</strong>将数组转换为<strong>List</strong>时，就会得到这样的容器。还可以通过使用<strong>Collections</strong>类中的“不可修改”的方法，选择创建任何会抛出<strong>UnsupportedOperationException</strong>的容器(包括Map)。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---"</span>+msg+<span class="string">"---"</span>);</span><br><span class="line">        Collection&lt;String&gt; c = list;</span><br><span class="line">        Collection&lt;String&gt; subList = list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.retainAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"retainAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.removeAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"removeAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"clean()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.add(<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.addAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.remove(<span class="string">"C"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"remove()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(<span class="number">0</span>,<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A B C D E F G H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"Modifiable Copy"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"Arrays.asList()"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList()"</span>, Collections.unmodifiableList(</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;(list)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Modifiable Copy---</span></span><br><span class="line"><span class="comment">---Arrays.asList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">---unmodifiableList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">List.set()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arrays.asList()</strong>会生成一个<strong>List</strong>，它基于一个固定大小的数组，仅支持那些不会改变数组大小的操作，任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个<strong>UnsupportedOpreationException</strong>异常，以表示对未获支持操作的调用(一个编程错误)。</p>
</li>
<li><p>应该把<strong>Arrays.asList()</strong>的结果作为构造器的参数传递给任何<strong>Collection</strong>(或者使用<strong>addAll()</strong>方法，或<strong>Collections.addAll()</strong>静态方法)，这样可以生成允许使用所有的方法的普通容器，这样的调用会产生新的尺寸可调的底层数据结构。</p>
</li>
<li><p><strong>Collections</strong>类中的”不可修改”的方法将容器包装到了一个代理中，只要你执行任何试图修改容器的操作，这个代理都会产生<strong>UnsupportedOperationException</strong>异常，使用这些方法的目标就是产生”常量”容器对象。</p>
</li>
</ul>
<h3 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h3><ul>
<li><p>在<strong>Java</strong>中像<strong>Integer</strong>和<strong>String</strong>这样的<strong>Java</strong>预定义的类型，这些类型被设计为可以在容器内部使用。当你创建自己的类型时，要意识到<strong>Set</strong>需要一种方式来维护存储顺序，而存储顺序如何维护，则是在<strong>Set</strong>的不同实现之间会有所变化。因此，不同的<strong>Set</strong>实现不仅具有不同的行为，而且它们对于可以在特定的<strong>Set</strong>中放置的元素的类型也有不同的要求。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Set</strong>(interface)</td>
<td>存入<strong>Set</strong>的每个元素都必须是唯一的，因为<strong>Set</strong>不保存重复元素。加入<strong>Set</strong>的元素必须定义<strong>equals()</strong>方法以确保对象的唯一性。<strong>Set</strong>与<strong>Collection</strong>有完全一样的接口。<strong>Set</strong>接口不保证维护元素的次序。</td>
</tr>
<tr>
<td><strong>HashSet</strong>(项目中最常使用)</td>
<td>为快速查找而设计的<strong>Set</strong>。存入<strong>HashSet</strong>的元素必须定义<strong>hashCode()</strong></td>
</tr>
<tr>
<td><strong>TreeSet</strong></td>
<td>保持次序的<strong>Set</strong>，底层为树结构。使用它可以从<strong>Set</strong>中提取有序的序列。元素必须实现<strong>Comparable</strong>接口。</td>
</tr>
<tr>
<td><strong>LinkedHashSet</strong></td>
<td>具有<strong>HashSet</strong>的查询速度，且内部使用链表维护元素的顺序(插入的顺序)。于是在使用迭代器遍历<strong>Set</strong>时，结果会按元素的次序显示。元素也必须定义<strong>hashCode()</strong>方法。</td>
</tr>
</tbody></table>
</li>
<li><p>你必须为散列存储和树形存储都创建一个<strong>equals()</strong>方法，但是<strong>hashCode()</strong>只有在这个类将被置于<strong>HashSet</strong>或<strong>LinkedHashSet</strong>中时才是必需的。但是建议你应该在覆盖<strong>equals()</strong>方法时，总是同时覆盖<strong>hashCode()</strong>方法。</p>
</li>
<li><p>下面演示为了成功的使用特定的Set实现类而必须定义的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        i = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i == ((SetType)o).i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeType arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arg.i &lt; i ? -<span class="number">1</span> : (arg.i == i ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fill</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(</span><br><span class="line">                        type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="comment">[7, 7, 0, 8, 5, 9, 4, 1, 1, 3, 2, 3, 1, 9, 2, 8, 4, 6, 5, 4, 6, 8, 0, 3, 7, 5, 0, 6, 2, 9]</span></span><br><span class="line"><span class="comment">[2, 6, 1, 7, 1, 4, 0, 0, 9, 9, 9, 4, 7, 8, 0, 3, 8, 8, 7, 6, 3, 5, 5, 1, 6, 2, 2, 4, 3, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException: java.lang.ClassCastException: com.ym.ThinkingInJava.SetType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: com.ym.ThinkingInJava.HashType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了证明那些方法对于某种特定的<strong>Set</strong>是必需的，并且同时还要避免代码重复，我们创建了三个类，基类<strong>SetType</strong>只存储一个<strong>int</strong>，并且通过<strong>toString()</strong>方法产生它的值。因为所有在<strong>Set</strong>中存储的类都必须具有<strong>equals()</strong>方法，因此在基类中也有该方法。其等价性是基于这个<strong>int</strong>类型的<strong>i</strong>的值来确定的。</p>
</li>
<li><p><strong>HashType</strong>继承自<strong>SetType</strong>，并且添加了<strong>hashCode()</strong>方法，该方法对于放置到<strong>Set</strong>的散列实现中的对象来说是必需的。</p>
</li>
<li><p><strong>TreeType</strong>实现了<strong>Comparable</strong>接口，如果一个对象被用于任何种类的排序容器中，如<strong>SortedSet</strong>(<strong>TreeSet</strong>的其唯一实现)，那么它必须实现这个接口。注：==在<strong>compareTo()</strong>中，没有使用“简洁明了”的形式<strong>return i-i2,</strong>因为这是一个常见的编程错误，它只有在<strong>i</strong>和<strong>i2</strong>都是无符号的<strong>int</strong>(如果<strong>Java</strong>确实有<strong>unsigned</strong>关键字的话，但实际上并没有)时才能正确工作。对于<strong>Java</strong>的有符号<strong>int</strong>，他就会出错，因为<strong>int</strong>不够大，不足以表现两个有符号<strong>int</strong>的差。如：<strong>i</strong>是一个很大的正数，而j是很大的负整数，<strong>i-j</strong>就会溢出并且返回负值，这就不正确了==。</p>
</li>
<li><p><strong>fill()</strong>和<strong>test()</strong>方法都是使用泛型定义的，这是为了避免代码重复。</p>
</li>
<li><p><strong>HashSet</strong>以某种神秘的顺序保存所有的元素，<strong>LinkedhashSet</strong>按照元素插入的顺序保存元素，而<strong>TreeSet</strong>按照排序顺序维护元素(按照<strong>compareTo()</strong>的实现方式，这里维护的是降序)</p>
</li>
<li><p>对于没有重新定义<strong>hashCode()</strong>方法的<strong>SetType</strong>或<strong>TreeType</strong>，如果将它们放置到任何散列实现中都会产生重复值，这样就违反了Set的基本契约。</p>
</li>
<li><p>如果在<strong>TreeSet</strong>中使用没有实现<strong>Comparable</strong>的类型，那么你将会得到更确定的结果，在<strong>TreeSet</strong>试图将该对象当作<strong>Comparable</strong>使用时，将抛出一个异常。</p>
</li>
</ul>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><ul>
<li>SortedSet中的元素可以保证处于排序状态，这使得它可以通过在SortedSet接口中的下列方法提供附加的功能：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Set</strong>使用的<strong>Comparator</strong>;或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>Object first()</strong></td>
<td>返回容器中的第一个元素。</td>
</tr>
<tr>
<td><strong>Object last()</strong></td>
<td>返回容器中的最末一个元素</td>
</tr>
<tr>
<td><strong>SortedSet subSet(fromElement,toElement)</strong></td>
<td>生成此Set的子集，范围从<strong>fromElement</strong>(包含)到<strong>toElement</strong>(不包含)</td>
</tr>
<tr>
<td><strong>SortedSet headSet(toElement)</strong></td>
<td>生成此<strong>Set</strong>的元素，由小于<strong>toElement</strong>的元素组成</td>
</tr>
<tr>
<td><strong>SortedSet tailSet(fromElement)</strong></td>
<td>生成此<strong>Set</strong>的子集，由大于或等于<strong>fromElement</strong>的元素组成</td>
</tr>
</tbody></table>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(sortedSet,<span class="string">"one two three four five six seven eight"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">3</span>) low = it.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) high = it.next();</span><br><span class="line">            <span class="keyword">else</span> it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">        System.out.println(sortedSet.headSet(high));</span><br><span class="line">        System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">eight</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">[one, seven, six, three]</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three]</span></span><br><span class="line"><span class="comment">[one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SortedSet</strong>是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用<strong>LinkedHashSet</strong>来保存。</p>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>除并发应用，<strong>Queue在SE5中仅有的两个实现是LinkedList和PriorityQueue</strong>，两者的<strong>差异在于排序行为而不是性能</strong>。</p>
</li>
<li><p>下面是Queue实现的大部分操作的示例，包括基于并发的Queue.你可以将元素从队列的一端插入，并从另一端将它们抽取出来：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)</span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        String[] s = (<span class="string">"one two three four five six seven eight nine ten"</span>).split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了优先级队列(<strong>PriorityBlockingQueue,PriorityQueue</strong>)，<strong>Queue</strong>将精确地按照元素被置于<strong>Queue</strong>中的顺序产生它们。</p>
</li>
</ul>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><ul>
<li><p>该列表中的每个对象都包含一个字符串和一个主要的以及次要的优先级值。该列表的排序顺序也是通过实现Comparable而进行控制的。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoList</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDoList</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String td,<span class="keyword">char</span> pri, <span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.primary = pri;</span><br><span class="line">            <span class="keyword">this</span>.secondary = sec;</span><br><span class="line">            <span class="keyword">this</span>.item = td;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ToDoItem arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primary &gt; arg.primary)</span><br><span class="line">                <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (primary == arg.primary)</span><br><span class="line">                <span class="keyword">if</span> (secondary &gt; arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (secondary == arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toString(primary)+secondary+<span class="string">": "</span>+item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ToDoList toDoList = <span class="keyword">new</span> ToDoList();</span><br><span class="line">        toDoList.add(<span class="string">"Empty trash"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed bird"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Mow lawn"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Water lawn"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed cat"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!toDoList.isEmpty())</span><br><span class="line">            System.out.println(toDoList.remove());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A1: Water lawn</span></span><br><span class="line"><span class="comment">A2: Feed dog</span></span><br><span class="line"><span class="comment">B1: Feed cat</span></span><br><span class="line"><span class="comment">B7: Feed bird</span></span><br><span class="line"><span class="comment">C3: Mow lawn</span></span><br><span class="line"><span class="comment">C4: Empty trash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><ul>
<li><p>双向队列(双端队列)就像是一个队列，但是你可以在任何一端添加或移除元素。在<strong>LinkedList</strong>中包含支持双向队列的方法，但是在<strong>Java</strong>标准类库中没有任何显式的用于双向队列的接口。因此，<strong>LinkedList</strong>无法去实现这样的接口，你也无法转型到<strong>Queue</strong>那样去向上转型为<strong>Deque(双向队列/dek/)</strong>。但是，你可以使用组合来创建一个<strong>Deque</strong>类，并直接从<strong>LinkedList</strong>中暴露相关的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    ..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillTest</span><span class="params">(Deque&lt;Integer&gt; deque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            deque.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">55</span>; i++) &#123;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; di = <span class="keyword">new</span> Deque&lt;&gt;();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        System.out.println(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeFirst() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeLast() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[26, 25, 24, 23, 22, 21, 20, 50, 51, 52, 53, 54]</span></span><br><span class="line"><span class="comment">26 25 24 23 22 21 20 50 51 52 53 54 </span></span><br><span class="line"><span class="comment">54 53 52 51 50 20 21 22 23 24 25 26 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你可能不太在两端放入元素并抽取它们，因此，<strong>Deque</strong>不如<strong>Queue</strong>那样常用。</p>
</li>
</ul>
<h3 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h3><ul>
<li><p>标准的<strong>Java</strong>类库中包含了<strong>Map</strong>的几种基本实现，包括：<strong>HashMap</strong>,<strong>TreeMap</strong>,<strong>LinkedHashMap</strong>,<strong>WeakHashMap</strong>,<strong>ConcurrentHashMap</strong>,<strong>IdentityHashMap</strong>。</p>
</li>
<li><p>上面实现类都有同样的基本接口<strong>Map</strong>，但是行为特征各不相同，==这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和判定“键”等价的策略等方面==。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        pairs = <span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= pairs.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        pairs[index++] = <span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(pairs[i][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++) &#123;</span><br><span class="line">            result.append(pairs[i][<span class="number">0</span>].toString());</span><br><span class="line">            result.append(<span class="string">" : "</span>);</span><br><span class="line">            result.append(pairs[i][<span class="number">1</span>].toString());</span><br><span class="line">            <span class="keyword">if</span> (i &lt; index - <span class="number">1</span>)</span><br><span class="line">                result.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AssociativeArray&lt;String,String&gt; map = <span class="keyword">new</span> AssociativeArray&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">"sky"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        map.put(<span class="string">"grass"</span>,<span class="string">"green"</span>);</span><br><span class="line">        map.put(<span class="string">"ocean"</span>,<span class="string">"dancing"</span>);</span><br><span class="line">        map.put(<span class="string">"tree"</span>,<span class="string">"tall"</span>);</span><br><span class="line">        map.put(<span class="string">"earth"</span>,<span class="string">"brown"</span>);</span><br><span class="line">        map.put(<span class="string">"sun"</span>,<span class="string">"warm"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">"extra"</span>,<span class="string">"object"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Too many objects!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"ocean"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Too many objects!</span></span><br><span class="line"><span class="comment">sky : blue</span></span><br><span class="line"><span class="comment">grass : green</span></span><br><span class="line"><span class="comment">ocean : dancing</span></span><br><span class="line"><span class="comment">tree : tall</span></span><br><span class="line"><span class="comment">earth : brown</span></span><br><span class="line"><span class="comment">sun : warm</span></span><br><span class="line"><span class="comment">dancing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关联数组中的基本方法是<strong>put()</strong>和<strong>get()</strong>,<strong>toString()</strong>方法被覆盖为可以打印键-值对，<strong>main()</strong>用字符串加载了一个<strong>AssociativeArray</strong>，并打印所产生的映射表，随后是获取一个值的<strong>get()</strong>。</p>
</li>
<li><p>上面中为了使用<strong>get()</strong>方法，你需要传递想要查找的<strong>key</strong>，然后它会将于之相关联的值作为结果返回，或者在找不到的情况下返回<strong>null</strong>，<strong>get()</strong>方法使用的是效率最差的方式来定位值的：从数组的头部开始，使用<strong>equals()</strong>方法依次比较键。</p>
</li>
<li><p>上面示例中的版本是说明性的，但是缺乏效率，并且由于固定的尺寸而显得很不灵活，但是在<strong>java.util</strong>中的各种<strong>Map</strong>都没有这些问题，并且可以替代到上面的示例中。</p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>性能是映射表中的一个重要问题，当在<strong>get()</strong>中使用线性搜索时，执行速度会相当地慢，而这正是<strong>HashMap</strong>提高速度的地方。<strong>HashMap</strong>使用了特殊的值，称为散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的，用以代表对象的<strong>int</strong>值，它是通过将该对象的某些信息进行转换而生成的。<strong>hashCode()</strong>是根类<strong>Object</strong>中的方法，因此所有<strong>Java</strong>对象都能产生散列码。</li>
<li>HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashMap</strong>(默认选择)</td>
<td><strong>Map</strong>基于==散列表的实现==(它取代了<strong>Hashtable</strong>)。==插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。==</td>
</tr>
<tr>
<td><strong>LinkedHashMap</strong></td>
<td>类似于<strong>HashMap</strong>，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(<strong>LRU</strong>)的次序。==只比<strong>HashMap</strong>慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。==</td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td>基于红黑树的实现。==看“键“或”键值对“时，它们会被排序(次序由<strong>Comparable</strong>或<strong>Comparator</strong>决定)。====<strong>TreeMap</strong>的特点在于，所得到的结果是经过排序的。<strong>TreeMap</strong>是唯一的带有<strong>subMap()</strong>方法的<strong>Map</strong>，他可以返回一个子树。==</td>
</tr>
<tr>
<td><strong>WeakHashMap</strong></td>
<td>弱键(<strong>weak key</strong>)映射，允许释放映射所指向的对象；==这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个”键”，则此”键“可以被垃圾收集器回收。==</td>
</tr>
<tr>
<td><strong>ConcurrentHashMap</strong></td>
<td>一种线程安全的<strong>Map</strong>，它不涉及同步加锁。</td>
</tr>
<tr>
<td><strong>IdentityHashMap</strong></td>
<td>==使用代替<strong>equals()</strong>对”键“进行比较的散列映射，专为解决特殊问题而设计的。==</td>
</tr>
</tbody></table>
<ul>
<li>散列是映射中存储元素时最常用的方式。</li>
<li>对<strong>Map</strong>中使用的键的要求与对<strong>Set</strong>中的元素的要求一样，任何键都必须具有一个<strong>equals()</strong>方法；如果键被用于散列<strong>Map</strong>，那么它必须还具有恰当的<strong>hashCode()</strong>方法，如果键被用于<strong>TreeMap</strong>，那么它还必须实现<strong>Comparable</strong>。</li>
</ul>
<h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h4><ul>
<li>使用<strong>SortedMap</strong>(==<strong>TreeMap</strong>是现阶段的唯一实现==)，==可以确保键处于排序状态==，这使得它具有额外的功能，这些功能由<strong>SortedMap</strong>接口中的以下方法提供：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Map</strong>使用的<strong>Comparator</strong>；或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>T firstKey()</strong></td>
<td>返回<strong>Map</strong>中的第一个键。</td>
</tr>
<tr>
<td><strong>T lastKey()</strong></td>
<td>返回<strong>Map</strong>中的最末一个键。</td>
</tr>
<tr>
<td><strong>SortedMap subMap(fromKey,toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，范围由<strong>fromKey</strong>(包含)到<strong>toKey</strong>(不包含)的键确定。</td>
</tr>
<tr>
<td><strong>SortedMap headMap(toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键小于<strong>toKey</strong>的所有键值对组成。</td>
</tr>
<tr>
<td><strong>SortedMap tailMap(fromKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键大于或等于<strong>fromKey</strong>的所有键值对组成。</td>
</tr>
</tbody></table>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>为了==提高速度==，<strong>LinkedHashMap</strong>==散列化所有元素==，但是在==遍历键值对==时，却又==以元素的插入顺序返回键值对==(<strong>System.out.println()</strong>会迭代遍历该映射，因此可以看到遍历的结果)。此外，可以在构造器中设定<strong>LinkedHashMap</strong>，使之采用基于访问的==最近最少使用(<strong>LRU</strong>)算法==，于是==没有被访问过的==(可被看作需要删除的)==元素就会出现在队列的前面==。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</li>
</ul>
<h3 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h3><ul>
<li><p>当你自己创建用作<strong>HashMap</strong>的键的类，==有可能会忘记在其中放置必须的方法==，而这是通常会犯的一个错误。如：一个天气预报系统，将<strong>Groundhog</strong>对象与<strong>Prediction</strong>对象练习起来。创建这两个类，使用<strong>Groundhog</strong>作为键，<strong>Prediction</strong>作为值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        number = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Groundhog&#123;"</span> +</span><br><span class="line">                <span class="string">"number="</span> + number +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow = rand.nextDouble() &gt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shadow)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of Winter!"</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog = type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map = <span class="keyword">new</span> HashMap&lt;Groundhog,Prediction&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">            System.out.println(<span class="string">"map="</span>+map);</span><br><span class="line">            Groundhog gh = ghog.newInstance(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"Looking up prediction for "</span>+gh);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(gh))</span><br><span class="line">                System.out.println(map.get(gh));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"Key not found:"</span> + gh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        detectSpring(Groundhog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#5=Early Spring, Groundhog#9=Six more weeks of Winter!, Groundhog#8=Six more weeks of Winter!, Groundhog#7=Early Spring, Groundhog#1=Six more weeks of Winter!, Groundhog#3=Early Spring, Groundhog#6=Early Spring, Groundhog#0=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#4=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Key not found:Groundhog#3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<strong>Groundhog</strong>被给予一个标识数字，于是可以在<strong>HashMap</strong>中这样查找<strong>Prediction</strong>,“给我与<strong>Groundhog#3</strong>相关的<strong>Prediction</strong>”。<strong>Prediction</strong>类包含一个<strong>boolean</strong>值和一个<strong>toString()</strong>方法。<strong>boolean</strong>值使用<strong>java.util.random()</strong>来初始化；而<strong>toString()</strong>方法则解释结果。<strong>detectSpring()</strong>方法使用反射机制来实例化及使用<strong>Groundhog</strong>类或任何从<strong>Groundhog</strong>派生出来的类。如果我们为解决当前问题从<strong>Groundhog</strong>继承创建了一个新类型的时候，<strong>detectSpring()</strong>方法使用的这个技巧就变得很有用了。</p>
</li>
<li><p>首先会使用<strong>Groundhog</strong>和与之相关联的<strong>prediction</strong>填充<strong>HashMap</strong>，然后打印<strong>HashMap</strong>，以便可以观察它是否被填入了一些内容。然后使用标识数字为3的<strong>Groundhog</strong>作为键，查找与之对应的预报内容。</p>
</li>
<li><p>但是它不工作，它无法找到数字3这个键，问题出在<strong>Groundhog</strong>自动的继承自基类<strong>Object</strong>，所以这里使用<strong>Object</strong>的<strong>hashCode()</strong>方法生成散列码，而==它默认是使用对象的地址计算散列码。==</p>
</li>
<li><p>也许你会认为，==只需要恰当的<strong>hashCode()</strong>方法的覆盖版本即可。但是它仍然无法正常运行，除非你同时覆盖<strong>equals()</strong>方法，==它也是<strong>Object</strong>的一部分。<strong>HashMap</strong>使用<strong>equals()</strong>判断当前的键是否与表中存在的键相同。</p>
</li>
<li><p>正确的<strong>equals()</strong>方法必须满足下面==5个条件==：</p>
<ol>
<li>==自反性。对任意x,x.equals(x)一定返回true。==</li>
<li>==对称性。对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。==</li>
<li>==传递性。对任意x,y,z,如果有x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。==</li>
<li>==一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。==</li>
<li>==对任何不是null的x，x.equals(null)一定返回false。==</li>
</ol>
</li>
<li><p>默认的<strong>Object.equals()</strong>只是==比较对象的地址==，所以一个<strong>Groundhog(3)</strong>并不等于另一个<strong>Groundhog(3)</strong>。因此，==<u>如果要使自己的类作为<strong>HashMap</strong>的键，必须同时重载<strong>hashCode()</strong>和<strong>equals()</strong></u>==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog2</span> <span class="keyword">extends</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Groundhog2 &amp;&amp;</span><br><span class="line">                (number == ((Groundhog2)obj).number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringDetector.detectSpring(Groundhog2.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#0=Six more weeks of Winter!, Groundhog#1=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#3=Early Spring, Groundhog#4=Six more weeks of Winter!, Groundhog#5=Early Spring, Groundhog#6=Early Spring, Groundhog#7=Early Spring, Groundhog#8=Six more weeks of Winter!, Groundhog#9=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Early Spring</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管<strong>equals()</strong>方法只是检查其参数是否为<strong>Groundhog2</strong>的实例，但是<strong>instanceof</strong>悄悄地检查了此对象是否为<strong>null</strong>，因为如果<strong>instanceof</strong>左边的参数为<strong>null</strong>，它会返回<strong>false</strong>。如果<strong>equals()</strong>的参数不为<strong>null</strong>且类型正确，则基于每个对象中实际的<strong>number</strong>数值进行比较。</p>
</li>
<li><p>当在HashSet中使用自己的类作为键时，必须注意这个问题。</p>
</li>
</ul>
<h4 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h4><ul>
<li>上面说明了，如果不为你的键覆盖<strong>hashCode()</strong>和<strong>equals()</strong>，那么使用散列的数据结构(<strong>HashSet</strong>,<strong>HashMap</strong>,<strong>LinkedHashSet</strong>或<strong>LinkedHashMap</strong>)就无法正确处理你的键。</li>
<li>使用散列的目的在于：想要使用一个对象来查找另一个对象。</li>
<li>不过使用<strong>TreeMap</strong>或者你实现的<strong>Map</strong>也可以达到此目的。</li>
</ul>
<h4 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h4><ul>
<li>==散列的价值在于速度：散列使得查询得以快速进行==。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用<strong>Collections.binarySearch()</strong>进行查询。</li>
<li>散列则更近一步，它将键保存在某处，以便能很快找到，存储一组元素最快的数据结构是数组，所以使用它来表示键的信息，但是因为数组不能调整容量，因此会出现问题，我们希望在<strong>Map</strong>中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办？</li>
<li>解决方案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在<strong>Object</strong>中的，且可能由你的类覆盖的<strong>hashCode()</strong>方法(在计算机科学的术语中称为散列函数)生成。</li>
<li>查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突(如果值的数量是固定的，那么就有可能)，那可就有一个完美的散列函数，但是这种情况只是特例。通常，冲突由外部链接处理：==数组并不能直接保存值，而是保存值的<strong>list</strong>。==然后对<strong>list</strong>中的值使用<strong>equals()</strong>方法进行线性查询，这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个<strong>list</strong>，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是<strong>HashMap</strong>会如此之快的原因。</li>
</ul>
<h4 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h4><ul>
<li><p>设计<strong>hashCode()</strong>时最重要的因素就是：无论何时，对同一个对象调用<strong>hashCode()</strong>都应该生成同样的值。如果在将一个对象用<strong>put()</strong>添加进<strong>HashMap</strong>时产生一个<strong>hashCode()</strong>值，而用<strong>get()</strong>取出时却产生另一个<strong>hashCode()</strong>值，那么就无法重新取得该对象了。</p>
</li>
<li><p>此外，也不应该使<strong>hashCode()</strong>依赖于具有唯一性的对象信息，尤其是使用<strong>this</strong>的值，这只能产生糟糕的<strong>hashCode()</strong>。因为这样做无法生成一个新的键，使之与<strong>put()</strong>中原始的键值对中的键相同。</p>
</li>
<li><p><strong>String</strong>有个特点：==如果程序中有多个<strong>String</strong>对象，都包含相同的字符串序列，那么这些<strong>String</strong>对象都映射到同一块内存区域。==所以<strong>new String(“hello”)</strong>生成的两个实例，虽然是相互独立的，但是对它们使用<strong>hashCode()</strong>应该生成同样的结果。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] hellos = <span class="string">"Hello Hello"</span>.split(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(hellos[<span class="number">0</span>].hashCode());</span><br><span class="line">        System.out.println(hellos[<span class="number">1</span>].hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对<strong>String</strong>而言，<strong>hashCode()</strong>明显是基于<strong>String</strong>的内容的。</p>
</li>
<li><p>要想使<strong>hashCode()</strong>实用，它必须基于对象的内容生成散列码。(散列码不必是独一无二的，但是通过<strong>hashCode()</strong>和<strong>equals()</strong>，必须能够完全确定对象的身份)</p>
</li>
<li><p>因为在生成桶的下标前，<strong>hashCode()</strong>还需要做进一步的处理，所以散列码的生成范围并不重要，只要是<strong>int</strong>即可。</p>
</li>
<li><p>好的<strong>hashCode()</strong>应该产生分布均匀的散列码。如果散列码都集中在一块，那么<strong>HashMap</strong>或者<strong>HashSet</strong>在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p>
</li>
</ul>
<h3 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h3><ul>
<li><strong>Hashtable</strong>,<strong>Vector</strong>和<strong>Stack</strong>的“<strong>特征</strong>”是，它们是过去遗留下来的类，目的是为了支持老的程序(最好不要在新的程序中使用它们)</li>
<li>容器之间的区别通常归结为由什么在背后“支持”它们。也就是说，==所使用的接口是由什么样的数据结构实现的。==</li>
</ul>
<h4 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h4><ul>
<li>对于背后有数组支撑的<strong>List</strong>和<strong>ArrayList</strong>，无论列表的大小如何，访问都很快速和一致，而对于<strong>LinkedList</strong>，访问时间对于较大的列表将明显增加。显然，如果你需要执行大量的随机访问，链表不会是一种好的选择。</li>
<li>当在列表中间插入新的元素。对于<strong>ArrayList</strong>，当列表变大时，其开销将变得很高昂，但是对于<strong>LinkedList</strong>，相对来说比较低廉，并且不随列表尺寸而发生变化。这是因为<strong>ArrayList</strong>在插入时，必须创建空间并将它的所有引用向前移动，这会随<strong>ArrayList</strong>的尺寸增加而产生高昂的代价。<strong>LinkedList</strong>只需链接新的元素，而不必修改列表中剩余的元素。</li>
<li><strong>LinkedList</strong>对<strong>List</strong>的端点会进行特殊处理，这使得在将<strong>LinkedList</strong>用作<strong>Queue</strong>时，速度可以得到提高。但是，如果你在列表的中间增加或移除元素，其中会包含随机访问的代价，这在不同的<strong>List</strong>实现中变化很大。</li>
<li>在<strong>LinkedList</strong>中的插入和移除代价相当低廉，并且不随列表尺寸发生变化，但是对于<strong>ArrayList</strong>，插入操作代价特别高昂，并且其代价将随列表尺寸的增加而增加。</li>
<li>对于随机访问的<strong>get()</strong>和<strong>set()</strong>操作，背后有数组支撑的<strong>List</strong>只比<strong>ArrayList</strong>稍快一点，但是对于<strong>LinkedList</strong>，同样的操作会变得异常的高昂。因为它本身就不是针对随机访问操作而设计的。</li>
<li>==最佳的做法可能是将<strong>ArrayList</strong>作为默认首选==，只有你需要使用额外的功能，或者当程序的性能因为经常从表中进行插入和删除而变差的时候，才去选择<strong>LinkedList</strong>。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支撑的<strong>List</strong>(就像<strong>Arrays.asList()</strong>产生的列表)，也可以选择真正的数组。</li>
<li><strong>CopyOnWriteArrayList</strong>是<strong>List</strong>的特殊实现，专门用于并发编程。</li>
</ul>
<h4 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h4><ul>
<li><strong>HashSet</strong>的性能基本上总是比<strong>TreeSet</strong>好，特别是在添加和查询元素时，<strong>TreeSet</strong>存在的唯一原因是它可以维持元素的排序状态；所以，只有当需要一个排好序的<strong>Set</strong>时，才用<strong>TreeSet</strong>。因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，所以，用<strong>TreeSet</strong>迭代通常比用<strong>HashSet</strong>要快。</li>
<li>对于插入操作，<strong>LinkedHashSet</strong>比<strong>HashSet</strong>的代价更高；这是由维护链表所带来额外开销造成的。</li>
</ul>
<h4 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h4><ul>
<li>除了<strong>IdentityHashMap</strong>,所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。</li>
<li><strong>Hashtable</strong>的性能大体上与<strong>HashMap</strong>相当。因为<strong>HashMap</strong>是用来替代<strong>Hashtable</strong>的，因此它们使用了相同的底层存储和查找机制。</li>
<li><strong>TreeMap</strong>通常比<strong>HashMap</strong>要慢。与使用<strong>TreeSet</strong>一样，<strong>TreeMap</strong>是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。</li>
<li>当使用<strong>Map</strong>时，你的第一选择应该是<strong>HashMap</strong>,只有在你要求<strong>Map</strong>始终保持有序时，才需要使用<strong>TreeMap</strong>。</li>
<li><strong>LinkedHashMap</strong>在插入时比<strong>HashMap</strong>慢一点，因为它维护散列数据结构的同时还要维护链表(以保持插入顺序)。正是由于这个列表，使得其迭代速度更快。</li>
<li><strong>IdentityHashMap</strong>则具有完全不同的性能，==因为它使用的是<strong>==</strong>而不是<strong>equals()</strong>来比较元素。==</li>
</ul>
<h5 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h5><ul>
<li>我们可以通过手工调整<strong>HashMap</strong>来提高其性能，从而满足我们特定应用的需求。为了在调整<strong>HashMap</strong>时理解性能问题，下面术语必要了解以下：<ul>
<li>==<strong>容量</strong>==：表中的桶位数。</li>
<li>==<strong>初始容量</strong>==：表在创建时所拥有的桶位数。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定初始容量的构造器。</li>
<li>==<strong>尺寸</strong>==：表中当前存储的项数。</li>
<li>==<strong>负载因子</strong>==：尺寸/容量。==空表的负载因子是0==，==而半满表的负载因子是0.5，以此类推==。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的(但是会减慢使用迭代器进行遍历的过程)。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量(桶位数),实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中(这被称为再散列)。<strong>HashMap</strong>使用的默认负载因子是==0.75==(只有当表达到3/4满时，才进行再散列)，这个因子在时间和空间代价之间达到了平衡。</li>
</ul>
</li>
<li>如果你知道将要在<strong>HashMap</strong>中存储多少项，那么==创建一个具有恰当大小的初始容量将可以避免自动在散列的开销==。</li>
</ul>
<h4 id="Collection或Map的同步控制"><a href="#Collection或Map的同步控制" class="headerlink" title="Collection或Map的同步控制"></a>Collection或Map的同步控制</h4><ul>
<li><p>Collections类有办法能够自动同步整个容器。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; tSet = Collections.synchronizedSet(<span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; mm = Collections.synchronizedMap(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面直接将新生成的容器传递给了适当的“同步”方法；这样做就不会有任何机会暴露出不同步的版本。</p>
</li>
</ul>
<h5 id="快速报错"><a href="#快速报错" class="headerlink" title="快速报错"></a>快速报错</h5><ul>
<li><p><strong>Java</strong>容器有一个==保护机制==，==能够防止多个进程同时修改同一个容器的内容。如果在你迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或者修改此容器内的某个对象==，那么就会出现问题。Java容器类类库采用==快速报错(<strong>fail-fast</strong>)机制==。它会探查容器上的任何除了你的进程所进行的操作外的所有变化，一旦它发现其它进程修改了容器，就会立即抛出==<strong>ConcurrentModificationException</strong>==异常。</p>
</li>
<li><p>“快速报错”机制的工作原理：只需要创建一个迭代器，然后向迭代器所指向的<strong>Collection</strong>添加点什么，如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFast</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        c.add(<span class="string">"An Object"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = it.next();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>程序运行时发生了异常，因为在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。此例中，应该在添加完所有的元素之后，再获取迭代器。</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>,<strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>都使用了可以避免<strong>ConcurrentModificationException</strong>的技术。</p>
</li>
</ul>
<h3 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h3><ul>
<li><strong>java.lang.ref</strong>类库包含了一组类，这些类为==垃圾回收提供了更大的灵活性==。==当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。==有三个继承自抽象类<strong>Reference</strong>的类：<strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>。当垃圾回收器正在考察的对象只能通过某个<strong>Reference</strong>对象才“==可获得==”时，上述这些不同的派生类==为垃圾回收器提供了不同级别的间接性指示==。</li>
<li>对象是可获得的(reachable)，是指此对象可在程序中的某处找到。这意味着你在栈中有一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对象含有另一个引用指向正在讨论的对象；也可能有更多的中间链接。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序将无法使用到它，所以将其回收是安全的。</li>
<li>如果想继续持有对某个对象的引用，希望后续还能够访问到该对象，但是也希望能够允许垃圾回收器释放它，这时就应该使用<strong>Reference</strong>对象。这样，你可以继续使用该对象，而在内存消耗殆尽的时候又允许释放该对象。</li>
<li>以<strong>Reference</strong>对象作为你和普通引用之间的媒介(代理)，另外，一定不能有普通的引用指向那个对象，这样就能达到上述目的。(普通的引用指没有经<strong>Reference</strong>对象包装过的引用)。如果垃圾回收器发现某个对象通过普通引用可获得的，该对象就不会被释放。</li>
<li><strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>由强到弱排列，对应不同的级别的“可获得性”。<strong>Softreference</strong>用以实现内存敏感的告诉缓存。<strong>WeakReference</strong>是为实现“规范映射”而设计的，它不妨碍垃圾回收器回收映射的“键”(或“值”)。“规范映射”中的实例可以在程序的多处被同时使用，以节省存储空间。<strong>PhantomReference</strong>用以调度回收前的清理工作，它比Java终止机制更灵活。</li>
<li>使用<strong>SoftReference</strong>和<strong>WeakReference</strong>时，可以选择是否要将它们放入<strong>ReferenceQueue</strong>(用作“回收前清理工作”的工具)。而<strong>PhantomReference</strong>只能依赖于<strong>ReferenceQueue</strong>。</li>
</ul>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><ul>
<li><p>容器类中有一种特殊的<strong>Map</strong>，即<strong>WeakHashMap</strong>,它被用来保存<strong>WeakReference</strong>。在这种映射中，每个值只保存一份实例以节省存储空间。当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它(而不是重新在创建)。映射可将值作为其初始化中的一部分，不过通常是在需要的时候才生成“值”。</p>
</li>
<li><p>==这是一种节约存储空间的技术，因为<strong>WeakHashMap</strong>允许垃圾回收器自动清理键和值。允许清理元素的触发条件是，不再需要此键了。==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        ident = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Element</span><br><span class="line">                &amp;&amp; ident.equals(((Element) o).ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span> + getClass().getSimpleName() + <span class="string">" "</span> + ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            Key[] keys = <span class="keyword">new</span> Key[size];</span><br><span class="line">            WeakHashMap&lt;Key,Value&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Key k = <span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">                Value v = <span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    keys[i] = k;</span><br><span class="line">                    map.put(k,v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行此程序，会看到垃圾回收器每隔三个键就跳过一个，因为指向那个键的普通引用被存入了<strong>keys</strong>数组，所以那些对象不能被垃圾回收器回收。</p>
</li>
</ul>
<h3 id="Java-1-0-1-1的容器"><a href="#Java-1-0-1-1的容器" class="headerlink" title="Java 1.0/1.1的容器"></a>Java 1.0/1.1的容器</h3><h4 id="Vector和Enumeration"><a href="#Vector和Enumeration" class="headerlink" title="Vector和Enumeration"></a>Vector和Enumeration</h4><ul>
<li>在<strong>Java 1.0/1.1</strong>中，<strong>Vector</strong>是==唯一可以自我扩展的序列==。基本上，可以将其看作是<strong>ArrayList</strong>。但是具有有长有难记的方法名，在订正过的<strong>Java</strong>容器类类库中，<strong>Vector</strong>被改造过，可将其归类为<strong>Collection</strong>和<strong>List</strong>。</li>
<li><strong>Java 1.0/1.1</strong>版的迭代器发明了一个新的名字—<strong>枚举</strong>，取代了为人熟知的术语(<strong>迭代</strong>器)。此<strong>Enumeration</strong>接口比<strong>Iterator</strong>小，只有两个名字很长的方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasMoreElements()</td>
<td>如果此枚举包含更多的元素，该方法就返回true</td>
</tr>
<tr>
<td>Object nextElement()</td>
<td>该方法返回此枚举中的下一个元素(如果还有的话)，否则抛出异常。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Enumeration</strong>只是接口而不是实现，所以有时新的类库仍然使用了旧的<strong>Enumeration</strong>。虽然在你的代码中应该尽量使用<strong>Iterator</strong>，但也得有准备，类库可能会返回给你一个<strong>Enumeration</strong>。</li>
</ul>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul>
<li><strong>Java 1.0/1.1</strong>的<strong>Stack</strong>很奇怪，竟然不是用<strong>Vector</strong>来构建<strong>Stack</strong>，而是继承<strong>Vector</strong>。所以它拥有<strong>Vector</strong>所有的特点和行为，再加上一些额外的<strong>Stack</strong>行为。(很难理解设计者是否意识到这样做特别有用处，或者只是一个幼稚的设计，但是你永远都不应该使用它)</li>
</ul>
<h4 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h4><ul>
<li>如果想要高效地存储大量“开/关”信息，<strong>BitSet</strong>是很好的选择。不过它的效率仅是对空间而言；如果想要高效的访问时间，<strong>BitSet</strong>比本地数组稍慢一点。</li>
<li><strong>BitSet</strong>的最小容量是<strong>long</strong>：<strong>64</strong>位。如果要存储的内容比较小，那么<strong>BitSet</strong>就浪费了一些空间。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/容器/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>容器</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第二章/">
      java编程思想第二章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/java编程思想/读书笔记/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java&nbsp;/&nbsp;java编程思想&nbsp;/&nbsp;读书笔记</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1 id="java编程思想总结"><a href="#java编程思想总结" class="headerlink" title="java编程思想总结"></a>java编程思想总结</h1><h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章:一切都是对象"></a>第二章:一切都是对象</h2><h3 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1. 用引用操作对象"></a>1. 用引用操作对象</h3><ul>
<li><h5 id="在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference"><a href="#在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference" class="headerlink" title="在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)"></a>在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)</h5></li>
<li><p>你拥有一个引用,并不一定需要一个对象与他关联.(String s;)</p>
</li>
</ul>
<h3 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2. 必须由你创建所有对象"></a>2. 必须由你创建所有对象</h3><ul>
<li>一旦创建一个引用,就希望他能与一个新的对象产生关联,通常用==new==来实现这一目的,new的意思是给我一个新对象</li>
</ul>
<h3 id="3-存储到什么地方"><a href="#3-存储到什么地方" class="headerlink" title="3.存储到什么地方"></a>3.存储到什么地方</h3><ul>
<li>寄存器:这是最快的存储区,位于不同于其他存储区的位置——-处理器内部,但是寄存器数量极其有限,所以寄存器根据需求进行分配,不能直接控制.</li>
<li>堆栈:位于通用RAM(随机访问存储器),通过堆栈指针可以从处理器哪里获得直接支持,堆栈指针若向下移动,则分配新内存,若向上移动,则释放哪些内存,这是一种快速有效的存储方式,仅次于寄存器,创建程序时,java必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针,java对象的引用存储在堆栈,但是java对象并不存储于其中.</li>
<li>堆:一种通用的内存池(位于ram区)用于存放java对象,不同于堆栈的好处是:编译器不需要知道存储的数据在堆里能存活多长时间,因此,在堆里分配存储有很大的灵活性,当我们在new一个对象的时候,会自动地在堆里进行存储分配,当然,为这种灵活性必须付出代价,用堆进行存储分配和清理可能会比用堆栈进行存储分配需要更多时间.</li>
<li>常量存储:常量值通常直接存放在程序代码内部,这样做是安全的,因为他们永远不会被改变.</li>
<li>非RAM存储:如果数据完全存活于程序之外,那么他可以不受程序的任何控制,在程序没有运行时也可以存在,两个最基本的例子就是”流对象”,”持久化对象”,在”流对象”中,对象转换成字节流,通常被发送给另一台机器,在”持久化对象”中,对象被存放在磁盘上.</li>
</ul>
<h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><ul>
<li><p>在程序中经常用到一系列类型,他们需要被特殊对待,可以把他们想象成”基本”类型,之所以被特殊对待,是因为==<strong>new将对象存储在”堆”里</strong>==,故用new创建一个对象,特别是小的简单的变量,不是很有效,对于这些类型,我们不用new来创建变量,而是创建一个并非是引用的”自动”变量,这个变量直接存储”值”并置放于堆栈中,效率更高.</p>
</li>
<li><p>java要确定每种基本类型所占存储空间的大小,他们的大小不像其他语言那样随机器硬件架构的变化而变化,正是这种原因使得java程序更具有可移植性.</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">大小</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
<th align="left">包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16 bit</td>
<td align="left">Unicode 0</td>
<td align="left">Unicode 0</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">8 bit</td>
<td align="left">-128</td>
<td align="left">127</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16 bit</td>
<td align="left">$-2^{15}$</td>
<td align="left">$2^{15}-1$</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">32 bit</td>
<td align="left">$-2^{31}$</td>
<td align="left">$2^{31}-1$</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64 bit</td>
<td align="left">$-2^{63}$</td>
<td align="left">$2^{63}-1$</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Void</td>
</tr>
</tbody></table>
</li>
<li><p>高精度数字</p>
<ul>
<li>java提供了用于高精度计算的类:<strong>BigInteger</strong>(整数)和<strong>BigDecimal</strong>(小数)(用于精确的货币计算)</li>
</ul>
</li>
</ul>
<h3 id="5-永远不需要销毁对象"><a href="#5-永远不需要销毁对象" class="headerlink" title="5.永远不需要销毁对象"></a>5.永远不需要销毁对象</h3><ul>
<li><p>作用域(scope)</p>
<ul>
<li>作用域决定了在其内部定义的变量名的可见性和生命周期,作用域由花括号的位置决定.</li>
</ul>
</li>
<li><p>对象的作用域</p>
<ul>
<li>java有一个垃圾回收器,用于监视用new创建的所有对象,并辨别那些不会在被引用的对象,随后,释放这些对象的内存空间,以便供其他新的对象使用.</li>
</ul>
</li>
<li><p>默认成员类型</p>
<ul>
<li><p>若类的某个成员是基本数据类型,即使没有初始化,java也会确保它获得一个默认值,前提必须是作为<strong>成员变量</strong>使用.</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>f</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’(null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常运行输出0</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果作为局部变量,会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2019/11/17/java编程思想第二章/1559358469727-1573995008036.png" alt="1559358469727"></p>
<h3 id="6-static"><a href="#6-static" class="headerlink" title="6.static"></a>6.static</h3><ol>
<li>优势<ul>
<li>只想为某特定域分配单一存储空间,而不去考虑究竟要创建多少对象,甚至根本不用创建对象.</li>
<li>希望某个方法不与包含他的类的任何对象关联在一起,也就是说,即使没有创建对象,也能够调用这个方法.</li>
</ul>
</li>
</ol>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/读书笔记/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>读书笔记</a>
        
          <a href="/tags/面向对象/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>面向对象</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java-java编程思想-读书笔记/" href="/categories/java-java编程思想-读书笔记/"><div class='name'>java - java编程思想 - 读书笔记</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(25)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/java/java编程思想/" href="/categories/java/java编程思想/"><div class='name'>java编程思想</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child" title="/categories/java/java编程思想/读书笔记/" href="/categories/java/java编程思想/读书笔记/"><div class='name'>读书笔记</div><div class='badge'>(10)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 22px; color: #636363">java编程思想</a> <a href="/tags/jvm/" style="font-size: 20px; color: #707070">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 18px; color: #7e7e7e">多线程</a> <a href="/tags/字符串/" style="font-size: 14px; color: #999">字符串</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/异常/" style="font-size: 14px; color: #999">异常</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/数组/" style="font-size: 14px; color: #999">数组</a> <a href="/tags/枚举/" style="font-size: 14px; color: #999">枚举</a> <a href="/tags/泛型/" style="font-size: 14px; color: #999">泛型</a> <a href="/tags/注解/" style="font-size: 14px; color: #999">注解</a> <a href="/tags/类型信息/" style="font-size: 14px; color: #999">类型信息</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16px; color: #8b8b8b">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="" target="_blank" class="codename">Hello World</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>





	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
