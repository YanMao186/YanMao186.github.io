<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Archives: 2019/11 | 编程是一门艺术</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="编程是一门艺术">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<style>
#canvas {
  position: fixed;
  right: 0px;
  bottom: 0px;
  min-width: 100%;
  min-height: 100%;
  height: auto;
  width: auto;
  z-index: -1;
}
</style>
<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <h1 class='title'>Hello World</h1>


<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/"
            
            
            id="home">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="https://github.com/YanMao186"
            
            
            id="https:github.comYanMao186">
            <i class='fab fa-github fa-fw'></i>&nbsp;github
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          编程是一门艺术
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                  id="home">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="https://github.com/YanMao186"
                
                
                id="https:github.comYanMao186">
								<i class='fab fa-github fa-fw'></i>&nbsp;github
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
	
		
  <section class="post-list">
    
      
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十八章/">
      java编程思想第十八章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h2><h3>对程序语言的设计者来说，创建一个好的输入/输出系统是一项艰难的任务</h3>

<ul>
<li><strong>Java 1.0</strong>版本以来，<strong>Java</strong>的<strong>I/O</strong>类库发生了明显的改变，在原来面向字节的类中添加了面向字符和基于<strong>Unicode</strong>的类。在<strong>JDK 1.4</strong>中，添加了<strong>nio</strong>类(对于“新<strong>I/O</strong>”来说，这是一个从现在起我们将要使用若干年的名称，即使它们在<strong>JDK 1.4</strong>中就已经被引入了，因此它们已经“旧”了)添加进来是为了改进性能及功能。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ul>
<li><strong>File</strong>(文件)类这个名字具有一定的误导性；我们可能会认为它指代的是文件，实际上却并非如此。==它既能代表一个特定文件的名称，有能代表一个目录下的一组文件的名称==。如果它指的是一个文件集，我们就可以对此集合调用<strong>list()</strong>方法，这个方法会返回一个字符数组。</li>
</ul>
<h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><ul>
<li><p>假设查看一个目录列表，可以用两种方法来使用<strong>File</strong>对象。如果调用不带参数的<strong>list()</strong>方法，便可以获得此<strong>File</strong>对象包含的全部列表。但是，如果我们想要获得一个受限列表，如：想得到所有拓展名为<strong>.java</strong>的文件，那么就需要使用“<strong>目录过滤器</strong>”，这个类会告诉我们怎么显示符合条件的<strong>File</strong>对象。</p>
</li>
<li><p>通过使用<strong>java.utils.sort()</strong>和<strong>String.CASE_INSENSITIVE.ORDERComparator</strong>，可以很容易的对结果进行排序(按字母顺序)</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            list = path.list();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list = path.list(<span class="keyword">new</span> DirFilter(args[<span class="number">0</span>]));</span><br><span class="line">            Arrays.sort(list,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String dirItem : list) &#123;</span><br><span class="line">            System.out.println(dirItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">            pattern = Pattern.compile(regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DirFilter</strong>这个类存在的唯一原因就是<strong>accept()</strong>方法。创建这个类的目的在于把<strong>accept()</strong>方法提供给<strong>list()</strong>使用，使<strong>list()</strong>可以回调<strong>accept()</strong>，进而以决定哪些文件包含在列表中。因此，这种结构也常常被称为==回调==。更具体的说，这是一个==策略模式==。==策略的目的就是提供了代码行为的灵活性==。</p>
</li>
<li><p><strong>accept()</strong>方法必须接受一个代表某个特定文件所在目录的<strong>File</strong>对象，以及包含那个文件的一个<strong>String</strong>。注意：==<strong>list()</strong>方法会为此目录对象下的每个文件名调用<strong>accept()</strong>,来判断该文件是否包含在内；判断结果由<strong>accept()</strong>返回的布尔值决定。==</p>
</li>
</ul>
<h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><ul>
<li><strong>File</strong>类不仅仅只代表存在的文件或目录。也可以用<strong>File</strong>对象来创建新的目录或尚不存在的整个目录路径。还可以查看文件的特性，检查某个<strong>File</strong>对象代表的是一个文件还是一个目录，并可以删除文件。</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li><strong>I/O</strong>库中常使用流这个抽象概念，它代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。“流”屏蔽了实际的<strong>I/O</strong>设备中处理数据的细节。</li>
<li><strong>Java</strong>类库中的<strong>I/O</strong>类分成==输入和输出==两部分。通过==继承==，任何自<strong>InputStream</strong>或<strong>Reader</strong>派生而来的类都含有名为<strong>read()</strong>的基本方法，==用于读取单个字节或者字节数组==。同样，任何自<strong>OutputStream</strong>或<strong>Writer</strong>派生而来的类都含有名为<strong>write()</strong>的基本方法，==用于写单个字节或者字节数组==。但是，我们通常不会用到这些方法，它们之所以存在是因为别的类可以使用它们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个流对象来提供所期望的功能(这是装饰器设计模式)。</li>
<li>实际上。<strong>Java</strong>中的“<strong>流</strong>”类库让人迷惑的主要原因就在于：==创建单一的结果流，却需要创建多个对象==。</li>
<li>在<strong>Java 1.0</strong>中，类库的设计者首先限定与<strong>输入</strong>有关的所有类都应该从<strong>InputStream</strong>继承,而<strong>输出</strong>有关的所有类都应该从<strong>OutputStream</strong>继承。</li>
</ul>
<h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul>
<li><strong>InputStream</strong>的作用是用来表示那些从不同数据源产生输入的类。包括：<ol>
<li>字节数组。</li>
<li><strong>String</strong>对象。</li>
<li>文件。</li>
<li>“管道”，工作方式与实际管道类似，即，从一端输入，从另一端输出。</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集和并到一个流内。</li>
<li>其他数据源，如<strong>Internet</strong>连接等。</li>
</ol>
</li>
<li>每一种数据源都有相应的<strong>InputStream</strong>子类。另外，<strong>FileInputStream</strong>也属于一种<strong>InputStream</strong>，为“装饰器”类提供基类。其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayInputStream</strong></td>
<td>允许将内存的缓冲区当作<strong>InputStrem</strong>使用</td>
<td>缓冲区，字节将从中取出<br>          作为一种数据源：将其与<strong>FileterInputStream</strong>对象相连以提供有用接口</td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong></td>
<td>将<strong>String</strong>转换为<strong>InputStream</strong></td>
<td>字符串。底层实现实际使用<strong>StringBuffer</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td>用于从文件中读取信息</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象1相连以提供有用接口</td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td>产生用于写入相关<strong>PipedOutputStream</strong>的数据。实现“管道化”概念</td>
<td><strong>PipedOutputStream</strong><br>          作为多线程中的数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
<td>将两个或多个<strong>InputStream</strong>对象转换成单一<strong>InputStream</strong></td>
<td>两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<strong>Enumeration</strong><br>          作为一种数据源：将其与<strong>FilterInputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterInputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中“装饰器”为其他类的<strong>InputStream</strong>类提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><ul>
<li>该类型的类决定了输出所要去往的目标：字节数组，文件或管道。</li>
<li><strong>FilterOutputStream</strong>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td>在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区。</td>
<td>缓冲区大小(可选的)<br>          用于指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td>用于将信息写至文件。</td>
<td>字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br>          指定数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td>任何写入其中的信息都会自动作为相关<strong>PipedInputStream</strong>的输出。实现“管道化”概念</td>
<td><strong>PipedInputStream</strong>          <br>指定用于多线程的数据的目的地：将其与<strong>FilterOutputStream</strong>对象相连以提供有用接口。</td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td>抽象类，作为“装饰器”的接口。其中，“装饰器”为其他<strong>OutputStream</strong>提供有用功能。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><ul>
<li><strong>Java I/O</strong>类库需要多种不同功能的组合，这正是使用装饰器模式的理由所在。这也是<strong>Java I/O</strong>类库里存在<strong>filter</strong>(过滤器)类的原因所在抽象类<strong>filter</strong>是所有装饰器的基类。</li>
<li>==装饰器必须具有和它所装饰的对象相同的接口==，但它也可以扩展接口，这种情况只发生在个别<strong>filter</strong>类中。</li>
<li>装饰器的==缺点==：在编写程序时，==增加了代码的复杂性==。<strong>Java I/O</strong>类库操作不便的原因在于：我们必须创建许多类—“核心” <strong>I/O</strong>类型加上所有的装饰器，才能得到我们所希望的单个<strong>I/O</strong>对象。</li>
<li><strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>是用来提供装饰器类接口以控制特定输入流(<strong>InputStream</strong>)和输出流(<strong>OutputStream</strong>)的两个类。<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>分别自<strong>I/O</strong>类库中的基类<strong>InputStream</strong>和<strong>OutputStream</strong>派生而来，这两个类是装饰器的必要条件。</li>
</ul>
<h4 id="通过FilterInputStream从InputStream读取数据"><a href="#通过FilterInputStream从InputStream读取数据" class="headerlink" title="通过FilterInputStream从InputStream读取数据"></a>通过FilterInputStream从InputStream读取数据</h4><ul>
<li><strong>FilterInputStream</strong>类能够完成两件完全不同的事情。<ol>
<li><strong>DataInputStream</strong>允许我们读取不同的基本类型数据以及<strong>String</strong>对象(所有的方法都以“<strong>read</strong>”开头，如：<strong>readByte()</strong>,<strong>readFloat()</strong>等等)。搭配相应的<strong>DataOutputStream</strong>,就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方。</li>
<li>其他<strong>FilterInputStream</strong>类则在内部修改<strong>InputStream</strong>的行为方式：是否缓冲，是否保留它所读过的行，以及是否把单一字符推回输入流等等。</li>
</ol>
</li>
<li>我们几乎每次都要对输入进行缓冲—–不管我们正在连接的是什么<strong>I/O</strong>设备，所以，<strong>I/O</strong>类库把无缓冲输入(而不是缓冲输入)作为特殊情况(或只是方法调用)就显得更加合理了。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataInputStream</strong></td>
<td>与<strong>DataOutputStream</strong>搭配使用，因此我们可以按照可移植方式从流读取基本数据类型(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)。</td>
<td><strong>InputStream</strong><br>包含用于读取基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td>使用它可以防止每次读取时都得进行实际写操作。代表“使用缓冲区”。</td>
<td><strong>InputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong></td>
<td>跟踪输入流中的行号；可调用<strong>getLineNumber()</strong>和<strong>setLineNumber(int)</strong>。</td>
<td><strong>InputStream</strong><br>仅增加了行号，因此可能要与接口对象搭配使用。</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td>具有“能弹出一个字节的缓冲区”。因此可以将读到的最后一个字符回退。</td>
<td><strong>InputStream</strong><br>通常作为编译器的扫面器，之所以包含在内是因为Java编译器的需要，我们可能永远不会用到。</td>
</tr>
</tbody></table>
<h4 id="通过FilterOutPutStream向OutputStream写入"><a href="#通过FilterOutPutStream向OutputStream写入" class="headerlink" title="通过FilterOutPutStream向OutputStream写入"></a>通过FilterOutPutStream向OutputStream写入</h4><ul>
<li>与<strong>DataInputStream</strong>对应的是<strong>DataOutputStream</strong>，它可以将各种<strong>基本数据类型</strong>以及<strong>String</strong>对象格式化输出到“流”中；这样，任何设备上的任何<strong>DataInputStream</strong>都能够读取它们。所有的方法都以”<strong>wirte</strong>“开头，如<strong>writeByte()</strong>,<strong>writeFloat()</strong>等等。</li>
<li><strong>PrintStream</strong>最初目的便是为了以可视化格式打印所有的<strong>基本数据类型</strong>以及<strong>String</strong>对象。这和<strong>DataOutputStream</strong>不同，后者的目的是将数据元素置入“流”中，使<strong>DataInputStream</strong>能够可移植地重构它们。</li>
<li><strong>PrintStream</strong>可能会有些问题，因为它捕捉了所有的<strong>IOException</strong>(因此，我们必需使用<strong>checkError()</strong>自行测试错误状态，如果出现错误它返回<strong>true</strong>)。另外，<strong>PrintStream</strong>也未完全国际化，不能以平台无关地方式处理换行动作(这些问题在<strong>printWriter</strong>中得到了解决)。</li>
<li><strong>BufferedOutputStream</strong>是一个修改过的<strong>OutputStream</strong>，<strong>它对数据流使用缓冲技术</strong>；因此当每次向流写入时，不必每次都进行实际的物理写操作。</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构造器参数/如何使用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
<td>与<strong>DataInputStream</strong>搭配使用，因此可以按照可移植方式向流中写入基本类型数据(<strong>int</strong>,<strong>char</strong>,<strong>long</strong>等)</td>
<td><strong>OutputStream</strong><br>包含用于写入基本类型数据的全部接口。</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td>用于产生格式化输出。其中<strong>DataOutputStream</strong>处理数据的存储，<strong>PrintStream</strong>处理显示。</td>
<td><strong>OutputStream</strong>,可以用<strong>boolean</strong>值指示是否在每次换行时清空缓冲区(可选的)应该是对<strong>OutputStream</strong>对象的“<strong>final</strong>”封装。</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td>使用它以避免每次发送数据时都要进行实际的写操作。代表“使用缓冲区”。可以调用<strong>flush()</strong>清空缓冲区。</td>
<td><strong>OutputStream</strong>，可以指定缓冲区大小(可选的)<br>本质上并不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配。</td>
</tr>
</tbody></table>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul>
<li><strong>Java 1.1</strong>对基本的<strong>I/O</strong>流类库进行了重大的修改。<strong>InputStream</strong>和<strong>OutputStream</strong>在以面向==字节==形式的<strong>I/O</strong>中提供极有价值的功能，<strong>Reader</strong>和<strong>Writer</strong>则提供兼容<strong>Unicode</strong>与面向==字符==的<strong>I/O</strong>功能。</li>
<li>有时我们必须把来自“<strong>字节</strong>”层次结构中的类和“<strong>字符</strong>”层次结构中的类结合起来使用。为了实现这个目的，要用到”<strong>适配器</strong>“(adapter)类：<strong>InputStreamReader</strong>可以把<strong>InputStream</strong>转换为<strong>Reader</strong>，而<strong>OutputStreamWriter</strong>可以把<strong>OutputStream</strong>转换为<strong>Writer</strong>。</li>
<li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化。老的<strong>I/O</strong>流继承层次结构仅支持<strong>8位字节流</strong>，并且不能很好地处理<strong>16位的Unicode字符</strong>。由于<strong>Unicode</strong>用于<strong>字符国际化</strong>(<strong>Java</strong>本身的<strong>char</strong>也是16位的<strong>Unicode</strong>)，所以添加<strong>Reader</strong>和<strong>Writer</strong>继承层次结构就是为了在所有的<strong>I/O</strong>操作中都支持<strong>Unicode</strong>。</li>
</ul>
<h4 id="数据的来源和去处"><a href="#数据的来源和去处" class="headerlink" title="数据的来源和去处"></a>数据的来源和去处</h4><ul>
<li>在某些场合中，==面向字节==的<strong>InputStream</strong>和<strong>OutputStream</strong>才是正确的解决方案；特别是，<strong>java.util.zip</strong>类库就是==面向字节的而不是面向字符==的。因此，最明智的做法就是尽量尝试使用<strong>Reader</strong>和<strong>Writer</strong>，一旦程序代码无法成功编译，我们就会发现自己==不得不使用面向字节==的类库。</li>
<li>下面展示了在两个继承层次结构中，信息的来源和去处(即数据物理上来自哪里及去向哪里)之间的关系：</li>
</ul>
<table>
<thead>
<tr>
<th>来源与去处：Java 1.0类</th>
<th>相应的Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InputStream</strong></td>
<td><strong>Reader</strong><br>适配器：<strong>InputStreamReader</strong></td>
</tr>
<tr>
<td><strong>OutputStream</strong></td>
<td><strong>Writer</strong><br>适配器：<strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td><strong>FileInputStream</strong></td>
<td><strong>FileReader</strong></td>
</tr>
<tr>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileWriter</strong></td>
</tr>
<tr>
<td><strong>StringBufferInputStream</strong>(已弃用)</td>
<td><strong>StringReader</strong></td>
</tr>
<tr>
<td>无</td>
<td><strong>StringWriter</strong></td>
</tr>
<tr>
<td><strong>ByteArrayInputStream</strong></td>
<td><strong>CharArrayReader</strong></td>
</tr>
<tr>
<td><strong>ByteArrayOutputStream</strong></td>
<td><strong>CharArrayWriter</strong></td>
</tr>
<tr>
<td><strong>PipedInputStream</strong></td>
<td><strong>PipedReader</strong></td>
</tr>
<tr>
<td><strong>PipedOutputStream</strong></td>
<td><strong>PipedWriter</strong></td>
</tr>
</tbody></table>
<h4 id="更改流的行为"><a href="#更改流的行为" class="headerlink" title="更改流的行为"></a>更改流的行为</h4><ul>
<li>对于<strong>InputStream</strong>和<strong>OutputStream</strong>来说，我们会使用<strong>FilterInputStream</strong>和<strong>FilterOutputStream</strong>的装饰器子类来修改“<strong>流</strong>”以满足特殊需要。<strong>Reader</strong>和<strong>Writer</strong>的类继承层次结构继续沿用相同的思想，但是并不完全相同。</li>
</ul>
<table>
<thead>
<tr>
<th>过滤器 Java 1.0类</th>
<th>相应的 Java 1.1类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FilterInputStream</strong></td>
<td><strong>FilterReader</strong></td>
</tr>
<tr>
<td><strong>FilterOutputStream</strong></td>
<td><strong>FilterWriter</strong>(抽象类，没有子类)</td>
</tr>
<tr>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedReader</strong>(也有<strong>readLine()</strong>)</td>
</tr>
<tr>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td><strong>DataInputStream</strong></td>
<td>使用<strong>DataInputStream</strong>(除了当需要使用<strong>readLine()</strong>时以外，这时应该使用<strong>BufferedReader</strong>)</td>
</tr>
<tr>
<td><strong>PrintStream</strong></td>
<td><strong>PrintWriter</strong></td>
</tr>
<tr>
<td><strong>LineNumberInputStream</strong>(已弃用)</td>
<td><strong>LineNumberReader</strong></td>
</tr>
<tr>
<td><strong>StreamTokenizer</strong></td>
<td><strong>StreamTokenizer</strong>(使用接受<strong>Reader</strong>的构造器)</td>
</tr>
<tr>
<td><strong>PushbackInputStream</strong></td>
<td><strong>PushbackReader</strong></td>
</tr>
</tbody></table>
<ul>
<li>无论我们何时使用<strong>readLine()</strong>,都不应该使用<strong>DataInputStream</strong>(这会遭到编译器的强烈反对)，而应该使用<strong>BufferedReader</strong>。除这一点，<strong>DataInputStream</strong>仍然是<strong>I/O</strong>类库的首选。</li>
<li><strong>PrintWriter</strong>提供了一个既能接受<strong>Writer</strong>对象又能接受任何<strong>OutputStream</strong>对象的构造器。<strong>PrintWriter</strong>的格式化接口实际上与<strong>PrintStream</strong>相同。</li>
<li>有一种<strong>PrintWriter</strong>构造器还有一个选项，就是“<strong>自动执行清空</strong>”选项。如果构造器设置此选项，则每个<strong>Println()</strong>执行之后，便会自动清空。</li>
</ul>
<h4 id="未发生变化的类"><a href="#未发生变化的类" class="headerlink" title="未发生变化的类"></a>未发生变化的类</h4><table>
<thead>
<tr>
<th>以下这些Java 1.0类在Java 1.1中没有相应类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DataOutputStream</strong></td>
</tr>
<tr>
<td><strong>File</strong></td>
</tr>
<tr>
<td><strong>RandomAccessFile</strong></td>
</tr>
<tr>
<td><strong>SequenceInputStream</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>DataOutputStream</strong>，在使用时没有任何变化；因此如果想以“可传输的”格式存储和检索数据，可以使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构。</li>
</ul>
<h3 id="自我独立的类：RandomAccessFile"><a href="#自我独立的类：RandomAccessFile" class="headerlink" title="自我独立的类：RandomAccessFile"></a>自我独立的类：RandomAccessFile</h3><ul>
<li><strong>RandomAccessFile</strong>适用于由大小已知的记录组成的文件，所以我们可以使用<strong>seek()</strong>将记录从一处转移到另一处，然后读取或者修改记录。</li>
<li>除了实现了<strong>DataInput</strong>和<strong>DataOutput</strong>接口之外，它和这两个继承层次结构没有任何关联。甚至不适用<strong>InputStream</strong>和<strong>OutputStream</strong>类中已有的任何功能。它是一个完全独立的类，这么做是因为<strong>RandomAccessFile</strong>拥有和别的<strong>I/O</strong>类型本质不同的行为，因为我们可以在一个文件内向前和向后移动。</li>
<li>只有RandomAccessFile支持搜寻方法，并且只适用于文件。</li>
</ul>
<h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I/O流的典型使用方式"></a>I/O流的典型使用方式</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul>
<li><p>如果想要打开一个文件用于字符输入，可以使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputReader</strong>。为了提高速度，我们希望对那个文件进行缓冲，那么将所产生的引用传给一个<strong>BufferedReader</strong>构造器。由于<strong>BufferedReader</strong>也提供了<strong>readLine()</strong>方法，所以这是我们的最终对象和进行读取的接口。当<strong>readLine()</strong>将返回<strong>null</strong>时，你就达到了文件的末尾。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line">            in.close();</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串<strong>sb</strong>用来累计文件的全部内容(包括必须添加的换行符，因为<strong>readLine()</strong>已将它们删掉)。最后，调用<strong>close()</strong>关闭文件。</p>
</li>
</ul>
<h4 id="从内存输入"><a href="#从内存输入" class="headerlink" title="从内存输入"></a>从内存输入</h4><ul>
<li><p>下面，从<strong>BufferedInputFile.read()</strong>读入的<strong>String</strong>结果被用来创建一个<strong>StringReader</strong>。然后调用<strong>read()</strong>每次读取一个字符，并把它发送到控制台。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StringReader sr = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = sr.read())!= -<span class="number">1</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>read()</strong>是以<strong>int</strong>形式返回下一字节，因此必须类型转型为<strong>char</strong>才能正确打印。</p>
</li>
</ul>
<h4 id="格式化的内存输入"><a href="#格式化的内存输入" class="headerlink" title="格式化的内存输入"></a>格式化的内存输入</h4><ul>
<li><p>要读取格式化数据，可以使用<strong>DataInputStream</strong>,它是一个面向字节的<strong>I/O</strong>类(不是面向字符的)。因此我们必须使用<strong>InputStream</strong>类而不是<strong>Reader</strong>类。当然，可以用<strong>InputStream</strong>以字节的形式读取任何数据(如一个文件)，不过，这里使用的是字符串。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile</span><br><span class="line">                                    .read(<span class="string">"D://HelloWorld.java"</span>)</span><br><span class="line">                                    .getBytes()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)in.readByte());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>必须为<strong>ByteArrayInputStream</strong>提供字节数组，为了产生该数组<strong>String</strong>包含了一个可以实现此项工作的<strong>getBytes()</strong>方法。所产生的<strong>ByteArrayInputStream</strong>是一个适合传递给<strong>DataInputStream</strong>的<strong>InputStream</strong>。</p>
</li>
<li><p>如果我们从<strong>DataInputStream</strong>用<strong>readByte()</strong>一次一个字节读取字符，那么任何字节的值都是合法的结果，因此返回值不能用来检测输入是否结束。相反，我们可以使用<strong>available()</strong>方法查看还有多少可供存储的字符。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesrEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (in.available() != <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul>
<li><p>FileWriter对象可以向文件写入数据。创建一个与指定文件连接的FileWriter。实际上，我们通常会用BufferedWriter将其包装起来用以缓冲输出(尝试移除此包装来感受对性能的影响——缓冲往往能显著地增加I/O操作地性能)。下面，为了提供格式化机制，它被装饰成了PrintWriter。按照这种方式创建的数据文件可作为普通文本文件读取。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://HelloWorld.out"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(</span><br><span class="line">                        BufferedInputFile.read(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(</span><br><span class="line">                <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            out.println(lineCount++ + <span class="string">": "</span> + s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1: public class HelloWorld &#123;</span></span><br><span class="line"><span class="comment">2: 	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">3: 	System.out.println("Hello World");</span></span><br><span class="line"><span class="comment">4: 	&#125;</span></span><br><span class="line"><span class="comment">5: &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦读完输入数据流，<strong>readLine()</strong>会返回<strong>null</strong>。我们可以看到要为<strong>out</strong>显示调用<strong>close()</strong>。如果我们不为所有的输出文件调用<strong>close()</strong>,就会发现缓冲区内容不会被刷新清空，那么它们就不完整。</p>
</li>
</ul>
<h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><ul>
<li><p><strong>PrintWriter</strong>可以对数据进行格式化，以便人们阅读。但是为了输出可供另一个“流”恢复的数据，我们需要用<strong>DataOutputStream</strong>写入数据，并用<strong>DataInputStream</strong>恢复数据。当然，这些流可以是任意形式。注意：<strong>DataOutputStream</strong>和<strong>DataInputStream</strong>是==面向字节==的，因此要使用<strong>InputStream</strong>和<strong>OutputStream</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        out.writeDouble(<span class="number">3.1415926</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That was pi"</span>);</span><br><span class="line">        out.writeDouble(<span class="number">1.41413</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"Square root of 2"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>)));</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.1415926</span></span><br><span class="line"><span class="comment">That was pi</span></span><br><span class="line"><span class="comment">1.41413</span></span><br><span class="line"><span class="comment">Square root of 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>DataOutputStream</strong>写入数据，<strong>Java</strong>保证我们可以使用<strong>DataInputStream</strong>准确地读取数据—无论读和写数据的平台多么不同。</p>
</li>
<li><p>当使用<strong>DataOutputStream</strong>时，写字符串并且让<strong>DataInputStream</strong>能够恢复它的==唯一可靠==的做法就是使用<strong>UTF-8</strong>编码，在示例中是用<strong>writeUTF()</strong>和<strong>readUTF()</strong>实现的。</p>
</li>
<li><p><strong>writeDouble()</strong>将<strong>double</strong>类型的数字存储到流中，并用相应的<strong>readDouble()</strong>恢复它(对于其他的数据类型，也有类似方法用于读写)。</p>
</li>
</ul>
<h4 id="读写随机访问文件"><a href="#读写随机访问文件" class="headerlink" title="读写随机访问文件"></a>读写随机访问文件</h4><ul>
<li><p>使用<strong>RandomAccessFile</strong>，类似于组合使用了<strong>DataInputStream</strong>和<strong>DataOutputStream</strong>(因为它实现了相同的接口：<strong>DataInput</strong>和<strong>DataOutput</strong>)。另外，利用<strong>seek()</strong>可以在文件中到处移动，并修改文件中的某个值。</p>
</li>
<li><p>使用<strong>RandomAccessFile</strong>时，你必须知道文件排版，这样才能正确使用它。<strong>RandomAccessFile</strong>拥有读取基本类型和<strong>UTF-8</strong>字符串的各种方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"D://rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            System.out.println(<span class="string">"Value"</span>+i+<span class="string">" "</span>+rf.readDouble());</span><br><span class="line">            System.out.println(rf.readUTF());</span><br><span class="line">            rf.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">            rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line">            rf = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">"rw"</span>);</span><br><span class="line">            rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">            rf.writeDouble(<span class="number">47.001</span>);</span><br><span class="line">            rf.close();</span><br><span class="line">            display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 7.069999999999999</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">Value0 0.0</span></span><br><span class="line"><span class="comment">Value1 1.414</span></span><br><span class="line"><span class="comment">Value2 2.828</span></span><br><span class="line"><span class="comment">Value3 4.242</span></span><br><span class="line"><span class="comment">Value4 5.656</span></span><br><span class="line"><span class="comment">Value5 47.001</span></span><br><span class="line"><span class="comment">Value6 8.484</span></span><br><span class="line"><span class="comment">The end of the file</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>display()</strong>方法打开了一个文件，并以<strong>double</strong>值的形式显示了其中的七个元素。在<strong>main()</strong>中，首先创建了文件，然后打开并修改它。因为<strong>double</strong>总是8字节长，所以为了用<strong>seek()</strong>查找第5个双精度值，你只需用5*8来产生查找位置。</p>
</li>
</ul>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul>
<li>程序的<strong>所有输入</strong>都可以来自于<strong>标准输入</strong>，它的<strong>所有输出</strong>也都可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送到<strong>标准错误</strong>。<strong>标准I/O</strong>的意义在于：我们可以很容易地把程序串联起来，一个程序的<strong>标准输出</strong>可以成为另一个程序的<strong>标准输入</strong>。</li>
</ul>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul>
<li><p>按照标准<strong>I/O</strong>模型，<strong>Java</strong>提供了<strong>System.in</strong>,<strong>System.out</strong>,<strong>System.err</strong>。其中<strong>System.out</strong>已经事先被包装成了<strong>printStream</strong>对象。<strong>System.err</strong>同样也是<strong>PrintStream</strong>，但是<strong>System.in</strong>却是一个没有被包装过的未经加工的<strong>InputStream</strong>。这意味着尽管我们可以立即使用<strong>System.out</strong>和<strong>System.err</strong>，但是在读取<strong>System.in</strong>之前必须对其进行包装。</p>
</li>
<li><p>通常我们会用<strong>readLine()</strong>一次一行地读取输入，我们可以将<strong>System.in</strong>包装成<strong>BufferedReader</strong>来使用这要求我们必须用<strong>InputStreamReader</strong>把<strong>System.in</strong>转换成<strong>Reader</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length() != <span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><ul>
<li><p><strong>System.out</strong>是一个<strong>PrintStream</strong>，而<strong>PrintStream</strong>是一个<strong>OutputStream</strong>。<strong>PrintWriter</strong>有一个可以接受<strong>OutputStream</strong>作为参数的构造器。所以，只要需要，就可以使用那个构造器把<strong>System.out</strong>转换成<strong>PrintWriter</strong>。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Hello World</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将第二个参数设为<strong>true</strong>，以便开启自动清空功能；否则，有可能看不到输出。</p>
</li>
</ul>
<h4 id="标准I-O重定向"><a href="#标准I-O重定向" class="headerlink" title="标准I/O重定向"></a>标准I/O重定向</h4><ul>
<li><p><strong>System</strong>类提供了一些简单的静态方法调用，以允许我们对标准输入，输出和错误<strong>I/O</strong>流进行<strong>重定向</strong>：</p>
<ul>
<li><strong>setIn(InputStream)</strong></li>
<li><strong>setOut(PrintStream)</strong></li>
<li><strong>setErr(PrintStream)</strong></li>
</ul>
</li>
<li><p>如果我们突然开始在显示器上创建大量输出，而这些输出滚动的太快以至于无法阅读时，重定向输出就显得极为有用。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redirecting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream console = System.out;</span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"D://HelloWorld.java"</span>));</span><br><span class="line">        PrintStream out = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"D://test.txt"</span>)));</span><br><span class="line">        System.setIn(in);</span><br><span class="line">        System.setOut(out);</span><br><span class="line">        System.setErr(out);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(console);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>I/O</strong>重定向操纵的是<strong>字节流</strong>，而不是字符流；因此我们使用的是<strong>InputStream</strong>和<strong>OutputStream</strong>，而不是<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
</ul>
<h3 id="新I-O"><a href="#新I-O" class="headerlink" title="新I/O"></a>新I/O</h3><ul>
<li><p><strong>JDK 1.4</strong>的<strong>java.nio.*</strong>包中引入了新的<strong>Java I/O</strong>类库，其目的在于<strong>提高速度</strong>。速度的提高在<strong>文件I/O</strong>和<strong>网络I/O</strong>中都有可能发生。</p>
</li>
<li><p>速度的提高来自所使用的结构更接近于操作系统执行<strong>I/O</strong>的方式：<strong>通道和缓冲器</strong>。</p>
</li>
<li><p>唯一直接与通道交互的缓冲器是<strong>ByteBuffer</strong>—也就是说，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<strong>ByteBuffer</strong>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这种处理虽然很低级，但却正好，因为这是大多数操作系统中更有效的映射方式。</p>
</li>
<li><p>旧<strong>I/O</strong>类库中有三个类被修改了，用以产生<strong>FileChannel</strong>。分别是<strong>FileInputStream</strong>,<strong>FileOutputStream</strong>以及用于<strong>既读又写</strong>的<strong>RandomAccessFile</strong>。注意这些是<strong>字节操作流</strong>，与低层的<strong>nio</strong>性质一致。<strong>Reader</strong>和<strong>Writer</strong>这种<strong>字符模式类</strong>不能用于产生通道；但是<strong>java.nio.channels.Channels</strong>类提供了实用方法，用以在通道中产生<strong>Reader</strong>和<strong>Writer</strong>。</p>
</li>
<li><p>下面演示上面的三种类型的流，用于产生<strong>可写</strong>的，<strong>可读可写</strong>的及<strong>可读</strong>的通道。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some text "</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> RandomAccessFile(<span class="string">"D://data.txt"</span>,<span class="string">"rw"</span>).getChannel();</span><br><span class="line">        fc.position(fc.size());</span><br><span class="line">        fc.write(ByteBuffer.wrap(<span class="string">"Some more"</span>.getBytes()));</span><br><span class="line">        fc.close();</span><br><span class="line">        fc = <span class="keyword">new</span> FileInputStream(<span class="string">"D://data.txt"</span>).getChannel();</span><br><span class="line">        ByteBuffer buff = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        fc.read(buff);</span><br><span class="line">        buff.flip();</span><br><span class="line">        <span class="keyword">while</span> (buff.hasRemaining())</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)buff.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Some text Some more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getChannel()</strong>将会产生一个<strong>FileChannel</strong>。通道是一种相当基础的东西：可以向它传送用于读写的<strong>ByteBuffer</strong>，并且可以锁定文件的某些区域用于独占式访问。</p>
</li>
<li><p>将字节存放于<strong>ByteBufferr</strong>的方法之一是：使用一种“<strong>put</strong>”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<strong>warp()</strong>方法将已存在的字节数组“包装”到<strong>ByteBuffer</strong>中。一旦如此，就不再复制底层的数组，而是把它作为所产生的<strong>ByteBuffer</strong>的存储器，我们称之为数组支持的<strong>ByteBuffer</strong>。</p>
</li>
<li><p>对于只读访问，我们必须显式地使用静态的<strong>allocate()</strong>方法来分配<strong>ByteBuffer</strong>。<strong>nio</strong>的目标就是快速移动大量数据，因此<strong>ByteBuffer</strong>的大小就显得尤为重要。</p>
</li>
<li><p>甚至达到更高的速度也有可能，方法就是使用<strong>allocateDirect()</strong>而不是<strong>allocate()</strong>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大。</p>
</li>
<li><p>一旦调用<strong>read()</strong>来告知<strong>FileChannel</strong>向<strong>ByteBuffer</strong>存储字节，就必须调用缓冲器上的<strong>fip()</strong>，让它做好让别人读取字节的准备。</p>
</li>
<li><p>如果打算使用缓冲器执行进一步的<strong>read()</strong>操作，我们也必须得调用<strong>clear()</strong>来为每个<strong>read()</strong>做好准备。如下面这个简单文件复制程序。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">while</span> (in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            out.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看到，打开一个<strong>FileChannel</strong>用于读，而打开另一个以用于写。<strong>ByteBuffer</strong>被分配了空间，当<strong>FileChannel.read()</strong>返回<strong>-1</strong>时，表示我们已经到达了输入的末尾。每次<strong>read()</strong>操作之后，就会将数据输入到缓冲器中，<strong>filp()</strong>则是准备缓冲器以便它的信息可以由<strong>write()</strong>提取。<strong>write()</strong>操作之后，信息仍在缓冲器中，接着<strong>clear()</strong>操作则对所有的内部指针重新排序，以便缓冲器在另一个<strong>read()</strong>操作期间能够做好接受数据的准备。</p>
</li>
<li><p>上面的程序并不是处理此类操作的理想方式，特殊方法<strong>transferTo()</strong>和<strong>transferFrom()</strong>允许我们将一个通道和另一个通道直接相连。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FileChannel</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">        in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arguments: sourcefile destfile</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取基本类型"><a href="#获取基本类型" class="headerlink" title="获取基本类型"></a>获取基本类型</h3><ul>
<li><p>尽管ByteBuffer只能保留字节类型的数据，但是它具有可以从其他所容纳的字节中产生出各种不同基本类型值的方法。如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; bb.limit())</span><br><span class="line">            <span class="keyword">if</span> (bb.get() != <span class="number">0</span>)</span><br><span class="line">                System.out.print(<span class="string">"nonzero"</span>);</span><br><span class="line">        System.out.print(<span class="string">"i ="</span>+i);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asCharBuffer().put(<span class="string">"Howdy!"</span>);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = bb.getChar())!= <span class="number">0</span>)</span><br><span class="line">            System.out.print(c+<span class="string">" "</span>+<span class="string">"\b"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asShortBuffer().put((<span class="keyword">short</span>)<span class="number">471142</span>);</span><br><span class="line">        System.out.println(bb.getShort());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asIntBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getInt());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asLongBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getLong());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asFloatBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getFloat());</span><br><span class="line">        bb.rewind();</span><br><span class="line">        bb.asDoubleBuffer().put(<span class="number">99471142</span>);</span><br><span class="line">        System.out.println(bb.getDouble());</span><br><span class="line">        bb.rewind();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i =1025Howdy!</span></span><br><span class="line"><span class="comment">12390</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">99471142</span></span><br><span class="line"><span class="comment">9.9471144E7</span></span><br><span class="line"><span class="comment">9.9471142E7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在分配一个<strong>ByteBuffer</strong>之后，可以通过检测它的值来查看缓冲器的分配方式是否将其内容自动置零，它的确是这样做的。这里一共检测了<strong>1024</strong>个值(由缓冲器的<strong>limit()</strong>决定)，并且所有的值都是<strong>0</strong>。</p>
</li>
<li><p>向<strong>ByteBuffer</strong>插入基本类型数据的最简单方式是：利用<strong>asCharBuffer(),asShortBuffer()</strong>等获得该缓冲器上的视图，然后使用视图的<strong>put()</strong>方法，使用<strong>ShortBuffer</strong>的<strong>put()</strong>方法时，需要进行类型转换。</p>
</li>
</ul>
<h4 id="视图缓冲器"><a href="#视图缓冲器" class="headerlink" title="视图缓冲器"></a>视图缓冲器</h4><ul>
<li><p>视图缓冲器(view buffer)可以让我们通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong>。<strong>ByteBuffer</strong>依然是实际存储数据的地方，“支持”着前面的视图。因此，对视图的修改都会映射成为对<strong>ByteBuffer</strong>中数据的修改。这使得我们可以很方便地向<strong>ByteBuffer</strong>插入数据。视图还允许我们从<strong>ByteBuffer</strong>一次一个地或者成批的读取基本类型值。下面，通过<strong>IntBuffer</strong>操纵<strong>ByteBuffer</strong>中的<strong>int</strong>型数值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuffer bb = ByteBuffer.allocate(BSIZE);</span><br><span class="line">        IntBuffer ib = bb.asIntBuffer();</span><br><span class="line">        ib.put(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">54</span>,<span class="number">65</span>,<span class="number">888</span>,<span class="number">345</span>,<span class="number">3456</span>&#125;);</span><br><span class="line">        System.out.println(ib.get(<span class="number">3</span>));</span><br><span class="line">        ib.put(<span class="number">3</span>,<span class="number">1811</span>);</span><br><span class="line">        ib.flip();</span><br><span class="line">        <span class="keyword">while</span> (ib.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ib.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">65</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">33</span></span><br><span class="line"><span class="comment">54</span></span><br><span class="line"><span class="comment">1811</span></span><br><span class="line"><span class="comment">888</span></span><br><span class="line"><span class="comment">345</span></span><br><span class="line"><span class="comment">3456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先用重载后的<strong>put()</strong>方法存储一个整数数组。接着<strong>get()</strong>和<strong>put()</strong>方法调用直接访问底层<strong>ByteBuffer</strong>中的某个整数位置。</p>
</li>
<li><p>一旦底层的<strong>ByteBuffer</strong>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写到通道中了。然后使用视图缓冲器可以把任何数据都转换成某一特定的基本类型。</p>
</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li><p>Java I/O类库中的类支持读写压缩格式的数据流，这些类不是从Reader和Writer类派生而来的，而是属于InputStream和OutputStream继承层次结构的一部分。这是因为压缩类库是按字节方式而不是字符方式处理的。</p>
<table>
<thead>
<tr>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CheckedInputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>InputStream</strong>产生校验和(不仅是解压缩)</td>
</tr>
<tr>
<td><strong>CheckedOutputStream</strong></td>
<td><strong>GetCheckSum()</strong>为任何<strong>OutputStream</strong>产生校验和(不仅是压缩)</td>
</tr>
<tr>
<td><strong>DeflaterOutputStream</strong></td>
<td>压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipOutputStream</strong></td>
<td>一个<strong>DeflaterOutputStream</strong>，用于将数据压缩成Zip文件格式</td>
</tr>
<tr>
<td><strong>GZIPOutputStream</strong></td>
<td>一个个<strong>DeflaterOutputStream</strong>，用于将数据压缩成GZIP文件格式</td>
</tr>
<tr>
<td><strong>InflaterInputStream</strong></td>
<td>解压缩类的基类</td>
</tr>
<tr>
<td><strong>ZipInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩Zip文件格式的数据</td>
</tr>
<tr>
<td><strong>GZIPInputStream</strong></td>
<td>一个<strong>InflaterInputStream</strong>,用于解压缩GZIP文件格式的数据</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="用GZIP进行简单压缩"><a href="#用GZIP进行简单压缩" class="headerlink" title="用GZIP进行简单压缩"></a>用GZIP进行简单压缩</h4><ul>
<li><p>如果对单个数据流进行压缩，<strong>GZIP</strong>可能是一个比较适合的选择。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPcompress</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: \nGZIPcompress file\n"</span>+</span><br><span class="line">                    <span class="string">"\tUses GZIP comression to compress"</span> + <span class="string">"the file to test.gz"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"E://test.gz"</span>)));</span><br><span class="line">        System.out.println(<span class="string">"Writing file"</span>);</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = in.read())!= -<span class="number">1</span>)</span><br><span class="line">            out.write(c);</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(<span class="string">"Reading file"</span>);</span><br><span class="line">        BufferedReader in2 = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> GZIPInputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileInputStream(<span class="string">"D://test.gz"</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = in2.readLine())!= <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接将输出流封装成<strong>GZIPOutputStream</strong>或<strong>ZipOutputStream</strong>，并将输入流封装成<strong>GZIPInputStream</strong>或<strong>ZipInputStream</strong>即可。</p>
</li>
</ul>
<h4 id="Java档案文件"><a href="#Java档案文件" class="headerlink" title="Java档案文件"></a>Java档案文件</h4><ul>
<li><p><strong>Zip</strong>格式也被应用于<strong>JAR</strong>(Java Archive,Java档案文件)文件格式中。这种格式就像<strong>Zip</strong>一样，可以将一组文件压缩到单个压缩文件中。</p>
</li>
<li><p>如果不采用<strong>JAR</strong>文件，<strong>Web</strong>浏览器在下载构成一个应用的所有文件时必须重复多次请求<strong>Web</strong>服务器；而且所有这些文件都是未经压缩的。如果将所有这些文件合并到一个<strong>JAR</strong>文件中，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，可以使传输时间更短。另外，处于安全考虑，<strong>JAR</strong>文件中的每个条目都可以加上数字化签名。</p>
</li>
<li><p><code>jar [options] destination [manifest] inputfile(s)</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>创建一个新的或空的压缩文档</td>
</tr>
<tr>
<td>t</td>
<td>列出目录表</td>
</tr>
<tr>
<td>x</td>
<td>解压所有文件</td>
</tr>
<tr>
<td>x file</td>
<td>解压该文件</td>
</tr>
<tr>
<td>f</td>
<td>意指：“我打算指定一个文件名。” 如果没有用这个选项，jar假设所有的输入都来自标准输入；或者在创建一个文件时，输出对象也假设为标准输出。</td>
</tr>
<tr>
<td>m</td>
<td>表示第一个参数将是用户自建的清单文件的名字</td>
</tr>
<tr>
<td>v</td>
<td>产生详细输出，描述jar所作的工作</td>
</tr>
<tr>
<td>O</td>
<td>只存储文件，不压缩文件(用来创建一个可放在类路径中的JAR文件)</td>
</tr>
<tr>
<td>M</td>
<td>不自动创建文件清单</td>
</tr>
</tbody></table>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><ul>
<li>当你创建对象时，只要你需要，它就会一直存在，但是在程序终止时，无论如何它都不会继续存在。但是仍旧存在某些情况，如果对象能够在程序不运行的情况下仍能存在并保存其信息，那将非常有用。</li>
<li><strong>Java</strong>的对象序列化将那些实现了<strong>Serializable</strong>接口的对象转换成了一个<strong>字节序列</strong>，并能在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。</li>
<li>序列化可以实现轻量级持久性。“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后在重新调用程序时恢复该对象，就能够实现持久化的效果。</li>
<li>对象序列化主要是为了支持两种特性：<ol>
<li><strong>Java</strong>的<strong>远程方法调用(Remote Method Invocation,RMI)</strong>，它使存活于其他计算机上的对象使用起来就像是存活于本机上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li>
<li>对<strong>Java Beans</strong>来说，对象的序列化也是必须的。使用<strong>Bean</strong>时，一般情况下是在设计阶段对它的状态信息进行配置。这种状态信息必须保留下来，并在程序启动时进行后期恢复；这种具体的工作就是由对象序列化完成的。</li>
</ol>
</li>
<li>要序列化一个对象，首先要创建某些<strong>OutputStream</strong>对象，然后将其封装在一个<strong>ObjectOutputStream</strong>对象内。这时，只需要调用<strong>writeObject()</strong>即可将对象序列化，并将其发送给<strong>OutputStream</strong>(对象化序列是基于字节的，因要使用<strong>InputStream</strong>和<strong>OutputStream</strong>继承层次结构)。要反向进行该过程(即将一个序列化还原为一个对象)，需要将一个<strong>InputStream</strong>封装在<strong>ObjectInputStream</strong>内，然后调用<strong>readObject()</strong>。我们最后获得的是一个引用，它指向一个向上转型的<strong>Object</strong>，所以必须向下转型才能直接设置它们。</li>
</ul>
<h4 id="寻找类"><a href="#寻找类" class="headerlink" title="寻找类"></a>寻找类</h4><ul>
<li><p>我们将一个对象序列化，并通过网络将其作为文件传递给另一台计算机，那么，另一台计算机上的程序可以只利用该文件内容来还原这个文件吗？</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    setter&amp;getter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreezeUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectOutput out = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"D://X.file"</span>));</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThawUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"D://X.file"</span>)));</span><br><span class="line">        Object mystery = in.readObject();</span><br><span class="line">        System.out.println(mystery.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.ym.ThinkingInJava.User</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件和读取<strong>mystery</strong>对象的内容都需要<strong>User</strong>的<strong>Class</strong>对象；而<strong>Java</strong>虚拟机找不到<strong>User.class</strong>(除非它正好在类路径<strong>Classpath</strong>内)。这样就会得到一个<strong>ClassNotFoundException</strong>的异常。必须保证<strong>Java</strong>虚拟机能找到相关的<strong>.class</strong>文件。</p>
</li>
</ul>
<h4 id="序列化的控制"><a href="#序列化的控制" class="headerlink" title="序列化的控制"></a>序列化的控制</h4><ul>
<li>某些情况下你不希望对象的某一部分被序列化；或者一个对象被还原以后，某子对象需要重新创建，从而不必将该子对象序列化。</li>
<li>在这些特殊情况下，可通过实现<strong>Externalizable</strong>接口—–代替实现<strong>Serialzable</strong>接口—来对序列化进行控制。<strong>Externalizable</strong>接口继承了<strong>Serializable</strong>接口，同时还增加了两个方法：<strong>writeExternal()</strong>和<strong>readExternal()</strong>。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</li>
</ul>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><ul>
<li><p>当我们对序列化进行控制时，可能某个特定子对象不想让Java的序列化机制自动保存与恢复。如果子对象表示的是我们不希望将其序列化的敏感信息，通常就会面临这种情况。即使对象中的这些信息是private属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式访问它。</p>
</li>
<li><p>如果我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以使用transient关键字逐个的关闭序列化。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logon</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logon</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"username = "</span>+username+<span class="string">"&amp;&amp;"</span>+<span class="string">"password = "</span>+password+<span class="string">"&amp;&amp;"</span>+<span class="string">"date"</span>+date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Logon a = <span class="keyword">new</span> Logon(<span class="string">"Tom"</span>,<span class="string">"11111111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span>+ a);</span><br><span class="line">        ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">                o.writeObject(a);</span><br><span class="line">                o.close();</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">"Logon.out"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Recovering object at "</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        a = (Logon)in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"logon a ="</span> + a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = 11111111&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">Recovering object at Sun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">logon a =username = Tom&amp;&amp;password = null&amp;&amp;dateSun Nov 17 20:25:13 CST 2019</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>date</strong>字段被存储到磁盘并从磁盘上被恢复出来，而且没有再重新生成。</p>
</li>
<li><p>由于<strong>Externalizable</strong>对象在默认情况下不保存它们的任何字段，所以<strong>transient</strong>关键字只能和<strong>Serializable</strong>对象一起使用。</p>
</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/I-O/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>I/O</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第十七章/">
      java编程思想第十七章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h2 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h2><h3 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h3><p><img src="/2019/11/17/java编程思想第十七章/1572948167233-1573995500325.png" alt="1572948167233"></p>
<ul>
<li>Java SE5新添加了：<ul>
<li><strong>Queue</strong>接口(<strong>LinkedList</strong>已经为实现该接口做了修改及其实现<strong>PrioityQueue</strong>和各种风格的<strong>BlockingQueue</strong>)。</li>
<li><strong>ConcurrentMap</strong>接口及其实现<strong>ConcurrentHashMap</strong>(用于多线程机制)。</li>
<li><strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>,它们也是用与多线程机制。</li>
<li><strong>EnumSet</strong>和<strong>EnumMap</strong>，为使用<strong>enum</strong>而设计的<strong>Set</strong>和<strong>Map</strong>的特殊实现。</li>
<li>在<strong>Collections</strong>类中的的多个便利方法，虚线框表示<strong>abstract</strong>类，它们只是部分实现了特定接口的工具。如：你可以在创建自己的<strong>Set</strong>,那么并不用从<strong>Set</strong>接口开始并实现其中的全部方法，只需从<strong>AbstractSet</strong>继承，然后执行一些创建新类必须的工作。</li>
</ul>
</li>
</ul>
<h3 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h3><ul>
<li><p>容器的填充仍然像java.util.Arrays一样面临不足。就像Arrays一样，相应的Collections类也有一些实用的static方法，其中包括fill()。与Arrays版本一样，此fill()方法也是只是复制同一个对象引用来填充整个容器的，并且只对List对象有用，但是所产生的列表可以传递给构造器或addAll()方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringAddress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringAddress</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StringAddress&#123;"</span> +</span><br><span class="line">                <span class="string">"s='"</span> + s + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;StringAddress&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(<span class="number">4</span>,<span class="keyword">new</span> StringAddress(<span class="string">"Hello"</span>)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.fill(list,<span class="keyword">new</span> StringAddress(<span class="string">"World"</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;, StringAddress&#123;s='Hello'&#125;]</span></span><br><span class="line"><span class="comment">[StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;, StringAddress&#123;s='World'&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面展示了两种对单个对象引用来填充Collection的方式。</p>
<ul>
<li>第一种是使用<strong>Collections.nCopies()</strong>创建传递给构造器的<strong>List</strong>，此处填充的是<strong>ArrayList</strong>。</li>
<li>第二种是使用<strong>Collection.fill()</strong>,<strong>fill()</strong>方法的用处有限，因为它只能替换已经在<strong>List</strong>中存在的元素，而不能添加新元素。</li>
</ul>
</li>
</ul>
<h3 id="Collection的功能方法"><a href="#Collection的功能方法" class="headerlink" title="Collection的功能方法"></a>Collection的功能方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(T)</td>
<td>确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends T&gt;)</td>
<td>添加参数中的所有元素，只要添加了任意元素就返回true(可选的)移除容器中的所有元素(可选的)</td>
</tr>
<tr>
<td>boolean contains(T)</td>
<td>如果容器已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td>Boolean containsAll(Collection&lt;?&gt;)</td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>容器中没有元素时返回true</td>
</tr>
<tr>
<td>Iterator<t> iterator()</t></td>
<td>返回一个Iterator<t>，可以用来遍历容器中的元素</t></td>
</tr>
<tr>
<td>Boolean remove(Object)</td>
<td>如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回true(可选的)</td>
</tr>
<tr>
<td>boolean removeAll(Collection&lt;?&gt;)</td>
<td>移除参数中的所有元素。只要有移除动作发生就返回true(可选的)</td>
</tr>
<tr>
<td>Boolean retainAll(Collection&lt;?&gt;)</td>
<td>只保存参数中的元素(应用集合论的“交集”概念)。只要Collection发生了改变就返回true(可选的)</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中元素的数目</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>返回一个数组，该数组包含容器中的所有元素</td>
</tr>
<tr>
<td><t> T[] toArray(T[] a)</t></td>
<td>返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object</td>
</tr>
<tr>
<td>void clear()</td>
<td>移除容器中的所有元素(可选)</td>
</tr>
</tbody></table>
<ul>
<li>其中不包括随机访问所选择元素的<strong>get()</strong>方法。因为<strong>Collection</strong>包括<strong>Set</strong>，而<strong>Set</strong>是自己维护内部顺序的。因此，如果想检查<strong>Collection</strong>中的元素，那就必须使用迭代器。</li>
</ul>
<h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><ul>
<li>执行各种不同的添加和移除的方法在<strong>Collection</strong>接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。</li>
<li>接口时面向对象设计中的契约，它声明“<strong>无论你选择如何实现该接口，我保证你可以向该接口发送这些消息</strong>”，但是可选操作违反了这个非常基本的原则，它声明调用某些方法将不会执行有意义的行为，相反，他会抛出异常。</li>
<li>如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。将Collection当作参数接受的大部分方法只会从该Collection中读取，而Collection的读取方法都不是可选的。</li>
<li>为什么将方法定义为可选的？因为这样做可以防止在设计中出现==接口爆炸==的情况。容器类库中的其他设计看起来总是为了描述每个主题的各种变体，而最终患上了接口过剩症。甚至这么做仍不能捕捉接口的各种特例，因为总有人发明新的接口，“未获支持的操作”这种方式可以实现Java容器类库的一个重要目标：==容器应该易学易用==。未获支持的操作是一种特例，可以延迟到需要时再实现。但是为了让这种方式能工作。<ol>
<li><strong>UnsupportedOperationException</strong>必须是一种罕见事件，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。这种设计留下了一个“后门”，如果你想要创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么它仍旧适合现有的类库。</li>
<li>如果一个操作是未获支持的，那么在实现接口的时候可能就会导致<strong>UnsupportedOperationException</strong>异常。毕竟，它表示编程上有错误，使用了不正确的接口实现。</li>
</ol>
</li>
<li>未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。</li>
</ul>
<h4 id="未获支持的操作"><a href="#未获支持的操作" class="headerlink" title="未获支持的操作"></a>未获支持的操作</h4><ul>
<li><p>常见的未获支持的操作，都来源于背后由==固定尺寸的数据结构支持的容器==，当你用<strong>Arrays.asList()</strong>将数组转换为<strong>List</strong>时，就会得到这样的容器。还可以通过使用<strong>Collections</strong>类中的“不可修改”的方法，选择创建任何会抛出<strong>UnsupportedOperationException</strong>的容器(包括Map)。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsupported</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String msg, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---"</span>+msg+<span class="string">"---"</span>);</span><br><span class="line">        Collection&lt;String&gt; c = list;</span><br><span class="line">        Collection&lt;String&gt; subList = list.subList(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> ArrayList&lt;&gt;(subList);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.retainAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"retainAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.removeAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"removeAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.clear();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"clean()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.add(<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.addAll(c2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"addAll()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.remove(<span class="string">"C"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"remove()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.set(<span class="number">0</span>,<span class="string">"X"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"List.set()"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A B C D E F G H I J K L"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        test(<span class="string">"Modifiable Copy"</span>,<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        test(<span class="string">"Arrays.asList()"</span>,list);</span><br><span class="line">        test(<span class="string">"unmodifiableList()"</span>, Collections.unmodifiableList(</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;(list)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Modifiable Copy---</span></span><br><span class="line"><span class="comment">---Arrays.asList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">---unmodifiableList()---</span></span><br><span class="line"><span class="comment">retainAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">removeAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">clean()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">add()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">addAll()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">remove()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">List.set()java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arrays.asList()</strong>会生成一个<strong>List</strong>，它基于一个固定大小的数组，仅支持那些不会改变数组大小的操作，任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个<strong>UnsupportedOpreationException</strong>异常，以表示对未获支持操作的调用(一个编程错误)。</p>
</li>
<li><p>应该把<strong>Arrays.asList()</strong>的结果作为构造器的参数传递给任何<strong>Collection</strong>(或者使用<strong>addAll()</strong>方法，或<strong>Collections.addAll()</strong>静态方法)，这样可以生成允许使用所有的方法的普通容器，这样的调用会产生新的尺寸可调的底层数据结构。</p>
</li>
<li><p><strong>Collections</strong>类中的”不可修改”的方法将容器包装到了一个代理中，只要你执行任何试图修改容器的操作，这个代理都会产生<strong>UnsupportedOperationException</strong>异常，使用这些方法的目标就是产生”常量”容器对象。</p>
</li>
</ul>
<h3 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h3><ul>
<li><p>在<strong>Java</strong>中像<strong>Integer</strong>和<strong>String</strong>这样的<strong>Java</strong>预定义的类型，这些类型被设计为可以在容器内部使用。当你创建自己的类型时，要意识到<strong>Set</strong>需要一种方式来维护存储顺序，而存储顺序如何维护，则是在<strong>Set</strong>的不同实现之间会有所变化。因此，不同的<strong>Set</strong>实现不仅具有不同的行为，而且它们对于可以在特定的<strong>Set</strong>中放置的元素的类型也有不同的要求。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Set</strong>(interface)</td>
<td>存入<strong>Set</strong>的每个元素都必须是唯一的，因为<strong>Set</strong>不保存重复元素。加入<strong>Set</strong>的元素必须定义<strong>equals()</strong>方法以确保对象的唯一性。<strong>Set</strong>与<strong>Collection</strong>有完全一样的接口。<strong>Set</strong>接口不保证维护元素的次序。</td>
</tr>
<tr>
<td><strong>HashSet</strong>(项目中最常使用)</td>
<td>为快速查找而设计的<strong>Set</strong>。存入<strong>HashSet</strong>的元素必须定义<strong>hashCode()</strong></td>
</tr>
<tr>
<td><strong>TreeSet</strong></td>
<td>保持次序的<strong>Set</strong>，底层为树结构。使用它可以从<strong>Set</strong>中提取有序的序列。元素必须实现<strong>Comparable</strong>接口。</td>
</tr>
<tr>
<td><strong>LinkedHashSet</strong></td>
<td>具有<strong>HashSet</strong>的查询速度，且内部使用链表维护元素的顺序(插入的顺序)。于是在使用迭代器遍历<strong>Set</strong>时，结果会按元素的次序显示。元素也必须定义<strong>hashCode()</strong>方法。</td>
</tr>
</tbody></table>
</li>
<li><p>你必须为散列存储和树形存储都创建一个<strong>equals()</strong>方法，但是<strong>hashCode()</strong>只有在这个类将被置于<strong>HashSet</strong>或<strong>LinkedHashSet</strong>中时才是必需的。但是建议你应该在覆盖<strong>equals()</strong>方法时，总是同时覆盖<strong>hashCode()</strong>方法。</p>
</li>
<li><p>下面演示为了成功的使用特定的Set实现类而必须定义的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        i = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> SetType &amp;&amp; (i == ((SetType)o).i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashType</span> <span class="keyword">extends</span> <span class="title">SetType</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HashType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">extends</span> <span class="title">SetType</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">TreeType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(TreeType arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (arg.i &lt; i ? -<span class="number">1</span> : (arg.i == i ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeForSets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">fill</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                set.add(</span><br><span class="line">                        type.getConstructor(<span class="keyword">int</span>.class).newInstance(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Set&lt;T&gt; set,Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        fill(set,type);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        test(<span class="keyword">new</span> TreeSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> HashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        test(<span class="keyword">new</span> LinkedHashSet&lt;TreeType&gt;(),TreeType.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;SetType&gt;(),SetType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> TreeSet&lt;HashType&gt;(),HashType.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="comment">[7, 7, 0, 8, 5, 9, 4, 1, 1, 3, 2, 3, 1, 9, 2, 8, 4, 6, 5, 4, 6, 8, 0, 3, 7, 5, 0, 6, 2, 9]</span></span><br><span class="line"><span class="comment">[2, 6, 1, 7, 1, 4, 0, 0, 9, 9, 9, 4, 7, 8, 0, 3, 8, 8, 7, 6, 3, 5, 5, 1, 6, 2, 2, 4, 3, 5]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">java.lang.RuntimeException: java.lang.ClassCastException: com.ym.ThinkingInJava.SetType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: com.ym.ThinkingInJava.HashType cannot be cast to java.lang.Comparable</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了证明那些方法对于某种特定的<strong>Set</strong>是必需的，并且同时还要避免代码重复，我们创建了三个类，基类<strong>SetType</strong>只存储一个<strong>int</strong>，并且通过<strong>toString()</strong>方法产生它的值。因为所有在<strong>Set</strong>中存储的类都必须具有<strong>equals()</strong>方法，因此在基类中也有该方法。其等价性是基于这个<strong>int</strong>类型的<strong>i</strong>的值来确定的。</p>
</li>
<li><p><strong>HashType</strong>继承自<strong>SetType</strong>，并且添加了<strong>hashCode()</strong>方法，该方法对于放置到<strong>Set</strong>的散列实现中的对象来说是必需的。</p>
</li>
<li><p><strong>TreeType</strong>实现了<strong>Comparable</strong>接口，如果一个对象被用于任何种类的排序容器中，如<strong>SortedSet</strong>(<strong>TreeSet</strong>的其唯一实现)，那么它必须实现这个接口。注：==在<strong>compareTo()</strong>中，没有使用“简洁明了”的形式<strong>return i-i2,</strong>因为这是一个常见的编程错误，它只有在<strong>i</strong>和<strong>i2</strong>都是无符号的<strong>int</strong>(如果<strong>Java</strong>确实有<strong>unsigned</strong>关键字的话，但实际上并没有)时才能正确工作。对于<strong>Java</strong>的有符号<strong>int</strong>，他就会出错，因为<strong>int</strong>不够大，不足以表现两个有符号<strong>int</strong>的差。如：<strong>i</strong>是一个很大的正数，而j是很大的负整数，<strong>i-j</strong>就会溢出并且返回负值，这就不正确了==。</p>
</li>
<li><p><strong>fill()</strong>和<strong>test()</strong>方法都是使用泛型定义的，这是为了避免代码重复。</p>
</li>
<li><p><strong>HashSet</strong>以某种神秘的顺序保存所有的元素，<strong>LinkedhashSet</strong>按照元素插入的顺序保存元素，而<strong>TreeSet</strong>按照排序顺序维护元素(按照<strong>compareTo()</strong>的实现方式，这里维护的是降序)</p>
</li>
<li><p>对于没有重新定义<strong>hashCode()</strong>方法的<strong>SetType</strong>或<strong>TreeType</strong>，如果将它们放置到任何散列实现中都会产生重复值，这样就违反了Set的基本契约。</p>
</li>
<li><p>如果在<strong>TreeSet</strong>中使用没有实现<strong>Comparable</strong>的类型，那么你将会得到更确定的结果，在<strong>TreeSet</strong>试图将该对象当作<strong>Comparable</strong>使用时，将抛出一个异常。</p>
</li>
</ul>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><ul>
<li>SortedSet中的元素可以保证处于排序状态，这使得它可以通过在SortedSet接口中的下列方法提供附加的功能：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Set</strong>使用的<strong>Comparator</strong>;或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>Object first()</strong></td>
<td>返回容器中的第一个元素。</td>
</tr>
<tr>
<td><strong>Object last()</strong></td>
<td>返回容器中的最末一个元素</td>
</tr>
<tr>
<td><strong>SortedSet subSet(fromElement,toElement)</strong></td>
<td>生成此Set的子集，范围从<strong>fromElement</strong>(包含)到<strong>toElement</strong>(不包含)</td>
</tr>
<tr>
<td><strong>SortedSet headSet(toElement)</strong></td>
<td>生成此<strong>Set</strong>的元素，由小于<strong>toElement</strong>的元素组成</td>
</tr>
<tr>
<td><strong>SortedSet tailSet(fromElement)</strong></td>
<td>生成此<strong>Set</strong>的子集，由大于或等于<strong>fromElement</strong>的元素组成</td>
</tr>
</tbody></table>
<ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        Collections.addAll(sortedSet,<span class="string">"one two three four five six seven eight"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i ==<span class="number">3</span>) low = it.next();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) high = it.next();</span><br><span class="line">            <span class="keyword">else</span> it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">        System.out.println(sortedSet.headSet(high));</span><br><span class="line">        System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">eight</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two</span></span><br><span class="line"><span class="comment">[one, seven, six, three]</span></span><br><span class="line"><span class="comment">[eight, five, four, one, seven, six, three]</span></span><br><span class="line"><span class="comment">[one, seven, six, three, two]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SortedSet</strong>是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用<strong>LinkedHashSet</strong>来保存。</p>
</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li><p>除并发应用，<strong>Queue在SE5中仅有的两个实现是LinkedList和PriorityQueue</strong>，两者的<strong>差异在于排序行为而不是性能</strong>。</p>
</li>
<li><p>下面是Queue实现的大部分操作的示例，包括基于并发的Queue.你可以将元素从队列的一端插入，并从另一端将它们抽取出来：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBehavior</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            queue.offer(gen.next());</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)</span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gen</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        String[] s = (<span class="string">"one two three four five six seven eight nine ten"</span>).split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> LinkedList&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(count), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line">        test(<span class="keyword">new</span> PriorityBlockingQueue&lt;String&gt;(), <span class="keyword">new</span> Gen());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">one two three four five six seven eight nine ten </span></span><br><span class="line"><span class="comment">eight five four nine one seven six ten three two </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了优先级队列(<strong>PriorityBlockingQueue,PriorityQueue</strong>)，<strong>Queue</strong>将精确地按照元素被置于<strong>Queue</strong>中的顺序产生它们。</p>
</li>
</ul>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><ul>
<li><p>该列表中的每个对象都包含一个字符串和一个主要的以及次要的优先级值。该列表的排序顺序也是通过实现Comparable而进行控制的。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoList</span> <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">ToDoList</span>.<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ToDoItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ToDoItem</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> primary;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> secondary;</span><br><span class="line">        <span class="keyword">private</span> String item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoItem</span><span class="params">(String td,<span class="keyword">char</span> pri, <span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.primary = pri;</span><br><span class="line">            <span class="keyword">this</span>.secondary = sec;</span><br><span class="line">            <span class="keyword">this</span>.item = td;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ToDoItem arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (primary &gt; arg.primary)</span><br><span class="line">                <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (primary == arg.primary)</span><br><span class="line">                <span class="keyword">if</span> (secondary &gt; arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (secondary == arg.secondary)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Character.toString(primary)+secondary+<span class="string">": "</span>+item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String td,<span class="keyword">char</span> pri,<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.add(<span class="keyword">new</span> ToDoItem(td,pri,sec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ToDoList toDoList = <span class="keyword">new</span> ToDoList();</span><br><span class="line">        toDoList.add(<span class="string">"Empty trash"</span>,<span class="string">'C'</span>,<span class="number">4</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed dog"</span>,<span class="string">'A'</span>,<span class="number">2</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed bird"</span>,<span class="string">'B'</span>,<span class="number">7</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Mow lawn"</span>,<span class="string">'C'</span>,<span class="number">3</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Water lawn"</span>,<span class="string">'A'</span>,<span class="number">1</span>);</span><br><span class="line">        toDoList.add(<span class="string">"Feed cat"</span>,<span class="string">'B'</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!toDoList.isEmpty())</span><br><span class="line">            System.out.println(toDoList.remove());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A1: Water lawn</span></span><br><span class="line"><span class="comment">A2: Feed dog</span></span><br><span class="line"><span class="comment">B1: Feed cat</span></span><br><span class="line"><span class="comment">B7: Feed bird</span></span><br><span class="line"><span class="comment">C3: Mow lawn</span></span><br><span class="line"><span class="comment">C4: Empty trash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><ul>
<li><p>双向队列(双端队列)就像是一个队列，但是你可以在任何一端添加或移除元素。在<strong>LinkedList</strong>中包含支持双向队列的方法，但是在<strong>Java</strong>标准类库中没有任何显式的用于双向队列的接口。因此，<strong>LinkedList</strong>无法去实现这样的接口，你也无法转型到<strong>Queue</strong>那样去向上转型为<strong>Deque(双向队列/dek/)</strong>。但是，你可以使用组合来创建一个<strong>Deque</strong>类，并直接从<strong>LinkedList</strong>中暴露相关的方法。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deque</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; deque = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        deque.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.getLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deque.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    ..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DequeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillTest</span><span class="params">(Deque&lt;Integer&gt; deque)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &lt; <span class="number">27</span>; i++) &#123;</span><br><span class="line">            deque.addFirst(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">50</span>; i &lt; <span class="number">55</span>; i++) &#123;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; di = <span class="keyword">new</span> Deque&lt;&gt;();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        System.out.println(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeFirst() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        fillTest(di);</span><br><span class="line">        <span class="keyword">while</span> (di.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(di.removeLast() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[26, 25, 24, 23, 22, 21, 20, 50, 51, 52, 53, 54]</span></span><br><span class="line"><span class="comment">26 25 24 23 22 21 20 50 51 52 53 54 </span></span><br><span class="line"><span class="comment">54 53 52 51 50 20 21 22 23 24 25 26 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你可能不太在两端放入元素并抽取它们，因此，<strong>Deque</strong>不如<strong>Queue</strong>那样常用。</p>
</li>
</ul>
<h3 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h3><ul>
<li><p>标准的<strong>Java</strong>类库中包含了<strong>Map</strong>的几种基本实现，包括：<strong>HashMap</strong>,<strong>TreeMap</strong>,<strong>LinkedHashMap</strong>,<strong>WeakHashMap</strong>,<strong>ConcurrentHashMap</strong>,<strong>IdentityHashMap</strong>。</p>
</li>
<li><p>上面实现类都有同样的基本接口<strong>Map</strong>，但是行为特征各不相同，==这表现在效率，键值对的保存及呈现次序，对象的保存周期，映射表如何在多线程程序中工作和判定“键”等价的策略等方面==。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssociativeArray</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AssociativeArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        pairs = <span class="keyword">new</span> Object[length][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= pairs.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">        pairs[index++] = <span class="keyword">new</span> Object[]&#123;key,value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++)</span><br><span class="line">            <span class="keyword">if</span> (key.equals(pairs[i][<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> (V)pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index;i++) &#123;</span><br><span class="line">            result.append(pairs[i][<span class="number">0</span>].toString());</span><br><span class="line">            result.append(<span class="string">" : "</span>);</span><br><span class="line">            result.append(pairs[i][<span class="number">1</span>].toString());</span><br><span class="line">            <span class="keyword">if</span> (i &lt; index - <span class="number">1</span>)</span><br><span class="line">                result.append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AssociativeArray&lt;String,String&gt; map = <span class="keyword">new</span> AssociativeArray&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">"sky"</span>,<span class="string">"blue"</span>);</span><br><span class="line">        map.put(<span class="string">"grass"</span>,<span class="string">"green"</span>);</span><br><span class="line">        map.put(<span class="string">"ocean"</span>,<span class="string">"dancing"</span>);</span><br><span class="line">        map.put(<span class="string">"tree"</span>,<span class="string">"tall"</span>);</span><br><span class="line">        map.put(<span class="string">"earth"</span>,<span class="string">"brown"</span>);</span><br><span class="line">        map.put(<span class="string">"sun"</span>,<span class="string">"warm"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">"extra"</span>,<span class="string">"object"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Too many objects!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"ocean"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Too many objects!</span></span><br><span class="line"><span class="comment">sky : blue</span></span><br><span class="line"><span class="comment">grass : green</span></span><br><span class="line"><span class="comment">ocean : dancing</span></span><br><span class="line"><span class="comment">tree : tall</span></span><br><span class="line"><span class="comment">earth : brown</span></span><br><span class="line"><span class="comment">sun : warm</span></span><br><span class="line"><span class="comment">dancing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关联数组中的基本方法是<strong>put()</strong>和<strong>get()</strong>,<strong>toString()</strong>方法被覆盖为可以打印键-值对，<strong>main()</strong>用字符串加载了一个<strong>AssociativeArray</strong>，并打印所产生的映射表，随后是获取一个值的<strong>get()</strong>。</p>
</li>
<li><p>上面中为了使用<strong>get()</strong>方法，你需要传递想要查找的<strong>key</strong>，然后它会将于之相关联的值作为结果返回，或者在找不到的情况下返回<strong>null</strong>，<strong>get()</strong>方法使用的是效率最差的方式来定位值的：从数组的头部开始，使用<strong>equals()</strong>方法依次比较键。</p>
</li>
<li><p>上面示例中的版本是说明性的，但是缺乏效率，并且由于固定的尺寸而显得很不灵活，但是在<strong>java.util</strong>中的各种<strong>Map</strong>都没有这些问题，并且可以替代到上面的示例中。</p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>性能是映射表中的一个重要问题，当在<strong>get()</strong>中使用线性搜索时，执行速度会相当地慢，而这正是<strong>HashMap</strong>提高速度的地方。<strong>HashMap</strong>使用了特殊的值，称为散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的，用以代表对象的<strong>int</strong>值，它是通过将该对象的某些信息进行转换而生成的。<strong>hashCode()</strong>是根类<strong>Object</strong>中的方法，因此所有<strong>Java</strong>对象都能产生散列码。</li>
<li>HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HashMap</strong>(默认选择)</td>
<td><strong>Map</strong>基于==散列表的实现==(它取代了<strong>Hashtable</strong>)。==插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。==</td>
</tr>
<tr>
<td><strong>LinkedHashMap</strong></td>
<td>类似于<strong>HashMap</strong>，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(<strong>LRU</strong>)的次序。==只比<strong>HashMap</strong>慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。==</td>
</tr>
<tr>
<td><strong>TreeMap</strong></td>
<td>基于红黑树的实现。==看“键“或”键值对“时，它们会被排序(次序由<strong>Comparable</strong>或<strong>Comparator</strong>决定)。====<strong>TreeMap</strong>的特点在于，所得到的结果是经过排序的。<strong>TreeMap</strong>是唯一的带有<strong>subMap()</strong>方法的<strong>Map</strong>，他可以返回一个子树。==</td>
</tr>
<tr>
<td><strong>WeakHashMap</strong></td>
<td>弱键(<strong>weak key</strong>)映射，允许释放映射所指向的对象；==这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个”键”，则此”键“可以被垃圾收集器回收。==</td>
</tr>
<tr>
<td><strong>ConcurrentHashMap</strong></td>
<td>一种线程安全的<strong>Map</strong>，它不涉及同步加锁。</td>
</tr>
<tr>
<td><strong>IdentityHashMap</strong></td>
<td>==使用代替<strong>equals()</strong>对”键“进行比较的散列映射，专为解决特殊问题而设计的。==</td>
</tr>
</tbody></table>
<ul>
<li>散列是映射中存储元素时最常用的方式。</li>
<li>对<strong>Map</strong>中使用的键的要求与对<strong>Set</strong>中的元素的要求一样，任何键都必须具有一个<strong>equals()</strong>方法；如果键被用于散列<strong>Map</strong>，那么它必须还具有恰当的<strong>hashCode()</strong>方法，如果键被用于<strong>TreeMap</strong>，那么它还必须实现<strong>Comparable</strong>。</li>
</ul>
<h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h4><ul>
<li>使用<strong>SortedMap</strong>(==<strong>TreeMap</strong>是现阶段的唯一实现==)，==可以确保键处于排序状态==，这使得它具有额外的功能，这些功能由<strong>SortedMap</strong>接口中的以下方法提供：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Comparator comparator()</strong></td>
<td>返回当前<strong>Map</strong>使用的<strong>Comparator</strong>；或者返回<strong>null</strong>，表示以自然方式排序。</td>
</tr>
<tr>
<td><strong>T firstKey()</strong></td>
<td>返回<strong>Map</strong>中的第一个键。</td>
</tr>
<tr>
<td><strong>T lastKey()</strong></td>
<td>返回<strong>Map</strong>中的最末一个键。</td>
</tr>
<tr>
<td><strong>SortedMap subMap(fromKey,toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，范围由<strong>fromKey</strong>(包含)到<strong>toKey</strong>(不包含)的键确定。</td>
</tr>
<tr>
<td><strong>SortedMap headMap(toKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键小于<strong>toKey</strong>的所有键值对组成。</td>
</tr>
<tr>
<td><strong>SortedMap tailMap(fromKey)</strong></td>
<td>生成此<strong>Map</strong>的子集，由键大于或等于<strong>fromKey</strong>的所有键值对组成。</td>
</tr>
</tbody></table>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul>
<li>为了==提高速度==，<strong>LinkedHashMap</strong>==散列化所有元素==，但是在==遍历键值对==时，却又==以元素的插入顺序返回键值对==(<strong>System.out.println()</strong>会迭代遍历该映射，因此可以看到遍历的结果)。此外，可以在构造器中设定<strong>LinkedHashMap</strong>，使之采用基于访问的==最近最少使用(<strong>LRU</strong>)算法==，于是==没有被访问过的==(可被看作需要删除的)==元素就会出现在队列的前面==。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</li>
</ul>
<h3 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h3><ul>
<li><p>当你自己创建用作<strong>HashMap</strong>的键的类，==有可能会忘记在其中放置必须的方法==，而这是通常会犯的一个错误。如：一个天气预报系统，将<strong>Groundhog</strong>对象与<strong>Prediction</strong>对象练习起来。创建这两个类，使用<strong>Groundhog</strong>作为键，<strong>Prediction</strong>作为值。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        number = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Groundhog&#123;"</span> +</span><br><span class="line">                <span class="string">"number="</span> + number +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prediction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> shadow = rand.nextDouble() &gt; <span class="number">0.5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shadow)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Six more weeks of Winter!"</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Early Spring"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Groundhog&gt; <span class="function"><span class="keyword">void</span> <span class="title">detectSpring</span><span class="params">(Class&lt;T&gt; type)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;T&gt; ghog = type.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Map&lt;Groundhog,Prediction&gt; map = <span class="keyword">new</span> HashMap&lt;Groundhog,Prediction&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            map.put(ghog.newInstance(i),<span class="keyword">new</span> Prediction());</span><br><span class="line">            System.out.println(<span class="string">"map="</span>+map);</span><br><span class="line">            Groundhog gh = ghog.newInstance(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"Looking up prediction for "</span>+gh);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(gh))</span><br><span class="line">                System.out.println(map.get(gh));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"Key not found:"</span> + gh);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        detectSpring(Groundhog.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#5=Early Spring, Groundhog#9=Six more weeks of Winter!, Groundhog#8=Six more weeks of Winter!, Groundhog#7=Early Spring, Groundhog#1=Six more weeks of Winter!, Groundhog#3=Early Spring, Groundhog#6=Early Spring, Groundhog#0=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#4=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Key not found:Groundhog#3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<strong>Groundhog</strong>被给予一个标识数字，于是可以在<strong>HashMap</strong>中这样查找<strong>Prediction</strong>,“给我与<strong>Groundhog#3</strong>相关的<strong>Prediction</strong>”。<strong>Prediction</strong>类包含一个<strong>boolean</strong>值和一个<strong>toString()</strong>方法。<strong>boolean</strong>值使用<strong>java.util.random()</strong>来初始化；而<strong>toString()</strong>方法则解释结果。<strong>detectSpring()</strong>方法使用反射机制来实例化及使用<strong>Groundhog</strong>类或任何从<strong>Groundhog</strong>派生出来的类。如果我们为解决当前问题从<strong>Groundhog</strong>继承创建了一个新类型的时候，<strong>detectSpring()</strong>方法使用的这个技巧就变得很有用了。</p>
</li>
<li><p>首先会使用<strong>Groundhog</strong>和与之相关联的<strong>prediction</strong>填充<strong>HashMap</strong>，然后打印<strong>HashMap</strong>，以便可以观察它是否被填入了一些内容。然后使用标识数字为3的<strong>Groundhog</strong>作为键，查找与之对应的预报内容。</p>
</li>
<li><p>但是它不工作，它无法找到数字3这个键，问题出在<strong>Groundhog</strong>自动的继承自基类<strong>Object</strong>，所以这里使用<strong>Object</strong>的<strong>hashCode()</strong>方法生成散列码，而==它默认是使用对象的地址计算散列码。==</p>
</li>
<li><p>也许你会认为，==只需要恰当的<strong>hashCode()</strong>方法的覆盖版本即可。但是它仍然无法正常运行，除非你同时覆盖<strong>equals()</strong>方法，==它也是<strong>Object</strong>的一部分。<strong>HashMap</strong>使用<strong>equals()</strong>判断当前的键是否与表中存在的键相同。</p>
</li>
<li><p>正确的<strong>equals()</strong>方法必须满足下面==5个条件==：</p>
<ol>
<li>==自反性。对任意x,x.equals(x)一定返回true。==</li>
<li>==对称性。对任意x和y，如果y.equals(x)返回true，则x.equals(y)也返回true。==</li>
<li>==传递性。对任意x,y,z,如果有x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)一定返回true。==</li>
<li>==一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。==</li>
<li>==对任何不是null的x，x.equals(null)一定返回false。==</li>
</ol>
</li>
<li><p>默认的<strong>Object.equals()</strong>只是==比较对象的地址==，所以一个<strong>Groundhog(3)</strong>并不等于另一个<strong>Groundhog(3)</strong>。因此，==<u>如果要使自己的类作为<strong>HashMap</strong>的键，必须同时重载<strong>hashCode()</strong>和<strong>equals()</strong></u>==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Groundhog2</span> <span class="keyword">extends</span> <span class="title">Groundhog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Groundhog2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> Groundhog2 &amp;&amp;</span><br><span class="line">                (number == ((Groundhog2)obj).number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDetector2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringDetector.detectSpring(Groundhog2.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">map=&#123;Groundhog#0=Six more weeks of Winter!, Groundhog#1=Six more weeks of Winter!, Groundhog#2=Early Spring, Groundhog#3=Early Spring, Groundhog#4=Six more weeks of Winter!, Groundhog#5=Early Spring, Groundhog#6=Early Spring, Groundhog#7=Early Spring, Groundhog#8=Six more weeks of Winter!, Groundhog#9=Six more weeks of Winter!&#125;Looking up prediction for Groundhog#3Early Spring</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尽管<strong>equals()</strong>方法只是检查其参数是否为<strong>Groundhog2</strong>的实例，但是<strong>instanceof</strong>悄悄地检查了此对象是否为<strong>null</strong>，因为如果<strong>instanceof</strong>左边的参数为<strong>null</strong>，它会返回<strong>false</strong>。如果<strong>equals()</strong>的参数不为<strong>null</strong>且类型正确，则基于每个对象中实际的<strong>number</strong>数值进行比较。</p>
</li>
<li><p>当在HashSet中使用自己的类作为键时，必须注意这个问题。</p>
</li>
</ul>
<h4 id="理解hashCode"><a href="#理解hashCode" class="headerlink" title="理解hashCode()"></a>理解hashCode()</h4><ul>
<li>上面说明了，如果不为你的键覆盖<strong>hashCode()</strong>和<strong>equals()</strong>，那么使用散列的数据结构(<strong>HashSet</strong>,<strong>HashMap</strong>,<strong>LinkedHashSet</strong>或<strong>LinkedHashMap</strong>)就无法正确处理你的键。</li>
<li>使用散列的目的在于：想要使用一个对象来查找另一个对象。</li>
<li>不过使用<strong>TreeMap</strong>或者你实现的<strong>Map</strong>也可以达到此目的。</li>
</ul>
<h4 id="为速度而散列"><a href="#为速度而散列" class="headerlink" title="为速度而散列"></a>为速度而散列</h4><ul>
<li>==散列的价值在于速度：散列使得查询得以快速进行==。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用<strong>Collections.binarySearch()</strong>进行查询。</li>
<li>散列则更近一步，它将键保存在某处，以便能很快找到，存储一组元素最快的数据结构是数组，所以使用它来表示键的信息，但是因为数组不能调整容量，因此会出现问题，我们希望在<strong>Map</strong>中保存数量不确定的值，但是如果键的数量被数组的容量限制了，该怎么办？</li>
<li>解决方案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在<strong>Object</strong>中的，且可能由你的类覆盖的<strong>hashCode()</strong>方法(在计算机科学的术语中称为散列函数)生成。</li>
<li>查询一个值的过程首先就是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突(如果值的数量是固定的，那么就有可能)，那可就有一个完美的散列函数，但是这种情况只是特例。通常，冲突由外部链接处理：==数组并不能直接保存值，而是保存值的<strong>list</strong>。==然后对<strong>list</strong>中的值使用<strong>equals()</strong>方法进行线性查询，这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个<strong>list</strong>，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是<strong>HashMap</strong>会如此之快的原因。</li>
</ul>
<h4 id="覆盖hashCode"><a href="#覆盖hashCode" class="headerlink" title="覆盖hashCode()"></a>覆盖hashCode()</h4><ul>
<li><p>设计<strong>hashCode()</strong>时最重要的因素就是：无论何时，对同一个对象调用<strong>hashCode()</strong>都应该生成同样的值。如果在将一个对象用<strong>put()</strong>添加进<strong>HashMap</strong>时产生一个<strong>hashCode()</strong>值，而用<strong>get()</strong>取出时却产生另一个<strong>hashCode()</strong>值，那么就无法重新取得该对象了。</p>
</li>
<li><p>此外，也不应该使<strong>hashCode()</strong>依赖于具有唯一性的对象信息，尤其是使用<strong>this</strong>的值，这只能产生糟糕的<strong>hashCode()</strong>。因为这样做无法生成一个新的键，使之与<strong>put()</strong>中原始的键值对中的键相同。</p>
</li>
<li><p><strong>String</strong>有个特点：==如果程序中有多个<strong>String</strong>对象，都包含相同的字符串序列，那么这些<strong>String</strong>对象都映射到同一块内存区域。==所以<strong>new String(“hello”)</strong>生成的两个实例，虽然是相互独立的，但是对它们使用<strong>hashCode()</strong>应该生成同样的结果。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHashCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] hellos = <span class="string">"Hello Hello"</span>.split(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(hellos[<span class="number">0</span>].hashCode());</span><br><span class="line">        System.out.println(hellos[<span class="number">1</span>].hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">69609650</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对<strong>String</strong>而言，<strong>hashCode()</strong>明显是基于<strong>String</strong>的内容的。</p>
</li>
<li><p>要想使<strong>hashCode()</strong>实用，它必须基于对象的内容生成散列码。(散列码不必是独一无二的，但是通过<strong>hashCode()</strong>和<strong>equals()</strong>，必须能够完全确定对象的身份)</p>
</li>
<li><p>因为在生成桶的下标前，<strong>hashCode()</strong>还需要做进一步的处理，所以散列码的生成范围并不重要，只要是<strong>int</strong>即可。</p>
</li>
<li><p>好的<strong>hashCode()</strong>应该产生分布均匀的散列码。如果散列码都集中在一块，那么<strong>HashMap</strong>或者<strong>HashSet</strong>在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p>
</li>
</ul>
<h3 id="选择接口的不同实现"><a href="#选择接口的不同实现" class="headerlink" title="选择接口的不同实现"></a>选择接口的不同实现</h3><ul>
<li><strong>Hashtable</strong>,<strong>Vector</strong>和<strong>Stack</strong>的“<strong>特征</strong>”是，它们是过去遗留下来的类，目的是为了支持老的程序(最好不要在新的程序中使用它们)</li>
<li>容器之间的区别通常归结为由什么在背后“支持”它们。也就是说，==所使用的接口是由什么样的数据结构实现的。==</li>
</ul>
<h4 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h4><ul>
<li>对于背后有数组支撑的<strong>List</strong>和<strong>ArrayList</strong>，无论列表的大小如何，访问都很快速和一致，而对于<strong>LinkedList</strong>，访问时间对于较大的列表将明显增加。显然，如果你需要执行大量的随机访问，链表不会是一种好的选择。</li>
<li>当在列表中间插入新的元素。对于<strong>ArrayList</strong>，当列表变大时，其开销将变得很高昂，但是对于<strong>LinkedList</strong>，相对来说比较低廉，并且不随列表尺寸而发生变化。这是因为<strong>ArrayList</strong>在插入时，必须创建空间并将它的所有引用向前移动，这会随<strong>ArrayList</strong>的尺寸增加而产生高昂的代价。<strong>LinkedList</strong>只需链接新的元素，而不必修改列表中剩余的元素。</li>
<li><strong>LinkedList</strong>对<strong>List</strong>的端点会进行特殊处理，这使得在将<strong>LinkedList</strong>用作<strong>Queue</strong>时，速度可以得到提高。但是，如果你在列表的中间增加或移除元素，其中会包含随机访问的代价，这在不同的<strong>List</strong>实现中变化很大。</li>
<li>在<strong>LinkedList</strong>中的插入和移除代价相当低廉，并且不随列表尺寸发生变化，但是对于<strong>ArrayList</strong>，插入操作代价特别高昂，并且其代价将随列表尺寸的增加而增加。</li>
<li>对于随机访问的<strong>get()</strong>和<strong>set()</strong>操作，背后有数组支撑的<strong>List</strong>只比<strong>ArrayList</strong>稍快一点，但是对于<strong>LinkedList</strong>，同样的操作会变得异常的高昂。因为它本身就不是针对随机访问操作而设计的。</li>
<li>==最佳的做法可能是将<strong>ArrayList</strong>作为默认首选==，只有你需要使用额外的功能，或者当程序的性能因为经常从表中进行插入和删除而变差的时候，才去选择<strong>LinkedList</strong>。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支撑的<strong>List</strong>(就像<strong>Arrays.asList()</strong>产生的列表)，也可以选择真正的数组。</li>
<li><strong>CopyOnWriteArrayList</strong>是<strong>List</strong>的特殊实现，专门用于并发编程。</li>
</ul>
<h4 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h4><ul>
<li><strong>HashSet</strong>的性能基本上总是比<strong>TreeSet</strong>好，特别是在添加和查询元素时，<strong>TreeSet</strong>存在的唯一原因是它可以维持元素的排序状态；所以，只有当需要一个排好序的<strong>Set</strong>时，才用<strong>TreeSet</strong>。因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，所以，用<strong>TreeSet</strong>迭代通常比用<strong>HashSet</strong>要快。</li>
<li>对于插入操作，<strong>LinkedHashSet</strong>比<strong>HashSet</strong>的代价更高；这是由维护链表所带来额外开销造成的。</li>
</ul>
<h4 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h4><ul>
<li>除了<strong>IdentityHashMap</strong>,所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。</li>
<li><strong>Hashtable</strong>的性能大体上与<strong>HashMap</strong>相当。因为<strong>HashMap</strong>是用来替代<strong>Hashtable</strong>的，因此它们使用了相同的底层存储和查找机制。</li>
<li><strong>TreeMap</strong>通常比<strong>HashMap</strong>要慢。与使用<strong>TreeSet</strong>一样，<strong>TreeMap</strong>是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。</li>
<li>当使用<strong>Map</strong>时，你的第一选择应该是<strong>HashMap</strong>,只有在你要求<strong>Map</strong>始终保持有序时，才需要使用<strong>TreeMap</strong>。</li>
<li><strong>LinkedHashMap</strong>在插入时比<strong>HashMap</strong>慢一点，因为它维护散列数据结构的同时还要维护链表(以保持插入顺序)。正是由于这个列表，使得其迭代速度更快。</li>
<li><strong>IdentityHashMap</strong>则具有完全不同的性能，==因为它使用的是<strong>==</strong>而不是<strong>equals()</strong>来比较元素。==</li>
</ul>
<h5 id="HashMap的性能因子"><a href="#HashMap的性能因子" class="headerlink" title="HashMap的性能因子"></a>HashMap的性能因子</h5><ul>
<li>我们可以通过手工调整<strong>HashMap</strong>来提高其性能，从而满足我们特定应用的需求。为了在调整<strong>HashMap</strong>时理解性能问题，下面术语必要了解以下：<ul>
<li>==<strong>容量</strong>==：表中的桶位数。</li>
<li>==<strong>初始容量</strong>==：表在创建时所拥有的桶位数。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定初始容量的构造器。</li>
<li>==<strong>尺寸</strong>==：表中当前存储的项数。</li>
<li>==<strong>负载因子</strong>==：尺寸/容量。==空表的负载因子是0==，==而半满表的负载因子是0.5，以此类推==。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的(但是会减慢使用迭代器进行遍历的过程)。<strong>HashMap</strong>和<strong>HashSet</strong>都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量(桶位数),实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中(这被称为再散列)。<strong>HashMap</strong>使用的默认负载因子是==0.75==(只有当表达到3/4满时，才进行再散列)，这个因子在时间和空间代价之间达到了平衡。</li>
</ul>
</li>
<li>如果你知道将要在<strong>HashMap</strong>中存储多少项，那么==创建一个具有恰当大小的初始容量将可以避免自动在散列的开销==。</li>
</ul>
<h4 id="Collection或Map的同步控制"><a href="#Collection或Map的同步控制" class="headerlink" title="Collection或Map的同步控制"></a>Collection或Map的同步控制</h4><ul>
<li><p>Collections类有办法能够自动同步整个容器。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        Set&lt;String&gt; tSet = Collections.synchronizedSet(<span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        Map&lt;String,String&gt; mm = Collections.synchronizedMap(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面直接将新生成的容器传递给了适当的“同步”方法；这样做就不会有任何机会暴露出不同步的版本。</p>
</li>
</ul>
<h5 id="快速报错"><a href="#快速报错" class="headerlink" title="快速报错"></a>快速报错</h5><ul>
<li><p><strong>Java</strong>容器有一个==保护机制==，==能够防止多个进程同时修改同一个容器的内容。如果在你迭代遍历某个容器的过程中，另一个进程介入其中，并且插入，删除或者修改此容器内的某个对象==，那么就会出现问题。Java容器类类库采用==快速报错(<strong>fail-fast</strong>)机制==。它会探查容器上的任何除了你的进程所进行的操作外的所有变化，一旦它发现其它进程修改了容器，就会立即抛出==<strong>ConcurrentModificationException</strong>==异常。</p>
</li>
<li><p>“快速报错”机制的工作原理：只需要创建一个迭代器，然后向迭代器所指向的<strong>Collection</strong>添加点什么，如下：</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFast</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        c.add(<span class="string">"An Object"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        String s = it.next();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>程序运行时发生了异常，因为在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。此例中，应该在添加完所有的元素之后，再获取迭代器。</p>
</li>
<li><p><strong>ConcurrentHashMap</strong>,<strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>都使用了可以避免<strong>ConcurrentModificationException</strong>的技术。</p>
</li>
</ul>
<h3 id="持有引用"><a href="#持有引用" class="headerlink" title="持有引用"></a>持有引用</h3><ul>
<li><strong>java.lang.ref</strong>类库包含了一组类，这些类为==垃圾回收提供了更大的灵活性==。==当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。==有三个继承自抽象类<strong>Reference</strong>的类：<strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>。当垃圾回收器正在考察的对象只能通过某个<strong>Reference</strong>对象才“==可获得==”时，上述这些不同的派生类==为垃圾回收器提供了不同级别的间接性指示==。</li>
<li>对象是可获得的(reachable)，是指此对象可在程序中的某处找到。这意味着你在栈中有一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对象含有另一个引用指向正在讨论的对象；也可能有更多的中间链接。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序将无法使用到它，所以将其回收是安全的。</li>
<li>如果想继续持有对某个对象的引用，希望后续还能够访问到该对象，但是也希望能够允许垃圾回收器释放它，这时就应该使用<strong>Reference</strong>对象。这样，你可以继续使用该对象，而在内存消耗殆尽的时候又允许释放该对象。</li>
<li>以<strong>Reference</strong>对象作为你和普通引用之间的媒介(代理)，另外，一定不能有普通的引用指向那个对象，这样就能达到上述目的。(普通的引用指没有经<strong>Reference</strong>对象包装过的引用)。如果垃圾回收器发现某个对象通过普通引用可获得的，该对象就不会被释放。</li>
<li><strong>SortReference</strong>,<strong>WeakReference</strong>和<strong>PhantomReference</strong>由强到弱排列，对应不同的级别的“可获得性”。<strong>Softreference</strong>用以实现内存敏感的告诉缓存。<strong>WeakReference</strong>是为实现“规范映射”而设计的，它不妨碍垃圾回收器回收映射的“键”(或“值”)。“规范映射”中的实例可以在程序的多处被同时使用，以节省存储空间。<strong>PhantomReference</strong>用以调度回收前的清理工作，它比Java终止机制更灵活。</li>
<li>使用<strong>SoftReference</strong>和<strong>WeakReference</strong>时，可以选择是否要将它们放入<strong>ReferenceQueue</strong>(用作“回收前清理工作”的工具)。而<strong>PhantomReference</strong>只能依赖于<strong>ReferenceQueue</strong>。</li>
</ul>
<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><ul>
<li><p>容器类中有一种特殊的<strong>Map</strong>，即<strong>WeakHashMap</strong>,它被用来保存<strong>WeakReference</strong>。在这种映射中，每个值只保存一份实例以节省存储空间。当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它(而不是重新在创建)。映射可将值作为其初始化中的一部分，不过通常是在需要的时候才生成“值”。</p>
</li>
<li><p>==这是一种节约存储空间的技术，因为<strong>WeakHashMap</strong>允许垃圾回收器自动清理键和值。允许清理元素的触发条件是，不再需要此键了。==</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ident;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        ident = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ident.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o <span class="keyword">instanceof</span> Element</span><br><span class="line">                &amp;&amp; ident.equals(((Element) o).ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing"</span> + getClass().getSimpleName() + <span class="string">" "</span> + ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanonicalMapping</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            Key[] keys = <span class="keyword">new</span> Key[size];</span><br><span class="line">            WeakHashMap&lt;Key,Value&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Key k = <span class="keyword">new</span> Key(Integer.toString(i));</span><br><span class="line">                Value v = <span class="keyword">new</span> Value(Integer.toString(i));</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    keys[i] = k;</span><br><span class="line">                    map.put(k,v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行此程序，会看到垃圾回收器每隔三个键就跳过一个，因为指向那个键的普通引用被存入了<strong>keys</strong>数组，所以那些对象不能被垃圾回收器回收。</p>
</li>
</ul>
<h3 id="Java-1-0-1-1的容器"><a href="#Java-1-0-1-1的容器" class="headerlink" title="Java 1.0/1.1的容器"></a>Java 1.0/1.1的容器</h3><h4 id="Vector和Enumeration"><a href="#Vector和Enumeration" class="headerlink" title="Vector和Enumeration"></a>Vector和Enumeration</h4><ul>
<li>在<strong>Java 1.0/1.1</strong>中，<strong>Vector</strong>是==唯一可以自我扩展的序列==。基本上，可以将其看作是<strong>ArrayList</strong>。但是具有有长有难记的方法名，在订正过的<strong>Java</strong>容器类类库中，<strong>Vector</strong>被改造过，可将其归类为<strong>Collection</strong>和<strong>List</strong>。</li>
<li><strong>Java 1.0/1.1</strong>版的迭代器发明了一个新的名字—<strong>枚举</strong>，取代了为人熟知的术语(<strong>迭代</strong>器)。此<strong>Enumeration</strong>接口比<strong>Iterator</strong>小，只有两个名字很长的方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasMoreElements()</td>
<td>如果此枚举包含更多的元素，该方法就返回true</td>
</tr>
<tr>
<td>Object nextElement()</td>
<td>该方法返回此枚举中的下一个元素(如果还有的话)，否则抛出异常。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Enumeration</strong>只是接口而不是实现，所以有时新的类库仍然使用了旧的<strong>Enumeration</strong>。虽然在你的代码中应该尽量使用<strong>Iterator</strong>，但也得有准备，类库可能会返回给你一个<strong>Enumeration</strong>。</li>
</ul>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul>
<li><strong>Java 1.0/1.1</strong>的<strong>Stack</strong>很奇怪，竟然不是用<strong>Vector</strong>来构建<strong>Stack</strong>，而是继承<strong>Vector</strong>。所以它拥有<strong>Vector</strong>所有的特点和行为，再加上一些额外的<strong>Stack</strong>行为。(很难理解设计者是否意识到这样做特别有用处，或者只是一个幼稚的设计，但是你永远都不应该使用它)</li>
</ul>
<h4 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h4><ul>
<li>如果想要高效地存储大量“开/关”信息，<strong>BitSet</strong>是很好的选择。不过它的效率仅是对空间而言；如果想要高效的访问时间，<strong>BitSet</strong>比本地数组稍慢一点。</li>
<li><strong>BitSet</strong>的最小容量是<strong>long</strong>：<strong>64</strong>位。如果要存储的内容比较小，那么<strong>BitSet</strong>就浪费了一些空间。</li>
</ul>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java</a>
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/容器/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>容器</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/11/17/java编程思想第二章/">
      java编程思想第二章
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    <a href="http://yoursite.com" rel="nofollow">
      
        <i class="fas fa-user" aria-hidden="true"></i>
      
      <p>Yan Mao</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-17</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/categories/java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>java</p>
    </a>
  </div>


          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1 id="java编程思想总结"><a href="#java编程思想总结" class="headerlink" title="java编程思想总结"></a>java编程思想总结</h1><h2 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章:一切都是对象"></a>第二章:一切都是对象</h2><h3 id="1-用引用操作对象"><a href="#1-用引用操作对象" class="headerlink" title="1. 用引用操作对象"></a>1. 用引用操作对象</h3><ul>
<li><h5 id="在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference"><a href="#在java中一切都被视为-对象-因此可采用单一固定的语法-尽管一切都被视为对象-但我们操作的标识符实际是只是对象的一个-引用-reference" class="headerlink" title="在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)"></a>在java中一切都被视为==对象==,因此可采用单一固定的语法,尽管一切都被视为对象,但我们操作的标识符实际是只是对象的一个==引用==(reference)</h5></li>
<li><p>你拥有一个引用,并不一定需要一个对象与他关联.(String s;)</p>
</li>
</ul>
<h3 id="2-必须由你创建所有对象"><a href="#2-必须由你创建所有对象" class="headerlink" title="2. 必须由你创建所有对象"></a>2. 必须由你创建所有对象</h3><ul>
<li>一旦创建一个引用,就希望他能与一个新的对象产生关联,通常用==new==来实现这一目的,new的意思是给我一个新对象</li>
</ul>
<h3 id="3-存储到什么地方"><a href="#3-存储到什么地方" class="headerlink" title="3.存储到什么地方"></a>3.存储到什么地方</h3><ul>
<li>寄存器:这是最快的存储区,位于不同于其他存储区的位置——-处理器内部,但是寄存器数量极其有限,所以寄存器根据需求进行分配,不能直接控制.</li>
<li>堆栈:位于通用RAM(随机访问存储器),通过堆栈指针可以从处理器哪里获得直接支持,堆栈指针若向下移动,则分配新内存,若向上移动,则释放哪些内存,这是一种快速有效的存储方式,仅次于寄存器,创建程序时,java必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针,java对象的引用存储在堆栈,但是java对象并不存储于其中.</li>
<li>堆:一种通用的内存池(位于ram区)用于存放java对象,不同于堆栈的好处是:编译器不需要知道存储的数据在堆里能存活多长时间,因此,在堆里分配存储有很大的灵活性,当我们在new一个对象的时候,会自动地在堆里进行存储分配,当然,为这种灵活性必须付出代价,用堆进行存储分配和清理可能会比用堆栈进行存储分配需要更多时间.</li>
<li>常量存储:常量值通常直接存放在程序代码内部,这样做是安全的,因为他们永远不会被改变.</li>
<li>非RAM存储:如果数据完全存活于程序之外,那么他可以不受程序的任何控制,在程序没有运行时也可以存在,两个最基本的例子就是”流对象”,”持久化对象”,在”流对象”中,对象转换成字节流,通常被发送给另一台机器,在”持久化对象”中,对象被存放在磁盘上.</li>
</ul>
<h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><ul>
<li><p>在程序中经常用到一系列类型,他们需要被特殊对待,可以把他们想象成”基本”类型,之所以被特殊对待,是因为==<strong>new将对象存储在”堆”里</strong>==,故用new创建一个对象,特别是小的简单的变量,不是很有效,对于这些类型,我们不用new来创建变量,而是创建一个并非是引用的”自动”变量,这个变量直接存储”值”并置放于堆栈中,效率更高.</p>
</li>
<li><p>java要确定每种基本类型所占存储空间的大小,他们的大小不像其他语言那样随机器硬件架构的变化而变化,正是这种原因使得java程序更具有可移植性.</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">大小</th>
<th align="left">最小值</th>
<th align="left">最大值</th>
<th align="left">包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">16 bit</td>
<td align="left">Unicode 0</td>
<td align="left">Unicode 0</td>
<td align="left">Character</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">8 bit</td>
<td align="left">-128</td>
<td align="left">127</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">16 bit</td>
<td align="left">$-2^{15}$</td>
<td align="left">$2^{15}-1$</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">32 bit</td>
<td align="left">$-2^{31}$</td>
<td align="left">$2^{31}-1$</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">64 bit</td>
<td align="left">$-2^{63}$</td>
<td align="left">$2^{63}-1$</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">32 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">64 bit</td>
<td align="left">IEEE754</td>
<td align="left">IEEE754</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">——–</td>
<td align="left">Void</td>
</tr>
</tbody></table>
</li>
<li><p>高精度数字</p>
<ul>
<li>java提供了用于高精度计算的类:<strong>BigInteger</strong>(整数)和<strong>BigDecimal</strong>(小数)(用于精确的货币计算)</li>
</ul>
</li>
</ul>
<h3 id="5-永远不需要销毁对象"><a href="#5-永远不需要销毁对象" class="headerlink" title="5.永远不需要销毁对象"></a>5.永远不需要销毁对象</h3><ul>
<li><p>作用域(scope)</p>
<ul>
<li>作用域决定了在其内部定义的变量名的可见性和生命周期,作用域由花括号的位置决定.</li>
</ul>
</li>
<li><p>对象的作用域</p>
<ul>
<li>java有一个垃圾回收器,用于监视用new创建的所有对象,并辨别那些不会在被引用的对象,随后,释放这些对象的内存空间,以便供其他新的对象使用.</li>
</ul>
</li>
<li><p>默认成员类型</p>
<ul>
<li><p>若类的某个成员是基本数据类型,即使没有初始化,java也会确保它获得一个默认值,前提必须是作为<strong>成员变量</strong>使用.</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>f</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’(null)</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//正常运行输出0</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果作为局部变量,会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2019/11/17/java编程思想第二章/1559358469727-1573995008036.png" alt="1559358469727"></p>
<h3 id="6-static"><a href="#6-static" class="headerlink" title="6.static"></a>6.static</h3><ol>
<li>优势<ul>
<li>只想为某特定域分配单一存储空间,而不去考虑究竟要创建多少对象,甚至根本不用创建对象.</li>
<li>希望某个方法不与包含他的类的任何对象关联在一起,也就是说,即使没有创建对象,也能够调用这个方法.</li>
</ul>
</li>
</ol>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/java编程思想/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>java编程思想</a>
        
          <a href="/tags/读书笔记/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>读书笔记</a>
        
          <a href="/tags/面向对象/" rel="nofollow"><i class="fas fa-hashtag fa-fw"></i>面向对象</a>
        
      </div>
    
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class='l_side'>
  
    
    
      
        
          
          
            <section class='widget author'>
  <div class='content pure'>
    
    
    
  </div>
</section>

          
        
      
        
          
          
            

          
        
      
        
          
          
            <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="/" href="/"
          
          
          id="home">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/YanMao186" href="https://github.com/YanMao186"
          
          
          id="https:github.comYanMao186">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          github
        </a></li>
      
        <li><a class="flat-box" title="/about/" href="/about/"
          
            rel="nofollow"
          
          
          id="about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

          
        
      
        
          
          
            
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/categories/"
    title="blog/categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/HTTP-TCP-IP/" href="/categories/HTTP-TCP-IP/"><div class='name'>HTTP/TCP/IP</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MySQL/" href="/categories/MySQL/"><div class='name'>MySQL</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/java/" href="/categories/java/"><div class='name'>java</div><div class='badge'>(18)</div></a></li>
        
      </ul>
    </div>
  </section>


          
        
      
        
          
          
            
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="/blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/tags/java-并发/" style="font-size: 14px; color: #999">-java -并发</a> <a href="/tags/Http/" style="font-size: 14px; color: #999">Http</a> <a href="/tags/I-O/" style="font-size: 14px; color: #999">I/O</a> <a href="/tags/IO/" style="font-size: 14px; color: #999">IO</a> <a href="/tags/MVC/" style="font-size: 14px; color: #999">MVC</a> <a href="/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/tags/ORM/" style="font-size: 14px; color: #999">ORM</a> <a href="/tags/Spring-Cloud/" style="font-size: 14px; color: #999">Spring Cloud</a> <a href="/tags/java/" style="font-size: 24px; color: #555">java</a> <a href="/tags/java编程思想/" style="font-size: 19px; color: #777">java编程思想</a> <a href="/tags/jvm/" style="font-size: 21.5px; color: #666">jvm</a> <a href="/tags/mysql/" style="font-size: 14px; color: #999">mysql</a> <a href="/tags/tcp-ip/" style="font-size: 14px; color: #999">tcp/ip</a> <a href="/tags/多线程/" style="font-size: 19px; color: #777">多线程</a> <a href="/tags/容器/" style="font-size: 14px; color: #999">容器</a> <a href="/tags/微服务/" style="font-size: 14px; color: #999">微服务</a> <a href="/tags/读书笔记/" style="font-size: 14px; color: #999">读书笔记</a> <a href="/tags/集合/" style="font-size: 14px; color: #999">集合</a> <a href="/tags/面向对象/" style="font-size: 16.5px; color: #888">面向对象</a>
    </div>
  </section>


          
        
      
        
          
          
            


  <section class='widget music'>
    
<header class='pure'>
  <div><i class="fas fa-compact-disc fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;最近在听</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_blank"
    
    href="http://music.163.com/playlist?id=2758693024&userid=76931878"
    title="http://music.163.com/playlist?id=2758693024&userid=76931878">
    <i class="far fa-heart fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css">
  <div class="aplayer"
    data-theme="#1BCDFC"
    
    
    data-mode="circulation"
    data-server="netease"
    data-type="playlist"
    data-id="2758693024"
    data-volume="0.5">
  </div>
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>


    </div>
  </section>


          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="" target="_blank" class="codename">Hello World</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/16/2019 23:30:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>





	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          [""],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.5/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
 

<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<!-- 数字雨 -->
<canvas id="canvas" width="1440" height="900" ></canvas>
<script type="text/javascript">

		
		window.onload = function(){
			//获取画布对象
			var canvas = document.getElementById("canvas");
			//获取画布的上下文
			var context =canvas.getContext("2d");
			  var s = window.screen;
             var W = canvas.width = s.width;
             var H = canvas.height;
			//获取浏览器屏幕的宽度和高度
			//var W = window.innerWidth;
			//var H = window.innerHeight;
			//设置canvas的宽度和高度
			canvas.width = W;
			canvas.height = H;
			//每个文字的字体大小
			var fontSize = 16;
			//计算列
			var colunms = Math.floor(W /fontSize);	
			//记录每列文字的y轴坐标
			var drops = [];
			//给每一个文字初始化一个起始点的位置
			for(var i=0;i<colunms;i++){
				drops.push(0);
			}

			//运动的文字
			var str ="javascript html5 canvas  严茂 www.mryanmao.top";
			//4:fillText(str,x,y);原理就是去更改y的坐标位置
			//绘画的函数
			function draw(){
				context.fillStyle = "rgba(0,0,0,.08)";//遮盖层
				context.fillRect(0,0,W,H);
				//给字体设置样式
				context.font = "700 "+fontSize+"px  微软雅黑";
				//给字体添加颜色
				context.fillStyle = "green";//randColor();可以rgb,hsl, 标准色，十六进制颜色
				//写入画布中
				for(var i=0;i<colunms;i++){
					var index = Math.floor(Math.random() * str.length);
					var x = i*fontSize;
					var y = drops[i] *fontSize;
					context.fillText(str[index],x,y);
					//如果要改变时间，肯定就是改变每次他的起点
					if(y >= canvas.height && Math.random() > 0.99){
						drops[i] = 0;
					}
					drops[i]++;
				}
			};

			function randColor(){//随机颜色
				var r = Math.floor(Math.random() * 256);
				var g = Math.floor(Math.random() * 256);
				var b = Math.floor(Math.random() * 256);
				return "rgb("+r+","+g+","+b+")";
			}

			draw();
			setInterval(draw,30);
		};

	
</script>
</body>
</html>
